# 计算机原理
[TOC]

# 一 概述
## 3 常识
### 3.1 从键盘输入的都是字符

# 三 计算机原理和硬件
## 1 CPU
通常，现代CPU主要由运算单元(运算器)、控制单元(控制器)和存储单元(寄存器)三大部分组成，其他部分还包括时钟等。

上下文切换:上下文切换，就是先把前一个任务的 CPU 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳到程序计数器所指的新位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。根据任务的不同，CPU 的上下文切换可以分为几个不同的场景：进程上下文切换、线程上下文切换、中断上下文切换。

### 运算器(运算器)
运算器是计算机对数据进行加工处理的中心，它主要由三个部分组成:
1. 算术逻辑部件（ALU：Arithmetic and Logic Unit）:ALU主要完成对二进制信息的定点算术运算、逻辑运算和各种移位操作。
2. 寄存器组:通用寄存器组是用来保存参加运算的操作数和运算的中间结果。
3. 状态寄存器组成:状态寄存器在不同的机器中有不同的规定，程序中，状态位通常作为转移指令的判断条件。

### 控制单元(控制器)
控制器是计算机的控制中心，它决定了计算机运行过程的自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。控制器一般包括:
1. 指令寄存器(Instruction Register,IR):指令控制逻辑要完成取指令、分析指令和执行指令的操作。
2. 时序控制逻辑:时序控制逻辑要为每条指令按时间顺序提供应有的控制信号。
3. 总线控制逻辑：为多个功能部件服务的信息通路的控制电路。就CPU而言一般分为内部总线和CPU对外联系的外部总线，外部总线有时候又叫做系统总线、前端总线（FSB）等。
4. 中断控制逻辑:中断是指计算机由于异常事件，或者一些随机发生需要马上处理的事件，引起CPU暂时停止现在程序的执行，转向另一服务程序去处理这一事件，处理完毕再返回原程序的过程。由机器内部产生的中断，把它叫做陷阱（内部中断），由外部设备引起的中断叫外部中断。
5. 等等

控制单元包含程序计数器。

### 存储单元(寄存器)
CPU 寄存器是 CPU 内置的容量小、速度极快的内存

### 时钟

## 2 关于ROM、RAM、硬盘
1. 内存分ROM(只读存储器)和RAM(随机存储器)两部分，而硬盘是外存。
2. ROM=Read Only Memory,光盘(非可刻录)属于ROM,是只读存储器，是内存的一种，断电后数据还在
3. RAM=Random Access Memory,随机存储器,是内存的一种，断电后数据消失
4. 额外的：手机的ROM相当于PC的硬盘，因为手机没有硬盘这个叫法

## 3 进程运行时的内存（似乎c/c++也是这样分的）
在Windows平台下，高级语言写出的程序经过编译链接，最终会变成PE文件。当PE文件被装载运行后，就成了所谓的进程。进程使用的内存都可以按照功能大致分为以下4个部分：
1. 代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取指并执行。
2. 数据区：用于存储全局变量等。
3. 堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。
4. 栈区：用于动态地存储函数之间的关系，以保证被调用函数在返回时恢复到母函数中继续执行。

## 4 各种进制
1. 为什么计算机中常用八进制和十六进制(除开二进制)
    数据在计算机中的表示，最终以二进制的形式存在。因为2、8、16，分别是2的1次方、3次方、4次方。这一点使得三种进制之间可以非常直接地互相转换。8进制或16进制缩短了二进制数，但保持了二进制数的表达特点。
    
### 4.1 十六进制(Hexadecimal)
参考：
1. https://en.wikipedia.org/wiki/Hexadecimal

1. 表示方法
    1. 十六进制的整数：以`0x`或`0X`开头(其中`0`是数字，`x`不区分大小写),后面每位的取值范围是`0~9`和`A~F`，也不区分大小写，如`0x123`表示十进制的291，`0x4e`表示十进制的78
    2. 十六进制转义字符：`\xST`,`S` and `T` are any of 0123456789abcdefABCDEF，比如`\x4e`表示字符`N`，范围是`\x00`到`\xff`
2. 转换
    1. 十进制转十六进制:十进制数的整数部分“除以16取余”，十进制数的小数部分“乘16取整”，进行转换。
    2. 十六进制转十进制
3. 十六进制只能表达无符号的整数？

### 4.2 八进制(octal)
表示方法：
1. 八进制的整数：以数字`0`开头，后面每位的取值范围是`0~7`,比如`043`,`044`表示十进制的35和36
2. 八进制的转义字符:`\0ST`,`S` and `T` are any of 012345678，比如`\043`,`\044`表示字符`#`和`$`，范围是`\000`到`\077`

### 4.3 二进制

## 5 关于原码、补码、反码
所有数字在计算机底层都是以二进制的形式存的，原码是直接将一个数值换算成二进制数。计算机以补码的形式保存所有的整数。正数的补码和原码相同，负数的补码是其反码+1。反码是对原码按位取反，只是最高位（符号位）保持不变。

## 6 关于屏幕保护
对于CRT显示器(以前的老显示器),确实有保护作用;但对LCD显示器(一般指液晶显示器,现代的笔记本等基本都是)则是帮倒忙,所以最好不要开

## 7 关于文本输入模式、backspace、insert和delete键
1. 一般的文本输入模式(linux也是?)包括:插入模式和覆盖模式.在早期的计算机终端里，如果切换为覆盖模式，光标会变成一个方块而不是通常的竖线。
    - 覆盖模式，光标位置新输入字会替代原来的字
    - 插入模式，新输入的字插入到光标位置，原来的字相应后移。

2. `backspace`是退格键,删除光标左边的字符,`isnert`是插入键,用于开关文本输入模式,`delete`是删除键,删除光标右边的字符,还可以删除文件(?);如果在选中状态下,`backspace`和`delete`都是删除

## 8 关于键盘(win)上的各个按键
1. `scroll lock`(滚动锁定键):(待补充)

## 11 关于动态和静态语言、强弱类型语言、解释和编译型语言
### 11.1 动态语言和静态语言
变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。
### 11.2 动态类型语言和静态类型语言
和上面不是一个概念。动态类型语言是指在运行期间才去做数据类型检查的语言，即数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段；静态类型语言的数据类型是在编译期间确定
### 11.3 强类型语言和弱类型语言
强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型；而弱类型语言表示一个变量可以赋不同数据类型的值
### 11.4 编译和解释型语言
不太推荐仅仅用这两种类型来划分编程语言,具体参考:[http://rednaxelafx.iteye.com/blog/492667](http://rednaxelafx.iteye.com/blog/492667)
1. 解释型语言

    源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由专门的解释器(实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的)对中间代码进行解释运行。每执行一次都要翻译一次。因此效率比较低但跨平台性好.比如
    - Python
    - JavaScript 
    - Perl 
    - Shell
2. 编译型语言

    编译型语言的首先将源代码编译生成机器语言，再由机器运行机器码(二进制).如,
    - C/C++
    - Delphi
## 12. 软件开发环境－开发环境、测试环境、生产环境的区别：  
项目部署环境一般可分为三种：生产环境，测试环境，开发环境
1. 开发环境(dev)：开发环境时程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告和测试工具，是最基础的环境。开发环境的分支，一般是feature分支。
2. 测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产服务器上，是开发环境到生产环境的过度环境。测试环境的分支一般是develop分支，部署到公司私有的服务器或者局域网服务器上，主要用于测试是否存在bug，一般会不让用户和其他人看到，并且测试环境会尽量与生产环境相似。
3. 生产环境(prod)： 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志，是最重要的环境。部署分支一般为master分支。
三个环境也可以说是系统开发的三个阶段：开发->测试->上线，其中生产环境也就是通产说的真实的环境，最后交给用户的环境。
## 13. 高内聚、低耦合
这两个是模块设计所追求的。高内聚（尽可能把模块的内部数据、功能实现细节隐藏在模块内部独立完成，不允许外部直接干预）、低耦合（仅暴露少量的方法给外部使用）
## 14 关于注释的位置
来自网友的回答：
1. 变量声明或初始化，放在右方
2. 简短代码块声明放在上方
3. 注释过长使用多行注释，并放在上方
4. 重点是，不要为了注释而注释，变量、函数等命名规范了，代码能清晰看懂就尽量往这个方向努力。毕竟有 “代码之美”，而未曾听说有 “注释之美”。
## 15 主程
目前泛指软件行业中主要的技术开发程序员。
## 16 关于过程式编程、面向对象编程和函数式编程(Functional Programming)
(待补充)
## 17 关于usb接口和ps2接口
最大的区别之一是usb支持热拔插，而ps2不支持,意味着后者重新连接后需要重启电脑才行

## 19 编程中变量命名方式
常见命名方法：
- camelCase(驼峰):包含大驼峰和小驼峰
    - UpperCamelCase(大驼峰)、PascalCase(帕斯卡命名法):如`PlayStation`。推荐类名使用该方式命名。
    - lowerCamelCase(小驼峰):如`backColor`：推荐方法名、参数名、成员变量、局部变量需要使用小驼峰命名法。
- kebab-case（短横线命名法/串式命名法）：各个单词之间通过连接符`-`连接。推荐项目文件夹名称、js中组件用该方式命名。
- snake_case（蛇形命名法）:各个单词之间通过下划线`_`连接，需要命名的单词比较多的时候用snake_case命名是可读性最高的。比如`should_get_200_status_code_when_request_is_valid`，用lowerCamelCase写的话是`shouldGet200StatusCodeWhenRequestIsValid`，可读性会比较差。通常推荐测试方法名、常量、枚举名称使用蛇形命名法。
- Hungarian(匈牙利命名法)

常见命名方法输入效率和可读性对比：
1. 输入效率：lowercase > camelCase > PascalCase > kebab-case > snake_case
2. 可读性：snake_case > kebab-case > camelCase = PascalCase > lowercase

### 19.1 驼峰命名法 camelCase
- UpperCamelCase(大驼峰)、PascalCase(帕斯卡命名法):如`PlayStation`
- lowerCamelCase(小驼峰):如`backColor`

### 19.2 匈牙利命名法 Hungarian
广泛应用于象Microsoft Windows这样的环境中。Windows 编程中用到的变量(还包括宏)的命名规则为匈牙利命名法，这种命名技术是由一位能干的 Microsoft 程序员查尔斯-西蒙尼(Charles Simonyi) 提出的。

匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域、类型等。这些符号可以多个同时使用，顺序是先m_(成员变量)、再指针、再简单数据类型、再其它。这样做的好处在于能增加程序的可读性，便于对程序的理解和维护。

例如：`m_lpszStr`, 表示指向一个以0字符结尾的字符串的长指针成员变量，`iMyData`
匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。

不过现在该命名方法已经逐渐被淘汰了

### 19.3 kebab-case 短横线分隔命名
如`my-component-name`

## 20 编程范式(Programming paradigm)
编程范式(Programming paradigm) 其实就是计算机编程所使用的方法，是设计程序结构所采用的设计风格。

目前主流的编程范式有：
- 命令式编程(Imperative programming)、面向过程式编程（Procedure Oriented Programming）
- 函数式编程(Functional programming)
    - 响应式编程(Reactive Programming或Functional Reactive Programming)
- 面向对象编程(Object-oriented programming)
- 面向切面编程(Aspect Oriented Programming,即AOP)

我们常见的架构、设计模式等都是在面向对象这个范式下面进行的设计，而编程范式则是更高一层的概念，它关注的不是怎么用写程序来解决问题，而是关注各种不同的设计程序的思考方式。

### 函数式编程
特点：
1. 函数的参数，可以是函数本身
2. 所有的复用单元都是函数：有助于减少程序体积，一定程度上可以提高开发效率，但它也会导致程序设计的困难，因为我们思考的自然方式是面向对象的。
3. 支持惰性计算，即表达式不在绑定变量时立即求值，而是在需要产生结果时再进行求值。目前大部分的语言，都增加了函数式编程的特性支持，比如java的lambda表达式，groovy的闭包。


参考：
1. http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html
1. http://www.ruanyifeng.com/blog/2017/03/pointfree.html
2. 经典例子：https://www.jianshu.com/p/4435dd6e9180：该例子中，最开始的代码可以理解认为是过程式的（虽然作者说是渐进式的，但是应该是一个意思），改进后的代码就是函数式的。

### AOP
在程序中存在很多的通用功能，比如日志记录，性能统计，安全控制，事务处理等等，这些功能与程序的业务逻辑没有强制的关联性，属于辅助或维护功能，如果我们采用面向对象的方式来实现这些功能，那我们必须在业务逻辑实现的同时，处理这些通用的功能。一但这些功能实现需要变更或者扩展，会导致业务代码的变更。我们将这些通用的功能，称为程序的一个切面。

面向切面编程的思想，就是通过预编译的方式或者动态代理技术，在不修改源码的情况下，为程序增加功能。通过这种方式，分离业务逻辑和辅助功能的实现，使程序可以专注于业务逻辑的实现，更加内聚和高效。

面向切面编程是很常用的一种技术，它天然是面向对象编程方式，在通用步骤处理能力上的一个补齐，可以极大的简化程序开发和提高程序的灵活性。比如java的APT技术衍生的很多框架，dagger、butterknife、greendao等，使用注解来生成辅助代码；比如使用ASM技术直接修改和生成class字节码的jacoco，再比如android的databinding框架，甚至是一些hook和插件化机制，都可以说是AOP编程方式的一种应用。

传统的程序通常表现出一些不能自然地适合单一的程序模块或者是几个紧密相关的程序模块的行为，AOP 将这种行为称为横切，它们跨越了给定编程模型中的典型职责界限。横切行为的实现都是分散的，软件设计师会发现这种行为难以用正常的逻辑来思考、实现和更改。最常见的一些横切行为如下面这些：
- 日志记录，跟踪，优化和监控
- 事务的处理
- 持久化
- 性能的优化
- 资源池，如数据库连接池的管理
- 系统统一的认证、权限管理等
- 应用系统的异常捕捉及处理
- 针对具体行业应用的横切行为

## 21 字符编码
参考：
1. https://en.wikipedia.org/wiki/Hexadecimal

### 21.1 ASCII
概述：
1. ASCII码大致可以分以下几部分
    1. 标准ASCII:范围是0~127，即`\x00`-`\x7f`
        1. 第一部分是：ASCII非打印控制字符：ASCII编码表中前32个(0–31)分配给了控制字符，用于控制像打印机电报机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。
            1. 控制字符最初被设计用来控制诸如打印机和磁带驱动器之类的硬件设备。控制字符（除了水平制表符、换行、回车之外）在 HTML 文档中不起任何作用。控制字符一般被认为是不能打印出来的符号
        2. 第二部分是：ASCII打印字符：数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表 DELETE 命令。
    2. 扩展ASCII(Extended ASCII)：Extended ASCII是IBM当年为PC扩展的8位码，范围是128~255，即`\x80`-`\xff`,它扩展的是一些打印字符

表示方法
1. 使用hexadecimal escape(十六进制转义)来表示：`\xST`,`S` and `T` are any of 0123456789abcdefABCDEF，比如`\x4e`表示字母N，它的最大范围是`\x00`-`\xff`,其中`\x00`-`\x7f`用来表示标准ASCII字符

### 21.2 ISO-8859-1/Latin1/Latin-1 
Latin1是ISO-8859-1的别名，有些环境下写作Latin-1

ISO-8859-1是单字节编码，编码范围**使用了单字节内的所有空间**，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。换言之，把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题。这是个很重要的特性，MySQL数据库默认编码是Latin1就是利用了这个特性。ASCII编码是一个7位的容器，ISO-8859-1编码是一个8位的容器。所以它向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。
> 这里的"抛弃"是一个相对形象的比喻方式，相对于其他编码，比如ASCII，是128个字符的编码，只占用了一个字节的后面7位，最前面的1位统一规定为0，编码范围为0×00-0x7F。而Latin1将一个字节的8位都用起来了。

很明显，iso8859-1编码表示的字符范围很窄，**无法表示中文字符**。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用iso8859-1编码来表示。而且**在很多协议上，默认使用该编码**。比如，虽然"中文"两个字不存在iso8859-1编码，以gb2312编码为例，应该是"d6d0 cec4"两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示："d6 d0 ce c4"（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是UTF编码，则是6个字节"e4 b8 ad e6 96 87"。很明显，这种表示方法还需要以另一种编码为基础。

### 21.3 GB2312/GBK
这就是汉字的国标码，专门用来表示汉字，是双字节编码，而英文字母和iso8859-1一致（兼容iso8859-1编码）。其中gbk编码能够用来同时表示繁体字和简体字，而gb2312只能表示简体字，gbk是兼容gb2312编码的。

GB2312/GBK不是定长编码

### 21.4 unicode
统一码，也叫万国码、单一码。它是最统一的编码，可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容iso8859-1编码的，也不兼容任何编码。不过，相对于iso8859-1编码来说，uniocode编码只是在前面增加了一个0字节，比如字母a为"00 61"。

需要说明的是，定长编码便于计算机处理，而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如java、go。

unicode编码的几种表示方法
1. 码点表示法`\uxxxx`或`\Uxxxx`：其中`xxxx`是十六进制。比如
    1. "严"的unicode编码是`\u4e25`或`\u4E25`。
    2. `\u0000`到`\u007F`对应全部128个ACSII字符
2. 编码表示法`U+xxxx`:比如`U+4E2D`表示"中"

看过Unicode的编码表之后我们发现了一个规律，那就是十进制编码时，大小写编码之间相差了32，十六进制相差了20。在golang中rune能获取字符的Unicode编码值，又知道了大小写字母的编码规律，接下来用他们做字母大写的变化就非常容易了。

### 21.5 utf
考虑到unicode编码不兼容iso8859-1编码，而且容易占用更多的空间：因为对于英文字母，unicode也需要两个字节来表示。所以unicode不便于传输和存储。因此而产生了utf编码，utf编码兼容iso8859-1编码，同时也可以用来表示所有语言的字符，不过，utf编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节(个别会占用四个字节)。

注意，虽然说utf是为了使用更少的空间而使用的，但那只是相对于unicode编码来说，如果已经知道是汉字，则使用GB2312/GBK无疑是最节省的。不过另一方面，值得说明的是，虽然utf编码对汉字使用3个字节，但即使对于汉字网页，utf编码也会比unicode编码节省，因为网页中包含了很多的英文字符。

细分：
1. utf-8：占用1~4个字节
2. utf-16

# 三. 手机原理和硬件
## 1 线刷和卡刷
线刷指使用USB线作为刷机工具进行刷机，而卡刷则是把固件或者升级包拷贝到手机SD卡中进行刷机升级操作。线刷一般是官方所采取的升级方式，主要用来刷固件，如果手机故障造成无法开机等情况，我们可以考虑使用线刷来拯救手机，而卡刷一般是用来升级的，两种刷机方式相比卡刷在刷机时表现的更稳定，不至于受到断电、数据线意外拔出等问题的影响，对于手机的操作有些是卡刷解决不了了，比如系统的重新分区，这些都要通过线刷来进行，所以卡刷与线刷大家要灵活掌握。
 # 五 问题
 1. unicode、ascii、utf-8、utf-16、gbk等

# 三 基础
## 1 进程
参考：
1. https://www.cnblogs.com/tianlangshu/p/5224178.html