# 1.docker
[TOC]
# 一 概述
容器技术笔记

## 1 简介
容器引擎

容器化（containerization）：The use of Linux containers to deploy applications is called containerization.

images:A container is launched by running an image. An image is an executable package that includes everything needed to run an application--the code, a runtime, libraries, environment variables, and configuration files.

Docker 利用 Linux 核心中的资源分脱机制，例如 cgroups，以及 Linux 核心名字空间（name space），来创建独立的软件容器（containers），属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docker 在容器的基础上进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得其比虚拟机技术更为轻便、快捷。Docker 可以在单一 Linux 实体下运作，避免因为创建一个虚拟机而造成的额外负担。

### 1.1 为什么需要docker
docker是干什么的：其中之一是作为云平台部署的框架。

### 1.2 Docker 和虚拟机的区别与特点
对于虚拟机技术来说，传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给他的资源将全部被占用。每一个虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。而操作系统通常需要数十GB。

容器技术和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器内没有自己的内核，也没有进行硬件虚拟。

具体来说与虚拟机技术对比，Docker 容器存在以下几个特点：
1. 更快的启动速度：因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。
2. 更高效的资源利用率：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。
3. 更高的系统支持量：Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。
4. 持续交付与部署：对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。
5. 更轻松的迁移：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。
    1. 一次发布，随处运行：Docker 项目通过容器镜像，直接将一个应用运行所需的完整环境，即把整个操作系统的文件系统也打包了进去。这种思路，可算是解决了困扰 PaaS 用户已久的一致性问题。
6. 更轻松的维护与扩展：Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。
7. 更弱的隔离性：Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。
8. 更弱的安全性：Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。

## 3 常识
### 3.1 OCI（Open Container Initiative）
OCI定义了容器运行时标准（工业界标准），runC是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。

### 3.2 docker版本
分为两大版本：CE（社区版，免费）和EE（企业版，强调安全，付费）


### 3.3 国内有名的加速镜像
docker官方提供的中国、七牛云、网易

## 4 文档等
1. Docker — 从入门到实践：https://yeasy.gitbooks.io/docker_practice/content/
2. https://docs.docker.com/get-started/

# 二 安装配置
## 3 mac
需要安装Docker Toolbox和Docker for Mac这两个东西。
1. 如果是`brew install docker`，则安装的是Docker engine, which will require Docker-Machine (+ VirtualBox) to run on the Mac；
2. 如果是`brew cask install docker`，则安装的是newer Docker for Mac, which does not require virtualbox。启动之后会在`/usr/local/bin`创建docker, docker-compose, docker-credential-osxkeychain and docker-machine的symbolic links。要想用docker-machine创建virtual machines, 需要安装VirtualBox`brew cask install virtualbox`(由于Docker引擎是使用了特定于Linux内核的特性，所以需要安装一个轻量级的虚拟机（如VirtualBox）来在OSX上运行)。

### 3.1 Docker Toolbox
Docker Toolbox installs docker, docker-compose, and docker-machine in /usr/local/bin on your Mac, it also install VirtualBox

注册docker hub：https://hub.docker.com/，Share images, automate workflows

验证安装成功：`docker run hello-world`

### 3.2 docker for docker
1. 安装完成之后运行`docker version`和`docker info`来验证是否安装成功。
    1. 如果提示`Error response from daemon: Bad response from Docker engine`，需要先登录账号密码
2. 测试两个镜像
    1. hello-world：`docker run hello-world`
    2. nginx
    
## 4 配置
### 4.1 镜像加速
待补充

# 三 基础
## 1 核心概念：镜像（Image）、容器（Container）与仓库（Repository）
Docker 主要包含三个基本概念，分别是镜像、容器和仓库，理解了这三个概念，就理解了 Docker 的整个生命周期。以下简要总结一下这三点，详细介绍可以移步Docker 从入门到实践对应章节。

镜像：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

容器：容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间容器可以被。创建、启动、停止、删除和暂停等等，说到镜像与容器之间的关系，可以类比面向对象程序设计中的类和实例。

仓库：镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号。

## 2 架构
在Docker架构中，Docker Client通过特定的协议与Docker Daemon进行通信，而Docker Daemon主要承载了Docker运行过程中的大部分工作。

Docker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行，运行过程的作用有以下几种可能：向Docker Registry获取镜像，通过graphdriver执行容器镜像的本地化操作，通过networkdriver执行容器网络环境的配置，通过execdriver执行容器内部运行的执行工作等。

## 2 操作
### 2.1 镜像（image）操作
1. 创建image：
    1. 新建Dockerfile文件，写入一些需要的信息，如
    2. 使用`docker build`生成image，如
2. 列出本地的image：`docker images`
3. 从远端获取image：`docker pull`
4. 删除image：`docker rmi`
5. 查看本地image详细信息：`docker inspect`
   
### 2.2 容器操作
1. 通过image运行容器：`docker run image_name`。Docker会在隔离的容器中运行进程，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。当运行`docker run`命令时，Docker会启动一个进程，并为这个进程分配其独占的文件系统、网络资源和以此进程为根进程的进程组。在容器启动时，镜像可能已经定义了要运行的二进制文件、暴露的网络端口等，但是用户可以通过docker run命令重新定义（docker run可以控制一个容器运行时的行为，它可以覆盖docker build在构建镜像时的一些默认配置），这也是为什么run命令相比于其它命令有如此多的参数的原因。常用参数如下：
    1. `-i`: 以交互模式运行容器，通常与`-t`同时使用
    2. `-p`: 端口映射，格式为：主机(宿主)端口:容器端口
    3. `-t`: 为容器重新分配一个伪输入终端，通常与`-i`同时使用；
    4. `--rm`：容器运行完之后自动清除。和`-d`不能共用。默认情况下，每个容器在退出时，它的文件系统也会保存下来，这样一方面调试会方便些，因为你可以通过查看日志等方式来确定最终状态。另外一方面，你也可以保存容器所产生的数据。
    5. `-net xxx`
    6. `-v`：挂载一个文件目录到指定容器
    7. `--security-opt`：
2. 列出正在运行的容器：`docker ps`
3. 删除已经结束的container：`docker rm`
4. 在host和container之间copy文件：`docker cp`
5. 保存改动为新的image：`docker commit`

### 2.3 仓库操作
1. 查找:`search`
    1. 查看image的tags：似乎不能用命令行来查看，只能去网页上查询，比如`arachnysdocker/athenapdf`，
        1. 可以去https://hub.docker.com/r/arachnysdocker/athenapdf/tags/
        2. 去https://hub.docker.com/u/library，搜索然后查看tags
2. 拉取`pull [选项][registry地址[:端口号]]仓库名[:标签]`（待补充）：
    
    ```bash
    docker pull ubuntu:16.04 # 会去官方的docker hub拉取library/ubuntu仓库中标签16.04的镜像
    ```
3. 推送


## 3 Dockerfile
一般该文件的名字就叫`Dockerfile`，约定成俗。文件里每一行都会产生一个新层，image中原来的层都是只读的，在运行时最外面会多一个container layer层，我们后续操作就是从这层开始。因为不同的容器可能有相同的层，所以分层的好处是节约存储空间。 

语法：
1. `FROM`：指定基础镜像
2. `RUN`：执行命令
3. `ADD`：添加文件，可以将远程的文件加入进去
4. `COPY`：拷贝文件
5. `CMD`：执行命令
6. `EXPOSE`：暴露端口
7. `VOLUME`：指定容器挂载的卷

## 4 Volume

## 5 Registry
官方仓库：hub.docker.com
国内的仓库：daocloud、时速云、阿里云

## 6 多容器app（docker-compose）
docker-compose用于编排容器。在win/mac的安装包里是自带的，如果是linux，需要手动安装

# 四 高级
## 1 网络设置
默认情况下，容器使用主机的DNS设置，网络设置为bridge模式。

`docker run -net xxx`:
1. `none`：关闭网络接口，此时将关闭所有网络数据的输入输出，这个容器内部只会有一个loopback接口，而且不存在任何可以访问外部网络的router。你只能通过STDIN、STDOUT或者files来完成I/O操作
2. `bridge`:通过veth接口来连接容器，默认配置。此时在主机上面将会存在一个docker0的网络接口，同时会针对容器创建一对veth接口。其中一个veth接口是在主机充当网卡桥接作用，另外一个veth接口存在于容器的命名空间中，并且指向容器的loopback。Docker会自动给这个容器分配一个IP，并且将容器内的数据通过桥接转发到外部。
3. `host`:允许容器使用host的网络堆栈信息。 注意：这种方式将允许容器访问host中类似D-BUS之类的系统服务，所以认为是不安全的。这个容器将完全共享host的网络堆栈。host所有的网络接口将完全对容器开放。容器的主机名也会存在于主机的hostname中。这时，容器所有对外暴露的端口和对其它容器的连接，将完全失效。
4. `container`:使用另外一个容器的网络堆栈信息。

## 2 Seccomp
限制一个容器可以执行的系统调用。
1. 从文件中读取`--security-opt seccomp:/home/smakam14/seccomp/profile.json`
2. 直接设置：`--security-opt seccomp:unconfined`，表示允许容器的全部系统调用

# 六 问题
1. 网友:利用 docker 实现跨平台编译, Mac 上开发好后直接用 docker 进行编译, 然后扔到服务器就好.

# 七 未整理
1. Kubernetes:容器编排工具
2. 下载的image是放在哪儿的
3. registry 注册中心