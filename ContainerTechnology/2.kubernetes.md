# 2.kubernetes

# 一 概述
Kubernetes单词起源于希腊语, 是“舵手”或者“领航员”的意思，是“管理者”和“控制论”的根源。 K8s是把用8代替8个字符“ubernete”而成的缩写。

首先有一个概念Orchestration(直译是管弦乐编曲，可以理解为协调器、编排、乐队指挥)，随着容器技术的发展，我们需要一个东西来管理、扩展和维护容器应用，这个东西就是Orchestration。常见的有Kubernetes和Docker Swarm。

## 1 简介
容器集群管理/容器调度/容器编排系统

特点：
1. 连续性——当应用程序由粒度组件组成时，通过单独更新和改进这些组件，应用程序就更容易按粒度演进。协调器可以根据各个更改对整体workloads的影响做出适当的调整。应用程序的特性改进不再需要在大规模的检修中实现——这通常会对其可用性产生负面影响。持续集成和持续交付的概念(CI/CD，“D”通常表示“部署”)可以通过一个平台更容易地实现自动化，这个平台从一开始就被设计成理解部署本身的更小、更易于管理的步骤。
2. 弹性——Kubernetes维护容器组的活动副本(称为replica
sets)，目的是为了在任何容器或容器分组(Kubernetes称之为pod)失败时保持正常运行时间和响应能力。这意味着数据中心不必复制整个应用程序，并触发负载均衡器，以便在主应用程序失败时切换到辅助应用程序。实际上，复制集中的多个pod通常在任何时候都在运行，协调器的工作是在应用程序的整个生命周期中保持这种多元性。
3. 可伸缩性——对于使用Kubernetes协调分布式workloads的组织来说，最大的好处是，根据预先设置的策略，workloads 可以在系统中按需成倍增长，从而再次进行伸缩。为了减少混乱的可能性，Kubernetes把相关的容器组合成一个pod。可以将名为autoscaler的服务设置为自动将pods复制到不同节点，因为它确定分配给这些pods的资源没有得到尽可能多的利用。

## 4 文档网址等
1. 中文文档：http://docs.kubernetes.org.cn/

# 二 安装配置
## 1 mac
1. 参考：https://github.com/AliyunContainerService/k8s-for-docker-desktop
2. docker desktop for mac => preference => k8s
    1. Deploy Docker Stacks to Kubernetes by default:将Kubernetes设置为docker stack的默认协调器。
    2. Show system containers (advanced):默认情况下，Kubernetes容器对docker service ls之类的命令是隐藏的，因为Kubernetes容器不支持手动管理。 要使其可见，需要勾选上该选项。
3. 部署k8s的控制台
    1. 追加：`kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc5/aio/deploy/recommended.yaml`或者构建:`kubectl create -f kubernetes-dashboard.yaml`二选一
    3. 开启api访问代理:`kubectl proxy`
    4. 本地浏览器访问`http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default`即可看到dashboard了
4. 配置控制台访问token：路径在`$HOME/.kube/config`

    ```bash
    TOKEN=$(kubectl -n kube-system describe secret default| awk '$1=="token:"{print $2}')
    kubectl config set-credentials docker-for-desktop --token="${TOKEN}"
    echo $TOKEN
    ```
5. 安装helm
    1. 参考：https://helm.sh/docs/intro/install/
    2. brew install helm
    3. helm repo add stable http://mirror.azure.cn/kubernetes/charts/
    4. helm repo update

# 三 基础
## 0 未整理
自动缩放功能，一旦服务需求减少，Kubernetes 就会自动减少每个服务的运行实例数量，而大多数容器只需要执行一个函数，当该函数执行完成之后就会停止。

## 1 架构
Chart 是 Kubernetes 的单元

### k8s
1. Pod资源
1. deployment.yaml
2. service.yaml
3. Ingress.yaml

### Helm 
Helm是Kubernetes 的包管理器。包管理器类似于我们在 Ubuntu 中使用的apt、Centos中使用的yum 或者Python中的 pip 一样，能快速查找、下载和安装软件包。Helm 由客户端组件 helm 和服务端组件 Tiller 组成, 能够将一组K8S资源打包统一管理, 是查找、共享和使用为Kubernetes构建的软件的最佳方式。

Helm 解决了什么痛点？
Helm 能够用来管理 k8s 上的复杂应用，它提供了比 k8s 更上一层（更粗粒度）的编排能力。它的编排目标是应用，而 k8s 的编排目标则是更小粒度的服务。在 Kubernetes中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。比如你安装一个 WordPress 博客，用到了一些 Kubernetes (下面全部简称k8s)的一些资源对象，包括 Deployment 用于部署应用、Service 提供服务发现、Secret 配置 WordPress 的用户名和密码，可能还需要 pv 和 pvc 来提供持久化服务。并且 WordPress 数据是存储在mariadb里面的，所以需要 mariadb 启动就绪后才能启动 WordPress。这些 k8s 资源过于分散，不方便进行管理，直接通过 kubectl 来管理一个应用，你会发现这十分蛋疼。
所以总结以上，我们在 k8s 中部署一个应用，通常面临以下几个问题：
1. 如何统一管理、配置和更新这些分散的 k8s 的应用资源文件
2. 如何分发和复用一套应用模板
3. 如何将应用的一系列资源当做一个软件包管理

Helm技术实现：
Helm 客户端是使用 Go 语言编写的，它通过 gRPC 协议与 Tiller 服务器交互。Tiller 服务器也是使用 Go 语言编写的，它使用 Kubernetes 客户端类库（当前是那个 REST+JSON ）与 Kubernetes 进行通讯。Tiller 服务器通过 Kubernetes 的 ConfigMap 存储信息，因此本身没有用于存储数据库。

Helm相关组件说明：
1. helm： 是一个命令行工具，用于本地开发及管理chart，chart仓库管理等
2. Tiller：是 Helm 的服务端。Tiller 负责接收 Helm 的请求，与 k8s 的 apiserver 交互，根据chart 来生成一个 release 并管理 release
3. chart：Helm的打包格式叫做chart，所谓chart就是一系列文件, 它描述了一组相关的 k8s 集群资源（比如 deployment、service 等），包含某个应用所需的全部基础组件依赖。
    1. 比如 wordpress 应用，chart 包中包含了 PHP、MySQL 等相关基础组件依赖，这样就能通过 Helm 来一键安装了。
    2. 这里有一个相关理念的产品，RANCHER：https://www.rancher.cn/（待整理）
4. release：使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release（比如 values ）。chart 和 release 的关系可以用代码和进程的关系来类比。release是chart的运行实例，包含特定的config
    1. 但是开发者需要维护release的状态
5. Repoistory：Helm chart 的仓库，Helm 客户端通过 HTTP 协议来访问存储库中 chart 的索引文件和压缩包

helm的基本使用:
1. repo
    1. 增加repo源
        
        ```bash
        helm repo add ali https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts # 阿里云
        helm repo add emqx https://repos.emqx.io/charts
        helm repo add google https://kubernetes-charts.storage.googleapis.com # google
        helm repo add fabric8 https://fabric8.io/helm  # f8
        ```
        
    2. 查看repo：`helm repo list`
    3. 更新repo信息到本地`helm repo update`
    3. 删除repo`helm repo remove xxx`
2. chart和release
    1. 查看已通过helm部署到k8s的release及其对应的chart:`helm list`、`helm ls`
    2. 搜索
        1. 在repo中搜索`helm search repo xxx` 
        2. 在hub中搜索`helm search hub xxx` 
    3. 查看chart详情：`helm inspect chartA`
    4. 下载chart：默认下载到当前目录
        1. `helm fetch chartA`，下载完了可能还需要手动解压
            1. 比如`tar zxvf ./emqx-v4.1.2.tgz`，解压后的目录如下
                
                ```bash
                ├── Chart.yaml # 用于描述Chart的基本信息，如名称、版本等；
                ├── README.md
                ├── templates # 部署文件模板目录
                │   ├── StatefulSet.yaml
                │   ├── _helpers.tpl
                │   ├── configmap.yaml
                │   ├── configmap_for_acl.yaml
                │   ├── rbac.yaml
                │   └── service.yaml
                └── values.yaml # 默认配置文件
                ```
    5. 语法检测:`helm lint chartA`
    5. 打包:`helm package chartA`
    5. 创建chart:`helm create chartA`
    1. 部署
        1. 通过指定chart来部署release:`helm install releaseA chartA`、`helm install --name releaseA chartA`
            1. 比如`helm install my-emqx emqx/emqx`，通过emqx/emqx这个chart来部署release，release名是my-emqx
        2. 通过指定配置来部署
            1. 比如`helm install my-emqx emqx/emqx --set service.type=NodePort`
        2. 通过指定目录来部署:`helm install releaseA dirA`
            1. 比如`helm install my-cus-emqx ./emqx`
        3. 通过指定目录和指定配置文件来部署:`helm install releaseA dirA --values fileA.yaml`
    2. 更新变量:`helm upgrade releaseA ./dirA --values ./dirB/fileC.yaml`，将releaseA的values.yaml修改为fileC.yaml
    3. 查看自定义了哪些变量:`helm get values releaseA`
    3. 卸载和删除release:`helm delete releaseA`、`helm del releaseA`
    4. 历史和回滚
        1. 查看历史:`helm history releaseA`
        2. 回滚到某个版本，比如回滚到版本1:`helm rollback releaseA 1`

## 2 k8s命令行
集群和节点：
1. `kubectl cluster-info`：获取集群信息
2. `kubectl get nodes`:查看所有节点信息
3. `kubectl describe node nodeNameA`查看节点信息
    1. `InternalIP`:就是节点的IP
3. `kubectl delete node 192.168.2.152`  //删除节点

服务器操作:
1. `kubectl get svc`获取服务

pod操作：
1. `kubectl get pods`:获取所有的pod
2. 查看pod信息
    1. `kubectl get pod name --output yaml`
    2. 查看pod网络`kubectl get pod  -o wide`
    3. 查看log
        1. `kubectl logs <pod_name>`
            1. `-f`类似`tail -f`的方式查看实时日志
        2. 查看指定pod中指定容器的日志`kubectl logs <pod_name> -c <container_name>`
2. `kubectl create -f YAML_FILE.yaml`  // 使用yaml文件创建pod
3. `kubectl delete -f YAML_FILE.yaml`  //使用yaml文件删除pod

命名空间：
1. `kubectl get ns`：查看命名空间
1. `kubectl create ns xxx`：创建命名空间

# 六 问题
## 1 docker desktop for mac的k8s一直显示在starting
默认拉取的事谷歌的源，科学上网似乎也不太好使。

解决方案：
1. 方案一：关闭k8s的启动
    1. 参考：https://github.com/docker/for-mac/issues/3594
2. 方案二：使用阿里的大神提供的k8s-for-docker-desktop
    1. 参考：https://github.com/AliyunContainerService/k8s-for-docker-desktop
    
## 2 k8s context： docker-desktop and docker-for-desktop
see：https://github.com/docker/for-mac/issues/4089

## 3 Error from server (NotFound): the server could not find the requested resource (get services http:heapster:)
在部署了kubernetes集群后，还需要安装metrics-server或者heapster插件才能通过 kubectl top node/top查看到资源使用情况。

因为heapster不在维护，所以推荐安装metrics-server

## 4 configmaps "xxx-env" is forbidden: User "xxx" cannot update resource "configmaps" in API group "" in the namespace "xxx"
应该是这个user没有权限

# 七 待整理
1. 三小时攻克 Kubernetes！：http://baijiahao.baidu.com/s?id=1602795888204860650&wfr=spider&for=pc
2. cluster