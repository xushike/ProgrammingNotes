# MQ消息队列

# 一 概述
MQ、MQTT相关

## 1 简介
了解消息队列之前，首先了解消息从发送者到接收者的两种方式：
1. **即时消息通讯**：也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），RPC就是方式的具体实现之一（当然单纯的http通讯也满足这个定义）
2. **延迟消息通讯**：即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。

什么是消息队列：消息队列，一般我们会简称它为MQ(Message Queue),可以简单理解为,把要传输的数据放在队列中。把数据放到消息队列叫做生产者，从消息队列里边取数据叫做消费者。

为什么需要消息队列:
1. 解耦。
	1. 例子,比如系统B、C、D都需要系统A的userInfo。直接把调用写在代码里 vs 系统A把userInfo放进消息队列:
    	1. 系统A只负责把数据写到队列中，谁想要或不想要这个数据(消息)，系统A一点都不关心
		2. 即便现在系统D不想要userId这个数据了，系统B又突然想要userId这个数据了，都跟系统A无关，系统A一点代码都不用改。如果直接写在代码里就需要º改代码
		3. 系统D拿userId不再经过系统A，而是从消息队列里边拿。系统D即便挂了或者请求超时，都跟系统A无关，只跟消息队列有关。
2. 异步
	1. 同样的例子，如果直接把调用写在代码里，调用时间就是系统B、C、D三者之和，但是放进消息队列，则各是各的。
3. 削峰/限流:
	1. 假设秒杀活动的时候，并发很高，现有的机器处理不了这么多请求，就可以放到消息队列里去。
	
消息队列的复杂性：
1. 高可用：消息队列肯定不能是单机的，如果是单机的，对应的机器挂了后，整个系统就不可用了。所以得是得集群/分布式的。
	1.  所以语言自带的数据结构队列基本是无法满足的
2. 如何获取数据
	1. 生产者将数据放到消息队列中，消息队列有数据了，主动叫消费者去拿(俗称push)
	2. 消费者不断去轮训消息队列，看看有没有新的数据，如果有就消费(俗称pull)
3. 数据丢失问题
4. 重复和顺序问题

常见消息队列的比较(不负责任):
1. kafka性能比 rabbitmq高

# 三 基础
## 1 MQ消息传递模式
在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：
1. 点对点传递模式
2. 发布-订阅模式。

大部分的消息系统选用发布-订阅模式，比如Kafka。

### 1.1 点对点消息传递模式
在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。

### 1.2 发布-订阅消息传递模式
在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除，发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。


# 四 高级
## 1 MQTT和MQ的区别
MQTT：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范
MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式

