# 2.PostgreSQL
[TOC]

# 一 概述
## 1 简介
PostgreSQL: 是以加州大学（University of California）伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL

psql: 是PostgreSQL数据库的命令行交互工具

pgAdmin: 是PostgreSQL数据库的图形化管理工具

### 1.1 优点
为什么选择postgresql：

## 2 历史
formerly known as Postgres, then as Postgres95，now

## 3 常识
### 3.1 pg有类似Oracle的dual表吗？
pg没有dual表，select可以没有from语句。比如查当前时间，可以`select now();`

## 4 文档
1. 9.6中文手册：http://www.postgres.cn/docs/9.6
2. 网友的学习资料：https://github.com/digoal/blog/blob/master/README.md

# 二 安装配置
## 3 mac下的安装
### 3.1 官网提供的app
### 3.2 brew安装（推荐）
1. `brew install postgresql`，数据库会被安装且初始化，使用Homebrew安装PostgreSQL不用再执行initdb来完成安装过程
2. 安装brew services，用于管理服务，`brew tap homebrew/services`
3. 以后台服务的方式启动Postgres:`brew services start postgresql`，相应的，停止和重启是stop和restart

## 4 配置
参考：https://www.citusdata.com/blog/2017/07/16/customizing-my-postgres-shell-using-psqlrc/

命令历史文件是在`~/.psql_history`，但好像不准？

psql的配置文件是`~/.psqlrc`，如:
```sh
\timing # 显示执行时间
\pset null '¤' # 设置打印空值时打印的字符串，因为空值容易和空字符串混淆
\x auto
\setenv PAGER 'less -S -m'
```

查看db所有参数的值`show all;`，查看某一个用`show option_name;`

数据库的配置文件是`postgresql.conf`？

# 三 基础

## 1 角色
可以将角色视为数据库用户或一组数据库用户，具体取决于角色的设置方式。角色可以拥有数据库对象（例如，表和函数），并可以将这些对象的权限分配给其他角色，以控制谁有权访问哪些对象。在8.1之前的PostgreSQL版本中，用户和组是不同类型的实体，但现在只有角色。任何角色都可以充当用户，组或两者

`createuser`实际上调用此命令`CREATE ROLE`，命令`createuser`会传输加密的密码，但后者传输明文密码

1. 创建角色:`CREATE ROLE role_name`：默认不会赋予登录权限。
2. 查看所有user:`select * from pg_user;`，查看所有role：`select * from pg_roles;`
3. 为角色赋予权限:`alter user user_name permission_name`,比如赋予登录权限：`alter user root login`

### 1.1 授权和取消授权GRANT and REVOKE
(待整理)

## 2 数据库
createdb和create database

1. list all database：`\l`
1. calculate db size in disk：`pg_database_size('db_name')`,it shows the size in bytes.

## 3 表
ps的表包含：系统表...

1. list all tables or table info:`\d t_name`，使用`\d+ t_name` 可以看到table的更多信息，比如comments。

删除表：
1. calculate table size including index and data in disk:`pg_total_relation_size('table_name')`,not including

重命名字段：`ALTER TABLE table_name RENAME COLUMN old_name TO new_name;`

## 4 数据类型
查看数据类型：`pg_typeof()`

数据类型转换:使用cast语法，`cast`或`::`,但`::`不符合SQL规范


### 4.1 boolean/bool
### 4.2 字符
注意PSQL的字符串必须用单引号包裹。

三种：
1. char(n)
2. varchar(n)：变长字符串，理论上长度不限
3. text:变长字符串，和varchar(n)基本一样。

### 4.3 数字
（待补充）
1. 整数
    1. smallint
    2. int
    3. serial
    4. bigint：将一个浮点数转成该类型时是四舍五入。
2. 浮点数
    1. float
    2. real
    3. numeric

### 4.4 时间

### 4.5 json和jsonb
区别：json写入快，读取慢；jsonb写入慢，读取快，而且支持索引；在一般操作上，二者是没有区别的，不过有些方法比如`jsonb_set()`只支持jsonb

参考：
1. http://francs3.blog.163.com/blog/static/4057672720157153719971/
2. https://www.cnblogs.com/alianbog/p/5658156.html
3. http://blog.163.com/digoal@126/blog/static/1638770402015516103221261/

1. 插入json：`INSERT INTO orders (info) VALUES ('{ "customer": "John Doe", "items": {"product": "Beer","qty": 6}}');`
2. 查询：
    1. 查询字段时以JSON的形式返回结果集
    2. 查询字段的某个属性可以使用`->`和`->>`操作符，前者以JSON的形式返回，后者以文本的形式返回，这两个操作符后的属性名要加上引号，对json字段的某个属性做类型转换时括号需要将整个包裹，形如`select (info -> 'items' ->> 'qty')::int from ...`
3. 修改：9.5以下只能整个字段修改（想使用扩展可以通过jsonbx插件），不支持部分修改，9.5开始可以使用`||`操作符和`jsonb_set()`函数对jsonb（不支持json格式）格式的字段进行修改。而且`||`会将path下所有的嵌套元素值整个替换为new_balue，而`jsonb_set()`只替换path，例子如

    ```sql
    
    ```
4. 删除：使用`-`操作符或指定路径的方式删除
5. 合并两个json：使用`||`
5. 遍历
5. 相关函数
    1. `jsonb_set(target jsonb, path text[], new_value jsonb[, create_missing boolean])`:create_missing表示要修改的属性值不存在时是否新增该属性值，默认为true

        ```sql
        update orders set info = jsonb_set(info::jsonb,'{name}','"Zhang"') where id = 5;
        ```

        1. 实测缺点是只能修改某个属性，无法修改平级的多个属性，想实现的话只有自定义函数
    2. `jsonb_object_keys`:以列的方式展开所有的key
    2. `jsonb_pretty()`
    3. jsonb_to_record
    4. jsonb_populate_recordset

### 4.6 数组
pg的数组下标从1开始

转换成数组的几种方法：
1. 类型转换：假如有字符串`'a,b,c'`，那么可以左右两边加上大扩号单引号然后调用类型转换

    ```sql
    '{a,b,c}'::text[]
    '{NULL,1,NULL,2}'::int[]
    ```
2. `string_to_array(text,text...)`：
3. `array_agg(expression)`

### 4.7 record

注意：
1. 如果一个方法返回的是record类型，比如`test()`函数返回了id和name，然后返回类型是record，那么获取这两个值需要`test.id`和`test.name`
 
## 6 新增
有两种：`insert into select`将一个表的数据复制到另一个表，`insert into values`将常量或常量表数据复制到一个表中，两种方式都可以upsert。

1. `insert into t1 select a,b,c from t2 where a=xxxx...`:当insert后面跟select的时候，select后面的where语句的字段默认是属于t2的。如果想插入部分字段，可以`insert into t1(a,b,c) select a,b,c from t2 where a=xxxx...`
2. `insert into t1(name) values ('xxx'),('xxx') ...`，似乎和其他语言有点不一样。

问题：
1. insert into不能给紧邻的table命名？
2. 尽量每一个细节都分析到

## 7 查询
去重`DISTINCT`和`DISTINCT ON`:参考https://blog.csdn.net/pg_hgdb/article/details/78513659

### 7.1 行号ctid
PostgreSQL 自带的表是堆表，数据按行存储在HEAP PAGE中，在btree索引中，除了存储字段的value，还会存储对应的ctid(即行号)，检索记录也是通过行号进行检索的。因此通过行号是可以快速检索到记录， 行号的写法是(数据块page_number, 条号item_number)，数据块从0开始编号，条号从1开始编号

## 8 更新
连表更新的写法如下，对于set后紧跟的赋值语句，左边被认是属于t1的，不能加上t1这个前缀（别名也不能加），但右边不知道属于谁，所以应该加上。
```sql
UPDATE t1 SET xxx = t1.xxx FROM t2 
WHERE t1.xxx = ...
```

三表+查询怎么写：查看文档结合网上的资料，结论是其他表的连接条件可以写在from关键字后面。比如
```sql
update t1 set a = tmp.a, b = tmp.b 
from (select * from t2 left join t3 on ...) tmp
where tmp.xxx = t1.xxx
```

关于直接使用inner join行不通的原因分析：之前在网上搜update inner join 的语法，有人说语法如下
```sql
update t1 set a = t2_alias.a
from t1 t1_alias inner join t2 t2_alias on ... 
where t1_alias.xxx = t2_alias.xxx
```
但实测发现不行，将t1.a全部更新为一样的，没有对应起来，最后查看文档和资料可以理解到：这里from后面t1使用了别名t1_alias，而update后面的t1还是t1，也就是说没有被认为是同一张表，所以后面的一堆限制条件都跟update后的t1没关系，所以并没有按条件去更新。如果想关联，可以加上`t1.id = t1_alias.id`，如
```sql
update t1 set a = t2_alias.a
from t1 t1_alias inner join t2 t2_alias on ... 
where t1_alias.xxx = t2_alias.xxx
    and t1.id = t1_alias.id
```
但最好的写法还是遵照官方文档。

## 9 删除 

## 10 UPSERT（insert on conflict do）
当插入遇到约束错误时，直接返回或者改为执行 UPDATE。

不存在则插入，存在则更新，如`insert into test values (1,'hello digoal',now()) on conflict (id) do update set info=excluded.info,crt_time=excluded.crt_time; `

不存在则插入，存在则直接返回，即不做任何处理，如`insert into test values (1,'hello digoal',now()) on conflict (id) do nothing;`

不跟`conflict_target`条件的`on conflict`和普通`insert into`的区别：
`on conflict`后的`conflict_target`条件可以为空，如果插入成功，和普通的insert效果一样；如果数据不满足表的任何约束，都会触发后面的`do nothing`（不能是do update，语法不支持）和`returning`（返回空行）而不是返回错误，而普通的insert此时会返回错误，利用这个可以在插入时判断数据是否存在。

有多个唯一约束时，以`conflict_target`条件为准：比如有a、b两个约束，如果`conflict_target`是a，当a冲突时，即使values后面有b的值且不和b冲突，也不会更新b，而是去执行后面的update或者nothing（当然，如果这里的update有更新b的操作，那么会更新b，但不是因为values后面的b）；如果a没冲突，但b冲突了，返回错误。

## 11 操作后的返回值
可以使用`returning xxx as yyy`返回受影响的数据

## 12 case when then 
语法形如
```sql
CASE WHEN condition THEN result
        [WHEN condition THEN result ...]
        [ELSE result]
END
```
condition为bool，如果都为true则返回后面的result，如果都为false，则返回ELSE后的result，如果都为false且没有ELSE，则返回null。

## 13 注释
分两种：添加注释和查询注释

添加注释语法:
1. 给字段添加注释：`comment on column tb.column_name is 'The user ID'`
2. 给表添加注释`comment on tb_name ....`

查询注释:
1. 查询字段上的注释`\d+ tb_name`，不会显示表上的注释
2. 查询表上的注释
    1. `SELECT obj_description('schemaName.tableName'::regclass, 'pg_class')`
    2. `SELECT obj_description(oid) FROM pg_class WHERE relkind = 'r'`

## 14 流程控制
三种循环

### 14.1 for循环
```sql
declare 
punm number:=1;
begin
for pnum in 1..10 loop
dbms_output.put_line(pnum);
end loop;
end;  
```

# 四 高级
## 1 psql
### 元命令/斜杠命令/终端命令
常用元命令:
1. 查看连接信息：`\conninfo`
1. 列出该数据库所有table：`\d`，所有非sequence table：`\dt`
3. 切换数据库、用户：切换数据库`\c database_name`,切换用户`\c user_name`
5. 打开执行计时，非常有用:`\timing`
6. 执行shell命令：`\! shell_command`
7. 每SEC秒执行查询，默认2s:`\watch SEC`,e.g.,`select * from orders;\watch 1`
8. 切换对齐与否：`\a`
9. 显示所有全文搜索的配置：`\dF` 
10. 显示已安装的扩展插件：`\dx`
11. 横纵显示切换（Expanded display）：`\x`，设为auto的话会自动选择合适的显示方式。
12. `-f`执行文件
13. `-d`指定数据库

## 2 索引
参考：
1. https://yq.aliyun.com/articles/111793


索引相关概念：唯一索引、联合索引、函数索引

1. specify postgreSQL index type while creating a new index on a table：`CREATE INDEX index_name ON table_name USING index_type (column);`,e.g.,`CREATE INDEX test_index ON numbers using hash (num)`



## 3 transactions
使用BEGIN、COMMIT、ROLLBACK

## 4  execution plan/query plan
执行计划的原理？

查看执行计划：`EXPLAIN query_sql`，分析sql但不会显示执行的时间

通过执行sql来显式执行计划：`EXPLAIN ANALYZE query_sql`，会真实执行!

扫描：分全表扫描、索引扫描（seq scan）和ctid扫描（Tid scan）。要使用tid进行快速的行扫描，必须开启参数enable_tidscan。

## 5 函数和存储过程
### 5.1 函数
例子`raise notice 'this is raise demo , param1 is % ,param2 is %',param1,param2;`，raise用于打印输出，后面的百分号就是占位符，不用考虑值的类型。notice是级别，可以为debug/log/info/notice/warning/exception，这些级别的信息是直接写到服务端日志还是返回到客户端或是二者皆有，是由log_min_messages和client_min_messages两个参数控制，这两个参数在数据库初始化时用到（？）

`$$`：从`begin`到`end`表示函数主体代码的开始和结束，需要用单引号包裹，为了防止主体代码里面已经存在单引号导致冲突，pg支持用`$$`替代单引号。

### 5.2 常用函数
1. `generate_series(start, stop, step, interval)`：生成多行数据。


## 6 聚合/聚集函数和窗口函数
参考：https://time-track.cn/postgresql-window-function.html

## 7 常量表/常数表
写法形如`value (1, 'one'), (2, 'two'), (3, 'three')`，可以当做一个表来用，写法如`(VALUES (1, 'one'), (2, 'two'), (3, 'three')) as tmp(a,b)`

## 8 数据备份和恢复
### 8.1 使用COPY TO和COPY FROM导入导出表为CSV文件
可以直接跟表名，也可以跟查询语句
1. 导出：`COPY (select id as COL_ID, name as COL_NAME from my_tab order by id) to 'D:/server_exp_dir/file_name.csv' with csv header;`
2. 导入：`COPY tanktab from '/u02/tank/123456.csv' with csv header;`
3. 将远程的数据导出到本地文件中:`psql -h 192.168.xxx.xxx -p 21770 -d db_name -U readonly -c "COPY (select * from table_name where company_id = 518 order by id) TO STDOUT with csv header" > /home/qa2/tmp/ruipai_back/company_stocks_back.csv`
4. 将本地文件中的数据导入到远程数据库中:`psql -h localhost -p 21770 -d db_name -U pgdata -c  "COPY table_name(xxx) from STDIN with csv header" < /home/prod/tmp/back_up/xxx.csv`

### 8.2 使用pg_dump导入导出数据库
参考：https://www.postgresql.org/docs/9.6/static/app-pgdump.html

该操作需要角色具有转储权限，如果没有那么需要切换角色或者修改权限。

导出格式包括文本格式：`.sql`和非文本格式`.tar`、`.dump`，如果是非文本格式，需要配合`pg_restore`恢复

导出单个数据库or数据库里的单个表：`pg_dump -h 127.0.0.1 -p 7002 <-t tabel_name> db_name > xxx.sql`
恢复到db（需要先创建db）：`psql -h 127.0.0.1 -p 7002 db_name < xxx.sql`

## 9 事务
ACID

PostgreSQL中支撑ACID的主要是MVCC和WAL两项技术。（原理？）

事务的控制：
1. 开启事务：`BEGIN` or `BEGIN TRANSACTION`
2. 提交事务：`COMMIT`or `END TRANSACTION`
3. 回滚：`ROLLBACK`


SQL标准有4种隔离机制/级别：
- Read Uncommitted（未提交的读取）
- Read Committed（提交的读取）：pgsql默认
- Repeatable Read（可重复读）：mysql默认
- Serializable（可串行化）

表格：待补充

pgsql只实现了2和4

隔离级别命令：
1. 查看和设置隔离级别：`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE`

### 9.2 Read Committed
在该级别，每个语句看到的是该语句执行前所有已经committed数据的快照，如果不加"begin....commit/rollback"，每一个SQL语句都是一个transaction，都有自己的transaction ID。

### 9.3 Repeatable Read
在这个级别，每个语句看到的是该事务执行前所有已经committed数据的快照。（所以在这个隔离级别，同一个transaction中多次执行同一个select语句会得到相同的结果。）


## 10 并发控制和锁
参考：https://www.cnblogs.com/biterror/p/7161631.html?utm_source=itganhuo&utm_medium=referral

锁的粒度：一般有行锁，页锁和表锁。PostgreSQL采用MVCC的方式进行并发控制，每个事务看到的是一段时间前的数据快照。同时，MVCC并不能够解决所有问题，所以也提供了行级和表级的锁。pg设计锁等待时，以队列方式存储等待锁。

`deadlock_timeout`：在等待一个lock被释放的时间里，多久可以启动deadlock检查机制，默认是1s。查看`show deadlock_timeout`

`lock_timeout`：单位是毫秒，设为0表示无线等待，默认为0。

`statement_timeout`

### 10.1 共享锁/读锁（Shared lock）
表锁的命令形如：`lock table_name ...`

表共享锁：`select`(?)

行共享锁`select for update/for share`：无论where有没有触发到索引，都是行级锁。
1. 使用`select for update`，数据被锁住时，对数据进行修改操作，会等待，如果设置了`lock_timeout`（非0），超时时会出现“canceling statement due to user request”
2. 使用`select for update nowait`，数据被锁住时，对数据进行修改操作，会报数据库错误
3. `select for update skip locked`，跳过已被锁的数据

注意：
1. 连表查询加锁时，不支持单边连接（left jon等）

### 10.2 排他锁
表排他锁：`drop`(?)

行排他锁：`insert/update/delete`

### 10.3 死锁
对于事务级别提交读来讲：新增的rows是不会出现死锁的

## 11 主从实现
### 11.1 基于Standby的异步流复制（Streaming Replication）
参考：https://blog.csdn.net/wlwlwlwl015/article/details/53287855

pg的主从分别称为primary和standby，也可以称为master和slave。

## 12 extension
查看已安装extension：`\dx`or`SELECT * FROM pg_extension`

### 12.1 pgbench
参考：https://www.postgresql.org/docs/10/pgbench.html
pgbench is a simple program for running benchmark tests on PostgreSQL

### 12.2  

### 12.3 中文分词：zhparser
github：https://github.com/amutu/zhparser

1. 安装SCWS，比如安装在~/opt目录
2. 下载zhparser源码
3. 编译和安装zhparser
4. 创建extension

## 13 全文检索/全文搜索（Full Text Search）
文档是全文搜索系统中的搜索单元。比如，一篇杂质文章或是一封邮件消息。这里的文档可以跨多个表，代表为我们想要搜索的逻辑实体。

`::tsvector`：不执行normalized
`to_tsvector('english', 'The Fat Rats')`：执行normalized
`::tsquery`：不执行normalized
`to_tsquery('Fat:ab & Cats')`：执行normalized

## 14 schema
默认是public，列出db里所有schema：
1. `\dn`
2. `select schema_name from information_schema.schemata`

列出schema下面的表格：
1. `\dt schema_name.*`，注意如果是`\d schema_name.*`的话会列出详细信息。
2. `SELECT * FROM information_schema.tables WHERE table_schema = 'public'`or`select * from pg_tables where schemaname='public';`

# 六 问题
## 1 解决
### 1.1 时间和时间戳的转换（待补充）
```sql
--日期转时间戳
SELECT EXTRACT(epoch FROM NOW());
SELECT EXTRACT(epoch FROM CAST('2017-12-06 00:17:10' AS TIMESTAMP));
SELECT EXTRACT(epoch FROM '2017-12-06 00:17:10'::TIMESTAMPTZ);

--时间戳转日期
SELECT TO_TIMESTAMP(1512490630)
```

### 1.2 行列转换
列->行：
1. `string_agg()`
2. `array_agg()`

行->列：
1. `regexp_split_to_table()`

## 2 未解决
1. 数值型有哪几种，取值范围，默认的是哪种

# 七 待整理
## 1 待笔记
1. excluded：在upsert语句中，表示values（）括号里面的值
2. upsert语句中returning的返回包括insert和update
3. pgsql自带的表是堆表。

## 2 未整理
1. PostgreSQL的扩展和标准有什么区别
2. 标准sql中用户额角色的区别
4. primary 和uniq等
5. 几种分页方法
6. 和mysql等的区别
7. https://yq.aliyun.com/groups/29
9. 聚合查询so hard？
11. 函数式索引
    1. 对jsonb的索引

12. text才能转jsonb？
15. 待研究
    1. 可以在upsert的更新中连接其他表吗
17. https://blog.csdn.net/sunbocong/article/details/79097713
18. sum和count的区别
20. anyelement是任意类型？
    1. numbric和int的区别
    2. numbric和float的区别

21. `show default_transaction_isolation`，设置使用`set`
22. begin，set，commit
23. 堆表和索引组织表的区别，聚集索引表？
24. 函数索引和联合索引
25. 数据库垃圾清理(vacuumdb/reindexdb)会锁表