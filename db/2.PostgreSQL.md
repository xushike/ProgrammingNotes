# 2.PostgreSQL
[TOC]

# 一 概述
## 1 简介
PostgreSQL: 是以加州大学（University of California）伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL

psql: 是PostgreSQL数据库的命令行交互工具

pgAdmin: 是PostgreSQL数据库的图形化管理工具

### 1.1 优点
为什么选择postgresql：

## 2 历史
formerly known as Postgres, then as Postgres95，now

## 3 常识
### 3.1 pg有类似Oracle的dual表吗？
pg没有dual表，select可以没有from语句。比如查当前时间，可以`select now();`

## 4 文档
1. 9.6中文手册：http://www.postgres.cn/docs/9.6
2. 网友的学习资料：https://github.com/digoal/blog/blob/master/README.md

# 二 安装配置
## 3 mac下的安装
### 3.1 官网提供的app
### 3.2 brew安装（推荐）
1. `brew install postgresql`，数据库会被安装且初始化，使用Homebrew安装PostgreSQL不用再执行initdb来完成安装过程
2. 安装brew services，用于管理服务，`brew tap homebrew/services`
3. 以后台服务的方式启动Postgres:`brew services start postgresql`，相应的，停止和重启是stop和restart

# 三 基础

## 1 角色
可以将角色视为数据库用户或一组数据库用户，具体取决于角色的设置方式。角色可以拥有数据库对象（例如，表和函数），并可以将这些对象的权限分配给其他角色，以控制谁有权访问哪些对象。在8.1之前的PostgreSQL版本中，用户和组是不同类型的实体，但现在只有角色。任何角色都可以充当用户，组或两者

`createuser`实际上调用此命令`CREATE ROLE`，命令`createuser`会传输加密的密码，但后者传输明文密码

1. 创建角色:`CREATE ROLE role_name`：默认不会赋予登录权限。
2. 查看所有user:`select * from pg_user;`，查看所有role：`select * from pg_roles;`
3. 为角色赋予权限:`alter user user_name permission_name`,比如赋予登录权限：`alter user root login`

### 1.1 授权和取消授权GRANT and REVOKE
(待整理)

## 2 数据库
createdb和create database

1. list all database：`\l`
1. calculate db size in disk：`pg_database_size('db_name')`,it shows the size in bytes.

## 3 表
ps的表包含：系统表...

1. list all tables or table info:`\d t_name`，使用`\d+ t_name` 可以看到table的更多信息，比如comments。如果想通过SELECT来查询comments信息，可以使用`SELECT obj_description('schemaName.tableName'::regclass, 'pg_class')`，不过实测貌似不行。

删除表：

1. calculate table size including index and data in disk:`pg_total_relation_size('table_name')`,not including

## 4 数据类型
查看数据类型：`pg_typeof()`

数据类型转换:使用cast语法，`cast`或`::`,但`::`不符合SQL规范


### 4.1 boolean/bool
### 4.2 字符
注意PSQL的字符串必须用单引号包裹。

三种：
1. char(n)
2. varchar(n)：变长字符串，理论上长度不限
3. text:变长字符串，和varchar(n)基本一样。

### 4.3 数字
（待补充）
1. 整数
    1. smallint
    2. int
    3. serial
    4. bigint：将一个浮点数转成该类型时是四舍五入。
2. 浮点数
    1. float
    2. real
    3. numeric

### 4.4 时间

### 4.5 json和jsonb
区别：json写入快，读取慢；jsonb写入慢，读取快，而且支持索引；在一般操作上，二者是没有区别的，不过有些方法比如`jsonb_set()`只支持jsonb

参考：
1. http://francs3.blog.163.com/blog/static/4057672720157153719971/
2. https://www.cnblogs.com/alianbog/p/5658156.html
3. http://blog.163.com/digoal@126/blog/static/1638770402015516103221261/

1. 插入json：`INSERT INTO orders (info) VALUES ('{ "customer": "John Doe", "items": {"product": "Beer","qty": 6}}');`
2. 查询：
    1. 查询字段时以JSON的形式返回结果集
    2. 查询字段的某个属性可以使用`->`和`->>`操作符，前者以JSON的形式返回，后者以文本的形式返回，这两个操作符后的属性名要加上引号，对json字段的某个属性做类型转换时括号需要将整个包裹，形如`select (info -> 'items' ->> 'qty')::int from ...`
3. 修改：9.5以下只能整个字段修改（想使用扩展可以通过jsonbx插件），不支持部分修改，9.5开始可以使用`||`操作符和`jsonb_set()`函数对jsonb（不支持json格式）格式的字段进行修改。而且`||`会将path下所有的嵌套元素值整个替换为new_balue，而`jsonb_set()`只替换path，例子如

    ```sql
    
    ```
4. 删除：使用`-`操作符或指定路径的方式删除
5. 合并两个json：使用`||`
5. 遍历
5. 相关函数
    1. `jsonb_set(target jsonb, path text[], new_value jsonb[, create_missing boolean])`:create_missing表示要修改的属性值不存在时是否新增该属性值，默认为true

        ```sql
        update orders set info = jsonb_set(info::jsonb,'{name}','"Zhang"') where id = 5;
        ```

        1. 实测缺点是只能修改某个属性，无法修改平级的多个属性，想实现的话只有自定义函数
    2. `jsonb_object_keys`:以列的方式展开所有的key
    2. `jsonb_pretty()`
    3. jsonb_to_record
    4. jsonb_populate_recordset

### 4.6 数组
pg的数组下标从1开始

转换成数组的几种方法：
1. 类型转换：假如有字符串`'a,b,c'`，那么可以左右两边加上大口号单引号然后调用类型转换

    ```sql
    '{a,b,c}'::text[]
    ```
2. `string_to_array(text,text...)`：
3. `array_agg(expression)`

### 4.7 record

注意：
1. 如果一个方法返回的是record类型，比如`test()`函数返回了id和name，然后返回类型是record，那么获取这两个值需要`test.id`和`test.name`
 
## 5 终端命令

## 6 新增
有两种：`insert into select`将一个表的数据复制到另一个表，`insert into values`将常量或常量表数据复制到一个表中，两种方式都可以upsert。

1. `insert into t1 select a,b,c from t2 where a=xxxx...`:当insert后面跟select的时候，select后面的where语句的字段默认是属于t2的。如果想插入部分字段，可以`insert into t1(a,b,c) select a,b,c from t2 where a=xxxx...`

问题：
1. insert into不能给紧邻的table命名？
2. 尽量每一个细节都分析到

## 7 查询
去重`DISTINCT`和`DISTINCT ON`:参考https://blog.csdn.net/pg_hgdb/article/details/78513659

### 7.1 行号ctid
PostgreSQL 自带的表是堆表，数据按行存储在HEAP PAGE中，在btree索引中，除了存储字段的value，还会存储对应的ctid(即行号)，检索记录也是通过行号进行检索的。因此通过行号是可以快速检索到记录， 行号的写法是(数据块page_number, 条号item_number)，数据块从0开始编号，条号从1开始编号

## 8 更新
连表更新的写法：
```sql
UPDATE t1 SET xxx = t1.xxx FROM t2 
WHERE t1.xxx = 
```

## 9 删除 

## 10 UPSERT（insert on conflict do）
当插入遇到约束错误时，直接返回或者改为执行 UPDATE。

不存在则插入，存在则更新，如`insert into test values (1,'hello digoal',now()) on conflict (id) do update set info=excluded.info,crt_time=excluded.crt_time; `

不存在则插入，存在则直接返回，即不做任何处理，如`insert into test values (1,'hello digoal',now()) on conflict (id) do nothing;`

## 11 操作后的返回值
可以使用`returning xxx as yyy`返回受影响的数据

## 12 case when then 
语法形如
```sql
CASE WHEN condition THEN result
        [WHEN condition THEN result ...]
        [ELSE result]
END
```
condition为bool，如果都为true则返回后面的result，如果都为false，则返回ELSE后的result，如果都为false且没有ELSE，则返回null。

# 四 高级
## 1 psql
### 1.1 元命令/斜杠命令/终端命令
常用元命令:
1. 查看连接信息：`\conninfo`
1. 列出该数据库所有表格：`\d`
3. 切换数据库、用户：切换数据库`\c database_name`,切换用户`\c user_name`
4. 切换为每条记录一行，有时很有用，默认未开启:`\x`
5. 打开执行计时，非常有用:`\timing`
6. 执行shell命令：`\! shell_command`
7. 每SEC秒执行查询，默认2s:`\watch SEC`,e.g.,`select * from orders;\watch 1`
8. 切换对齐与否：`\a`

## 2 索引
1. specify postgreSQL index type while creating a new index on a table：`CREATE INDEX index_name ON table_name USING index_type (column);`,e.g.,`CREATE INDEX test_index ON numbers using hash (num)`

## 3 transactions
使用BEGIN、COMMIT、ROLLBACK

## 4  execution plan or query plan
查看执行计划：`EXPLAIN query_sql`,

通过执行sql来显式执行计划：`EXPLAIN ANALYZE query_sql`(会真的执行吗)

扫描：分全表扫描、索引扫描（seq scan）和ctid扫描（Tid scan）。要使用tid进行快速的行扫描，必须开启参数enable_tidscan。

## 5 函数和存储过程
### 5.1 函数
例子`raise notice 'this is raise demo , param1 is % ,param2 is %',param1,param2;`，raise用于打印输出，后面的百分号就是占位符，不用考虑值的类型。notice是级别，可以为debug/log/info/notice/warning/exception，这些级别的信息是直接写到服务端日志还是返回到客户端或是二者皆有，是由log_min_messages和client_min_messages两个参数控制，这两个参数在数据库初始化时用到

`$$`表示函数实际代码的开始和结束。

## 6 聚合/聚集函数和窗口函数
参考：https://time-track.cn/postgresql-window-function.html

## 7 常量表/常数表
写法形如`value (1, 'one'), (2, 'two'), (3, 'three')`，可以当做一个表来用，写法如`(VALUES (1, 'one'), (2, 'two'), (3, 'three')) as tmp(a,b)`

## 8 数据备份和恢复
### 8.1 使用COPY TO和COPY FROM导入导出表为CSV文件
可以直接跟表名，也可以跟查询语句
1. 导出：`COPY (select id as COL_ID, name as COL_NAME from my_tab order by id) to 'D:/server_exp_dir/file_name.csv' with csv header;`
2. 导入：`COPY tanktab from '/u02/tank/123456.csv' with csv header;`
3. 将远程的数据导出到本地文件中:`psql -h 192.168.xxx.xxx -p 21770 -d db_name -U readonly -c "COPY (select * from table_name where company_id = 518 order by id) TO STDOUT with csv header" > /home/qa2/tmp/ruipai_back/company_stocks_back.csv`
3. 将本地文件中的数据导入到远程数据库中:`psql -h localhost -p 21770 -d db_name -U pgdata -c  "COPY table_name(xxx) from STDIN with csv header" < /home/prod/tmp/back_up/xxx.csv`

### 8.2 使用pg_dump导入导出数据库
参考：https://www.postgresql.org/docs/9.6/static/app-pgdump.html

需要角色具有转储权限，如果没有那么需要切换角色或者修改权限。

导出格式包括文本格式：`.sql`和非文本格式`.tar`、`.dump`，如果是非文本格式，需要配合`pg_restore`恢复

导出：`pg_dump -h 127.0.0.1 -p 7002  -t t   test > 8.sql`
恢复：`psql -h 127.0.0.1 -p 7002   monitor <8.sql`

## 9 事务
ACID

PostgreSQL中支撑ACID的主要是MVCC和WAL两项技术。（原理？）

事务的控制：
1. 开启事务：`BEGIN` or `BEGIN TRANSACTION`
2. 提交事务：`COMMIT`or `END TRANSACTION`
3. 回滚：`ROLLBACK`


SQL标准有4种隔离机制/级别：
- Read Uncommitted（未提交的读取）
- Read Committed（提交的读取）：pgsql默认
- Repeatable Read（可重复读）：mysql默认
- Serializable（可串行化）

表格：待补充

pgsql只实现了2和4

隔离级别命令：
1. 查看和设置隔离级别：`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE`

### 9.2 Read Committed
在该级别，每个语句看到的是该语句执行前所有已经committed数据的快照，如果不加"begin....commit/rollback"，每一个SQL语句都是一个transaction，都有自己的transaction ID。

### 9.3 Repeatable Read
在这个级别，每个语句看到的是该事务执行前所有已经committed数据的快照。（所以在这个隔离级别，同一个transaction中多次执行同一个select语句会得到相同的结果。）


## 10 并发控制和锁
参考：https://www.cnblogs.com/biterror/p/7161631.html?utm_source=itganhuo&utm_medium=referral

锁的粒度：一般有行锁，页锁和表锁。PostgreSQL采用MVCC的方式进行并发控制，每个事务看到的是一段时间前的数据快照。同时，MVCC并不能够解决所有问题，所以也提供了行级和表级的锁。pg设计锁等待时，以队列方式存储等待锁。

`deadlock_timeout`：在等待一个lock被释放的时间里，多久可以启动deadlock检查机制，默认是1s。查看`show deadlock_timeout`

`lock_timeout`：单位是毫秒，设为0表示无线等待，默认为0。

`statement_timeout`

### 10.1 共享锁/读锁（Shared lock）
表锁的命令形如：`lock table_name ...`

表共享锁：`select`(?)

行共享锁`select for update/for share`：无论where有没有触发到索引，都是行级锁。
1. 使用`select for update`，数据被锁住时，对数据进行修改操作，会等待，如果设置了`lock_timeout`（非0），超时时会出现“canceling statement due to user request”
2. 使用`select for update nowait`，数据被锁住时，对数据进行修改操作，会报数据库错误
3. `select for update skip locked`，跳过已被锁的数据

注意：
1. 连表查询加锁时，不支持单边连接（left jon等）

### 10.2 排他锁
表排他锁：`drop`(?)

行排他锁：`insert/update/delete`

# 六 问题
## 1 解决
### 1.1 时间和时间戳的转换（待补充）
```sql
--日期转时间戳
SELECT EXTRACT(epoch FROM NOW());
SELECT EXTRACT(epoch FROM CAST('2017-12-06 00:17:10' AS TIMESTAMP));
SELECT EXTRACT(epoch FROM '2017-12-06 00:17:10'::TIMESTAMPTZ);

--时间戳转日期
SELECT TO_TIMESTAMP(1512490630)
```

### 1.2 行列转换
列->行：
1. `string_agg()`
2. `array_agg()`

行->列：
1. `regexp_split_to_table()`

## 2 未解决
1. 数值型有哪几种，取值范围，默认的是哪种

# 七 待整理
## 1 待笔记
1. excluded：在upsert语句中，表示values（）括号里面的值
2. upsert语句中returning的返回包括insert和update
3. pgsql自带的表是堆表。

## 2 未整理
1. PostgreSQL的扩展和标准有什么区别
2. 标准sql中用户额角色的区别
3. 显式当前用户
4. primary 和uniq等
5. 几种分页方法
6. 和mysql等的区别
7. https://yq.aliyun.com/groups/29
9. 聚合查询so hard？
10. 多表关联更新类似下面这样：
    
    ```sql
    For those actually wanting to do a join you can also use:

    UPDATE a
    SET price = b_alias.unit_price
    FROM a as a_alias
    LEFT JOIN b as b_alias ON a_alias.b_fk = b_alias.id
    WHERE a_alias.unit_name LIKE 'some_value' AND a.id = a_alias.id;
    You can use the a_alias in the SET section on the right of the equals sign if needed. The fields on the left of the equals sign don't require a table reference as they are deemed to be from the original "a" table.
    ```

    不过实测的时候left join 和where的条件似乎有些问题，会把所有数据都更新

11. 函数式索引
    1. 对jsonb的索引

12. text才能转jsonb？
14. 连表的update
    1. 用join似乎会更新整个表的数据，只能用from？
15. 待研究
    1. 可以在upsert的更新中连接其他表吗
16. upsert中的where是对两个操作都生效？
17. https://blog.csdn.net/sunbocong/article/details/79097713
18. sum和count的区别
20. anyelement是任意类型？
    1. numbric和int的区别
    2. numbric和float的区别

21. `show default_transaction_isolation`，设置使用`set`
22. begin，set，commit
23. 堆表和索引组织表的区别，聚集索引表？