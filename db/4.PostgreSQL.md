# 4.PostgreSQL
[TOC]

# 一 概述
## 1 简介
PostgreSQL: 是以加州大学（University of California）伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，常简称为PG

psql: 是PostgreSQL数据库的命令行交互工具

pgAdmin: 是PostgreSQL数据库的图形化管理工具

### 1.1 优点
为什么选择postgresql：
1. PostgreSQL一个事务中可以包含DML, DDL和DCL，除了以下语句：
    - `create tablespace`
    - `create database`
    - 使用concurrently并行创建索引

## 2 历史
formerly known as Postgres, then as Postgres95，now

## 3 常识
### 3.1 pg有类似Oracle的dual表吗？
pg没有dual表，select可以没有from语句。比如查当前时间，可以`select now();`

### 3.2 带加号的元命令
很多命令都支持在后面带上加号，可以输出更详细的信息

### 3.3 pg的null和''
null表示没有值，可以插入到任意类型中，在命令行显示为`¤`（可在配置文件中修改），判断是否null有两种方式，两种方式的适用场景也不同，
1. `is null`和`is not null`
2. `is distinct from`：它把两个null当做不同的来对待，两个NULL值返回FALSE，一个NULL值返回TRUE

    ```sql
    select null is distinct from null; -- false
    select null is not distinct from null; -- true
    ```

`COALESCE()`：返回参数中第一个非null的值，要求参数中至少有一个是非null的，否则报错，而且所有参数必需是一个类型（null可以看作任意类型），对于空行`COALESCE()`不会生效。比如
```sql
select COALESCE(null,null); -- 报错
select COALESCE(null,null,now(),''); -- 结果会得到当前的时间
select COALESCE(null,null,'',now()); -- 结果会得到''
select COALESCE(updated_at,now()) from t1; -- updated_at如果是时间类型，能正确返回
select COALESCE(updated_at,now()::text) from t1; -- updated_at如果是时间类型，此时会报类型错误
select COALESCE(updated_at,now()) from t1 where id = 2; -- updated_at如果是时间类型且不存在id为2的数据，此时返回空行

select null - null; -- 报类型错误，系统不知道该用什么类型的减法
select updated_at - updated_at from t1; -- 如果updated_at为null，那么结果为null
select COALESCE(updated_at - updated_at, interval '1 year') from t1; -- 得到1 year
```

而`''`表示空字符串，有值，只不过这个值是空字符串。

### 3.4 使用大写字母和关键字
无论是表名还是字段名，如果你需要使用大写字母或一些关键字，那么这个表名或字段在使用的时候，需要加双引号

### 3.5 查看和设置参数
使用`set`和`show`，如
```sql
show all -- 查看db所有参数的值
show option_name -- 查看某一个用
show enable_seqscan -- 查看是否开启全表扫描
show default_transaction_isolation
```

### 3.6 psql源码目录
pgsql/src/bin/psql/describe.c（待确认）


### 3.7 存储一个典型的文本文件里的数据需要多少磁盘空间？ 
一个 Postgres 数据库（存储一个文本文件）所占用的空间最多可能需要相当于这个文本文件自身大小5倍的磁盘空间。

### 3.8 统计信息
参考：
1. https://yq.aliyun.com/articles/49359

PostgreSQL是catalog-driven型的数据库，引擎运行过程中所有所需的数据、信息都存放在系统表中，统计信息不例外。这些统计信息，则是通过SQL命令vacuum和analyze分别写入pg_class和pg_statistic中的。

#### pg_class
参考：https://www.postgresql.org/docs/9.4/catalog-pg-class.html

输入`\d pg_class`可以看到pg_catalog.pg_class的表结构，重点关注relpages和reltuples两个字段，分别表示这张表占了多少磁盘页和行数。其中行数是估计值。而这两个字段的值是通过vacuum、analyze（或create index)来更新的。


#### pg_statistic
参考：https://www.postgresql.org/docs/9.4/catalog-pg-statistic.html

输入`\d pg_statistic`查看pg_catalog.pg_statistic表结构，重点关注一下几个字段：
1. `stakindN`：用于表示后面number、values所表示的数据用途，被用于生成pg_stats。如1则表示是MCV的值；2表示直方图（histogram）的值；3表示相关性（correlation）的值等。kind的取值范围：1~99，內核占用；100~199，PostGIS占用；200~299，ESRI ST_Geometry几何系统占用；300~9999，公共占用。
2. `staopN`:用于表示该统计值支持的操作，如’=’或’<’等。
3. `stanumbersN`:如果是MCV类型（即kind=1），那么这里即是下面对应的stavaluesN出现的概率值，即MCF。
4. `stavaluesN`:anyarray类型的数据，內核特殊类型，不可更改。是统计信息的值部分，与kind对应。如kind=2的时候，则这里的值表示直方图。
5. 
这些值的更新都是通过analyze完成，N的取值是[1, 5]，由PG內核决定的。将来有可能更多。

### 3.9 什么是 OID ？什么是 CTID ？ 
PostgreSQL 里创建的每一行记录都会获得一个唯一的OID，除非在创建表时使用WITHOUT OIDS选项。 OID创建时会自动生成一个4字节的整数，所有 OID 在相应PostgreSQL服务器中均是唯一的。 然而，它在超过40亿时将溢出， OID此后会出现重复。PostgreSQL 在它的内部系统表里使用 OID 在表之间建立联系。 

在用户的数据表中，最好是使用SERIAl来代替OID 因为SERIAL只要保证在单个表中的数值是唯一的就可以了，这样它溢出的可能性就非常小了， SERIAL8可用来保存8字节的序列数值。 

CTID 用于标识带着数据块（地址）和（块内）偏移的特定的物理行。 CTID 在记录被更改或重载后发生改变。索引数据使用它们指向物理行。 

### 3.10 定义自增列
两种方法：
1. 使用`serial`或`serial8`类型:
    1. serial类型，自动创建一个序列，同时将列设置为INT，默认值设置为nextval('序列')，比如`create table test(id serial, info text)`，使用`\d+ test`可以看到id列的default值为`nextval('test_id_seq'::regclass)`，所以该句等同于
    
        ```sql
        create sequence seq1;  
        create table test (id int default nextval('seq1'), info text);  
        ```
    2. serial8类型，，自动创建一个序列，同时将列设置为INT8，默认值设置为nextval('序列')。用法同上
2. 使用identity列定义（需要pg版本 >= 10）：IDENTITY是为了兼容SQL Server或SQL标准，功能和serial类似，而且加入了一个新的功能，可以允许用户选择是否覆盖这个列的默认值。语法`GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ]`,`ALWAYS`表示优先使用系统列生成的自增值，`BY DEFAULT`表示优先使用用户输入的值。使用`always`时，如果要覆盖系统产生的值，需要使用`OVERRIDING SYSTEM VALUE`，使用`by default`时，如果要使用系统产生的值（覆盖用户提交的值），需要使用`OVERRIDING USER VALUE`。不管使用`always`还是`by default`，使用COPY导入数据时，输入的值会强行覆盖IDENTITY的设置。

    ```sql
    create table test1 (id int GENERATED BY DEFAULT AS IDENTITY (cache 100), info text);
    -- 覆盖设置的例子
    insert into test (id, info) OVERRIDING SYSTEM VALUE values (1,'test');
    insert into test1 (id, info) OVERRIDING user VALUE values (1000,'test');
    ```

## 4 文档网址等
1. pg中文社区：http://www.postgres.cn/v2/document
    1. 9.6中文手册：http://www.postgres.cn/docs/9.6
        1. 具体要看某一节可以直接跟上章节名字，比如要看window function，可以http://www.postgres.cn/docs/9.6/tutorial-window.html
2. 网友的学习资料：
   1. https://github.com/digoal/blog/blob/master/README.md
   2. https://github.com/ty4z2008/Qix/blob/master/pg.md
3. http://www.postgresqltutorial.com/
4. 源码
   1. https://github.com/postgres/postgres
   2. https://doxygen.postgresql.org/（待确认）

# 二 安装配置
## 1 win
这里使用EnterpriseDB提供的安装包安装，EnterpriseDB 是全球唯一一家提供基于 PostgreSQL 企业级产品与服务的厂商。

步骤：
1. 默认的superuser是postgres，密码自己指定
2. "postresql select the locale be used by new database cluster"，这里选择默认的就好
3. Stack Builder:目前它的作用就是按照语言模块
    1. 安装语言模块(因为需要用到中文)：类别 -> Add-ons, tools and utilities -> EDB Language Pack xxx，会先下载，下载完之后再安装。
4. 安装成功后服务默认启动

设置环境变量:安装后psql是没有被加到环境变量里的，需要把对应的bin目录加到环境变量里或去安装目录下才能执行。
1. 设置`PGHOME`，即pg的安装目录，比如`D:\Program Files\PostgreSQL\12`
2. 然后把`PGHOME/bin`加入path

## 2 linux
### 2.1 ubuntu wsl
以ubuntu wsl为例，`apt`安装，安装时会自动创建postgres的用户，配置文件似乎都在`/etc/postgresql/pg_versionA/main/...`

1. 启动:`sudo /etc/init.d/postgresql start`
2. 切换到postgres用户:`sudo su postgres`

### 2.2 CentOS
参考：https://www.postgresql.org/download/linux/redhat/

安装后配置文件在：
1. `/var/lib/pgsql/12/data/pg_hba.conf`
2. `/var/lib/pgsql/12/data/postgresql.conf`

配置：
1. 开启远程访问
    1. 修改`/var/lib/pgsql/12/data/postgresql.conf`
        
        ```bash
        # 取消下面两行的注释并修改 localhost为 *
        # listen_addresses = 'localhost'          # what IP address(es) to listen on;
        # port = 5432                             # (change requires restart)
        listen_addresses = '*'          # what IP address(es) to listen on;
        port = 5432                             # (change requires restart)
        ```
    
    2. 修改
    
        ```bash
        # "local" is for Unix domain socket connections only
        local   all             all                                     trust # 本地访问不需要认证
        # IPv4 local connections:
        # host    all             all             127.0.0.1/32            ident
        host    all             all             0.0.0.0/0               md5 # 支持外部访问
        ```

## 3 mac下的安装
### 3.1 官网提供的app
### 3.2 brew安装（推荐）
1. `brew install postgresql`，数据库会被安装且初始化，使用Homebrew安装PostgreSQL不用再执行`initdb`来完成安装过程
2. 安装brew services，用于管理服务，`brew tap homebrew/services`
3. 以后台服务的方式启动Postgres:`brew services start postgresql`，相应的，停止和重启是`stop`和`restart`。如果不想后台启动，可以用`  pg_ctl -D /usr/local/var/postgres start`
4. 登录：默认有数据库postgres，所以可以直接用`psql -d postgres`登录

## 4 配置
参考：https://www.citusdata.com/blog/2017/07/16/customizing-my-postgres-shell-using-psqlrc/

命令历史文件是在`~/.psql_history`，但好像不准？

psql的配置文件是`~/.psqlrc`，如:
```sql
\timing # 显示执行时间
\pset null '¤' # 设置打印空值时打印的字符串，因为空值容易和空字符串混淆
\x auto
\setenv PAGER 'less -S -m'
```


数据库的配置文件是`postgresql.conf`？

# 三 基础

## 1 角色和用户
PostgreSQL使用角色(role)的概念管理数据库访问权限。可以将角色视为一个或一组数据库用户(user)，具体取决于角色的设置方式。（用户也是角色，用户可以看作具有登录权限的角色）角色可以拥有数据库对象（例如，表和函数），并可以将这些对象的权限分配给其他角色，以控制谁有权访问哪些对象的权限。在8.1之前的PostgreSQL版本中，用户和组是不同类型的实体，但现在只有角色。任何角色都可以充当用户，组或两者。

`createuser`工具：实际上调用此命令`CREATE ROLE`，命令`createuser`会传输加密的密码，但`CREATE ROLE`传输明文密码。

1. 创建角色
    1. 普通创建`CREATE ROLE role_name`：默认不会赋予登录/建表等权限。
    2. 带密码的创建`create user test_user with password 'abc123';`
    3. 带权限的创建`CREATE ROLE role_name privilege_name`。比如
        ```sql 
        CREATE ROLE developer1 login; -- 创建具有登录权限的角色
        CREATE ROLE developer1 SUPERUSER; -- 创建具有超级用户权限的角色
        ```
2. 查看所有user:`s`，查看所有role：`select * from pg_roles;`
3. 为角色/用户赋予权限:`alter role/user role_name/user_name permission_name`,
    1. 赋予登录权限：`alter user user_name login`
    2. 赋予某个数据库的所有权限`grant all privileges on database dbA to userA;`
    1. 把某个用户设置为超级用户（需要用户是用superuser权限，否则会提示`must be superuser to alter superusers`）:`alter user xxx superuser`,也可以用`ALTER USER mydb_user WITH SUPERUSER`。
4. 修改角色密码
    
    ```sql 
    alter role postgres password 'newPasswordA';
    alter user postgres with encrypted password 'newPasswordA';
    ```
4. 删除角色：`drop role xxx`

### 1.1 授权和取消授权GRANT and REVOKE
```sql
grant db_role1 to db_user1,db_user2; --给用户1,2赋予角色1。假设角色1有创建数据库和创建角色的权限，则两个用户就拥有了创建数据库和创建角色的权限
revoke db_role1 from db_user1; --从用户1移除角色1，用户不在拥有角色1的权限
```

## 2 数据库
createdb和create database

1. list all database：`\l`
1. calculate db size in disk：`pg_database_size('db_name')`,it shows the size in bytes.

### 2.1 跨库连表
#### dblink

#### postgres-fdw

## 3 表
ps的表包含：系统表...
1. list all tables or table info:`\d t_name`，使用`\d+ t_name` 可以看到table的更多信息，比如comments。

删除表：
1. calculate table size including index and data in disk:`pg_total_relation_size('table_name')`,not including



### 3.0 表分类
#### 序列
序列对象（也叫序列生成器）就是用CREATE SEQUENCE或其他方式创建的特殊的单行表。一个序列对象通常用于为行或者表生成唯一的标识符。

操作：
1. 使用序列(待整理)
1. 删除序列，语法是`DROP SEQUENCE [ IF EXISTS ] name ...`
    1. 如果有表字段用到该序列，则不能直接删除
    2. 如果序列是由建表时指定serial 创建的，删除该表的同时，对应的序列也会被删除

### 3.1 约束
关键字constraint: 指定约束的名称，需要使用关键词“constraint”。

约束类型分为：检查约束(CHECK)、非空约束、唯一约束(UNIQUE)、主键(PRIMARY KEY)、外键(FOREIGN KEY)。pg会自动在组成主键或唯一约束的字段上创建唯一索引，以强迫这些约束。所以我们没有必要在唯一字段上再手动建立索引。

查看所有约束:用`\d`或者查`information_schema.table_constraints`表
```sql
select * from information_schema.table_constraints;
```

检查约束：设置某个字段里的数值必须满足约束表达式的条件。
```sql
create table person(name varchar(40),age int check (age >=0 and age<=120));
create table person(name varchar(40),age int constraint age_chk check (age >=0 and age<=120)); -- 指定约束名称
```

非空约束：非空约束仅仅指定一个列中不会有空值。非空约束等价于检查约束（column_name is not null）
```sql
create table person(name varchar(40),age int check not null;
```

唯一约束：唯一约束保证在一列或一组列中保存的数据是唯一值。
```sql
-- 创建
create table products (product_no integer UNIQUE, ...) -- 给单个列定义唯一约束
create table products (product_no integer CONSTRAINT pro_no_unique UNIQUE, ...) -- 给唯一约束指定名称
create table products (product_no integer, price numeric, ..., UNIQUE(product_no, price)) -- 给一组列定义唯一约束

-- 删除：实测想修改的话，似乎只能删除重建，不能直接修改。
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```
### 3.2 常量表/常数表
写法形如`values (1, 'one'), (2, 'two'), (3, 'three')`，可以当做一个表来用，写法如`(VALUES (1, 'one'), (2, 'two'), (3, 'three')) as tmp(a,b)`

常量表必需起个别名。

### 3.3 用WITH生成临时表
With语句中可以使用select，insert，update，delete语句。with也可以看成是一个单独的语句。普通写法形如`WITH temp_table_name AS (正常的SQL语句) 正常的SQL语句`，如
```sql
-- 例子1
WITH regional_sales AS (
        SELECT region, SUM(amount) AS total_sales
        FROM orders
        GROUP BY region
     ), top_regions AS (
        SELECT region
        FROM regional_sales
        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)
     ) -- 注意结尾这里不需要分号
SELECT region,
       product,
       SUM(quantity) AS product_units,·
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product; 

-- 例子2:带上字段名
with confirm_data(detail_id, rejected_qty) as (
        values (xxx,xxx),(xxx,xxx) ...
    )
```

常用场景：当一个查询的结果希望被重用或者这个结果集在另外一个查询中作为数据源，可以用普通SQL实现，但with语句逻辑更清晰、使用更方便。

#### 递归查询（待补充）
实现递归，是with的一个重要特性

### 3.4 建表
```sql
-- 一般建表语句
create table student(id serial,name character varying,course character varying,score integer);
-- 建表时指定owner
create database dbA owner userA;
```

### 3.5 表修改
上级语法`ALTER TABLE xxx action`，具体参考文档

```sql
-- 修改db owner
alter database dbA owner to userA;

-- 新增列
-- 1. 新增单列
ALTER TABLE xxx ADD COLUMN qty numeric(18,6) default 0 NOT NULL
-- 2. 新增多列
ALTER TABLE xxx ADD COLUMN qty numeric(18,6) default 0 NOT NULL, ADD COLUMN name text NOT NULL default '' ...;

-- 修改列
-- 1. 重命名字段
ALTER TABLE table_name RENAME [COLUMN] old_name TO new_name;

-- 增加注释:查了下，似乎没有批量增加的语法，感觉应该是不需要批量吧
-- 1. 直接加注释
COMMENT ON COLUMN table_name.created_by IS '创建人';
-- 2. 建表的时候加上注释：语法和上面一样，pg不能像MySQL、Oracle那样可以直接加在列后面
create table table_name(id int not null, url_id int);
comment on column table_name.id is '主键ID，自增';
-- 查询表注释
select description 
from pg_descriptionjoin pg_class on pg_description.objoid = pg_class.oid 
where relname = 'table_name';
-- 删除注释
COMMENT ON COLUMN table_name.created_by IS null;
```

## 4 数据类型
查看数据类型：`pg_typeof()`

数据类型转换:使用cast语法，`cast`或`::`,但`::`不符合SQL规范


### 4.1 boolean/bool
### 4.2 字符
注意PSQL的字符串必须用单引号包裹。

常见有三种类型，这三种性能都差不多，区别在于适合什么场景：
1. `char(n)`（是`character(n)`的别名）：定长字符串，实际数据不足定义长度时，以空格补齐 。不加n表示单个字符。适合于存储长度相同的字符串。
2. `varchar(n)`(是`character varying(n)`的别名)：变长字符串，理论上长度不限，不足定义长度的部分不补齐。适合存储限制了最大长度的变长字符串。
3. `text`:变长字符串，和varchar(n)基本一样。适用于存储最大可达 1G左右但未定义限制长度的字符串

类型后面的n：实测表示的是字符数

字符的操作：
1. 切割
    1. 切割并截取`split_part(str text, delimiter text, field int)`:str表示要切割的字段，delimiter表示分隔符，field表示截取的位置。
        
        ```sql
        split_part('name.cn.com', '.', 1); -- name
        split_part('name.cn.com', '.', 2); -- cn
        split_part('name.cn.com', '.', 3); -- com
        ```


### 4.3 数值
pg数字类型最小的是占两个字节，没有一个字节的？（待补充）
1. 整数
    1. smallint
    2. int
    3. serial
    4. bigint：将一个浮点数转成该类型时是四舍五入。
2. 浮点数
    1. float
    2. real
    3. numeric
    
常用操作：
1. 数值截取
2. 小数位
    1. `round(numA, precisionA)`
        ```sql
        -- 保留3位小数
        select round(2.45555, 3); -- 2.456
        ```
3. 绝对值
    1. `abs(numA)`
4. 转字符串

### 4.4 时间
参考;
1. https://www.postgresql.org/docs/9.2/functions-datetime.html

pg支持的时间类型有：
- 日期`date`:calendar date (year, month, day)，建议日期的输入格式为`1997-01-01`，同时也支持其他格式。
- 日期和时间`timestamp[(p)] with(without) time zone`:date and time，业务中一般不会存在多个时区的切换，所以一般使用无时区的时间戳就可以满足需求，建议时间戳的输入格式为`1997-01-01 00:00:00`。只写`timestamp`表示`timestamp without time zone`.
- 时间`time[(p)] with(without) time zone`：time，和时间戳类似的是，一般无时区即可满足需求。它只表示一天的时间点，不包含日期，如

    ```sql
    12:00:00,
    120000,
    12:00
    8:00 AM,
    8:00 PM
    ```
- 时间间隔`interval [fields][(p)]`:可以用单词复数，可以用简写，如

    ```sql
    select interval '1 year 2 months 3 days 4 hours 5 minutes 6 seconds';
    select interval '1 y 2 mon 2d 12:09:12';
    select interval '1 y 2 mon 2d 12h 09m 12s';
    -- 不加单位，默认是秒 
    select interval '5'; -- 00:00:05
    ```

时间的几个特殊值:`epoch`、`today`、`tomorrow`、`yesterday`、`allballs`等，用单引号包裹然后转换成时间类型。如，
```sql
select 'epoch'::time; -- 
select 'today'::date
```

时间的操作：
1. 获取时间：
   1. 兼容SQL标准的函数：`CURRENT_DATE`，`CURRENT_TIME`， `CURRENT_TIMESTAMP`(和`now()`等效)，`LOCALTIME`， `LOCALTIMESTAMP`
2. 时间的比较
   1. 公共部分相同的日期，格式多的比少的大(?)。如`2019-03-02 19:41:14.692522+08`大于`2019-03-02`
3. 时间的加减：

    ```sql
    -- 几种时间类型的加减写法有些区别，写法以此类推，注意减法的写法
    -- 1. date的加减写法如下
    select date'2020-02-26' + 7; -- 增加七天
    select date'2020-02-26' + integer '7'; -- 增加七天
    select date'2020-02-26' + interval '7 year'; -- 增加七年
    select date'2020-02-26' + interval '7' year; -- 增加七年
    select date'2020-02-26' - interval '7h'; -- 减少7小时
    select date'2020-02-26' + interval '-7h'; -- 减少7小时
    -- 2. timestamp的加减写法如下
    select now() + '1 year'; -- 增加一年
    select now() + '-1.5 day'; -- 减少1.5天
    -- 3. time的加减法
    ```
4. 时间差值的计算
   1. 使用`date_part()`，如`select date_part('day', now() - now())`，向下取整，第一个参数表示单位，可以是`year`、`month`等
   2. 计算天数的话可以直接让两个date类型相减，如`select '2018-01-15 14:00'::date - '2018-01-14 00:05'::date;`，得到的结果是1.
5. 字符串转时间：写法是把时间类型放在字符串的前面（可挨着可不挨着），如

    ```sql
    select timestamp(1) without time zone '2016-07-08 12:00:00.234'; -- 2016-07-08 12:00:00.2
    select date'2016-07-08' - 7; --  2016-07-01
    select timestamp'2016-07-08 22:00:00' - date'2016-07-08'; --  22:00:00
    select 10*interval'1h'; --  10:00:00
    ```
6. 时间的截取：推荐使用`EXTRACT(field FROM source)`，field表示取的时间对象；source表示取的日期来源，类型为timestamp、time 或 interval。

    ```sql
    -- 1. 取年份
    select extract(year from now()); -- 2013
    ```

### 4.5 json和jsonb
区别：
1. 最大的区别是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的二进制格式中，因为需要做附加的转换，它在输入时要稍慢一些。但是 jsonb在处理时要快很多，因为不需要重新解析。总结就是json写入快，读取慢；jsonb写入慢，读取快；
2. jsonb支持索引，json不支持
3. 有些方法比如`jsonb_set()`只支持jsonb。
4. json会存储空格和JSON 对象内部的键的顺序。如果一个值中的 JSON 对象包含同一个键超过一次，所有的键/值对都会被保留（ 处理函数会把最后的值当作有效值）。jsonb不保留空格、不保留对象键的顺序并且不保留重复的对象键。如果在输入中指定了重复的键，只有最后一个值会被保留

所以一般更推荐使用jsonb

写法：字面写法是key必需用双引号包裹。

操作：
1. 插入json：`INSERT INTO orders (info) VALUES ('{ "customer": "John Doe", "items": {"product": "Beer","qty": 6}}');`
2. 查询：
    1. 查询字段时以JSON的形式返回结果集
    2. 查询字段的某个属性可以使用`->`和`->>`操作符，前者以json类型返回，后者以text类型返回，这两个操作符后可以跟key即属性名（针对对象），也可以跟序号（针对数组，从0开始）。如果是属性名要加上引号，对json字段的某个属性做类型转换时括号需要将整个包裹，形如`select (info -> 'items' ->> 'qty')::int from ...`，如果没有这个属性，返回null
        
        ```sql
        select '[1,2]'::jsonb ->> 1; -- 输出2
        select '{"name":2}'::jsonb ->> 'name'; -- 输出2
        select '{"name":2}'::jsonb ->> 1; -- 对对象用序号获取到的是null
        ```
    3. `#>`和`#>>`:`#>`表示获取指定路径的一个JSON类型，`#>>`表示获取指定路径的一个text类型
3. 修改：9.5以下只能整个字段修改（想使用扩展可以通过jsonbx插件），不支持部分修改，9.5开始可以使用`||`操作符和`jsonb_set()`函数对jsonb（不支持json格式）格式的字段进行修改。而且`||`会将path下所有的嵌套元素值整个替换为new_value，而`jsonb_set()`只替换path。（待补充）例子如

    ```sql
    
    ```
4. 删除：使用`-`操作符或指定路径的方式删除
5. 连接（Concatenate）两个json：使用`||`
6. 遍历
7. 相关函数
    1. `jsonb_set(target jsonb, path text[], new_value jsonb[, create_missing boolean])`:create_missing表示要修改的属性值不存在时是否新增该属性值，默认为true

        ```sql
        update orders set info = jsonb_set(info::jsonb,'{name}','"Zhang"') where id = 5;
        ```

        1. 实测缺点是只能修改某个属性，无法修改平级的多个属性，想实现的话只有自定义函数
    2. `jsonb_object_keys`:以列的方式展开所有的key
    3. `jsonb_pretty()`
    4. jsonb_to_record
    5. jsonb_populate_recordset

### 4.6 数组
pg的数组下标从1开始，比如获取第一个元素`t.xxx[1]`

转换成数组的几种方法：
1. 类型转换：假如有字符串`'a,b,c'`，那么可以左右两边加上大扩号单引号然后调用类型转换

    ```sql
    '{a,b,c}'::text[]
    '{NULL,1,NULL,2}'::int[]
    ```
2. `string_to_array(text,text...)`：
3. `array_agg(expression)`

声明数组：字符串数组`'{"aaa","bbb"}'`或`ARRAY['aaa','bbb']`，数值数组`'{12,5}'`或`ARRAY[12,5]`，空数组`'{}'`或`ARRAY[]`。

操作：
1. 模糊匹配是否包含：
    1. 使用`array_to_string(xxx,xxx)`转换成字符串再用LIKE匹配，比如`select array_to_string('{"1","3","4"}'::text[],',') LIKE '%1%'`

### 4.7 record

注意：
1. 如果一个方法返回的是record类型，比如`test()`函数返回了id和name，然后返回类型是record，那么获取这两个值需要`test.id`和`test.name`

### 4.8 网络地址
#### inet
这个数据类型可以用来存储一个IPv4或IPv6地址和它们的子网。数据插入数据库的格式是Address/y，其中y是子网掩码的位数。

#### cidr
这个数据类型也可以用来存储网络和网络地址。一旦我们指定cidr数据类型的子网掩码，如果设置的位数超出了掩码，PG就会抛出一个从错误。

#### macaddr
存储不同格式的MAC地址

### 4.9 UUID
PostgreSQL-core不包含生成UUID的方法，需要依赖第三方扩展，比如`uuid-ossp`，然后可以生成UUID
使用：
1. 生成UUID

    ```sql
    select uuid_generate_v1(); -- v1版本的uuid
    select uuid_generate_v4(); -- v4版本的uuid
    ```
2. 创建表时指定字段为自动生成的UUID
    
    ```sql
    CREATE TABLE contacts (
        contact_id uuid DEFAULT uuid_generate_v4 (),
        first_name VARCHAR NOT NULL,
        last_name VARCHAR NOT NULL,
        email VARCHAR NOT NULL,
        phone VARCHAR,
        PRIMARY KEY (contact_id)
    );
    ```
 
## 6 新增
有两种：`insert into select`将一个表的数据复制到另一个表，`insert into values`将常量或常量表数据复制到一个表中，两种方式都可以upsert。而且可以混用

如何插入单引号呢：(参考：https://stackoverflow.com/questions/12316953/insert-text-with-single-quotes-in-postgresql)pq的标准做法是用连续的两个单引号来表示一个单引号
```sql
insert into t1(name) values('汤姆''杰克逊'); -- 实际插入的是 汤姆'杰克逊
```

### 6.1 insert into select
1. `insert into t1 select a,b,c from t2 where a=xxxx...`:当insert后面跟select的时候，select后面的where语句的字段默认是属于t2的。如果想插入部分字段，可以`insert into t1(a,b,c) select a,b,c from t2 where a=xxxx...`。需要注意
1. select后字段的顺序必需和`(a,b)`一致，或者和t1声明默认的字段顺序一致。
2. 默认隔离级别下，t2是扫描一行锁一行(待整理)

### 6.2 insert into values
2. `insert into t1(name) values ('xxx'),('xxx') ...`，似乎和其他语言有点不一样。

### 6.3 select into table2 from table1
要求table2不存在，因为会自动创建table2然后将数据插入进去

### 6.3 混用两者
```sql
insert into orders select a.info, b.address from person a, (values ('四川')) as b (address) where a.id  = 7 returning id;
```

问题：
1. insert into不能给紧邻的table命名？
2. 尽量每一个细节都分析到

## 7 查询
例子如，
```sql
select (actor_id as id, film_id) from film_actor order by actor_id; -- 错误，括号包裹的时候，里面不能alias
```

### 7.1 行号ctid
PostgreSQL 自带的表是堆表，数据按行存储在HEAP PAGE中，在btree索引中，除了存储字段的value，还会存储对应的ctid(即行号)，检索记录也是通过行号进行检索的。因此通过行号是可以快速检索到记录， 行号的写法是(数据块page_number, 条号item_number)，数据块从0开始编号，条号从1开始编号

### 7.2 distinct和distinct on
两者共同点：null视为相等

`distinct`：根据字段去重，distinct后面的字段都算在唯一里面（不管加没加逗号，所以写法不够灵活），还要注意：
1. 和`order by`一起使用时注意`for SELECT DISTINCT, ORDER BY expressions must appear in select list`
2. `distinct`后面没加逗号的话，跟的是alias，不是字段名，和`distinct on`不一样。

```sql
-- 例子
select distinct actor_id film_id, film_id from film_actor order by actor_id; -- 第一个film_id是actor_id的alias，第二个是字段名
select distinct (actor_id) film_id, film_id from film_actor order by actor_id; -- 第一个film_id是actor_id的alias，第二个是字段名
select distinct actor_id as id, film_id   from film_actor order by actor_id; -- 按actor_id, film_id同时唯一来过滤
select distinct (actor_id) as id, film_id   from film_actor order by actor_id; -- 我以为这样写是只按actor_id唯一来过滤，实际上后面的film_id也算上了，也就是和上面一样
select distinct (actor_id, film_id) as id from film_actor order by actor_id; -- fail。actor_id未出现在select list中，`(actor_id, film_id)`算作一个整体
select distinct (actor_id, film_id) as id from film_actor order by (actor_id,film_id); -- pass
select distinct (actor_id, film_id) as id from film_actor order by id; -- pass
```

如果只想按actor_id唯一来过滤，同时显示film_id，就要使用`distinct on`。注意：
1. `distinct on`的整个参数后面不能加逗号，整个参数后面直接跟的是字段名，也就是说参数的作用只是过滤，而不作为搜索结果。区别于`distinct`
2. 不跟`order by`的话，返回的记是不确定的；如果跟了，分以下情况：
    1. `order by`参数只包含`distinct on`参数（部分或全部），此时没有任何问题
    1. 如果`order by`参数要包含除`distinct on`参数外的其他字段，则`distinct on`参数（全部）必须在`order by`参数的最左边。
   
```sql
-- 例子
select distinct on (actor_id) actor_id, film_id from film_actor order by actor_id; -- pass，只按actor_id唯一过滤
select distinct on (actor_id), film_id from film_actor order by actor_id; -- 语法错误
select distinct on (actor_id) as actor_id, film_id from film_actor order by actor_id; -- as语法错误。
select distinct on (actor_id, film_id) from film_actor order by actor_id; -- 语法错误

-- order by参数顺序的例子
select distinct on (actor_id, film_id) last_update  from film_actor order by film_id; -- pass 
select distinct on (actor_id, film_id) last_update  from film_actor order by last_update; -- 报错：SELECT DISTINCT ON expressions must match initial ORDER BY expressions
select distinct on (actor_id, film_id) last_update  from film_actor order by actor_id,last_update; -- 报错
select distinct on (actor_id, film_id) last_update  from film_actor order by actor_id,last_update; -- 报错
select distinct on (actor_id, film_id) last_update  from film_actor order by film_id,actor_id,last_update; -- pass
select distinct on (actor_id, film_id) last_update  from film_actor order by actor_id,film_id,last_update; -- pass
```

```sql
-- distinct on()里面也可以直接跟字段的顺序来过滤。缺点是意思不够明确，一般不推荐使用。比如下面两个是相等的
select distinct on(2) id, customer, total from purchases; 
select distinct on(customer) id, customer, total from purchases; 

-- pg distinct on()还有个独有的用法，就是取分组后每组的第一条。此时如果不指定order by子句，则返回的第一条可能是不确定的，如果指定order by，则必须把分组字段放在最左边。
select distinct on(customer) id, customer, total from purchases order by customer, total desc, id; 
```

### 7.3 字段
1. PG和SQL Server一样，语法上不需要虚拟表，也没有Oracle那样的虚拟表dual

    ```sql
    select 'Hello' as txt;
    select now();
    ```

2. 如果想在返回的数值型字段前面加上正数或负数，需要别名一下，否则字段名称显示的是?column?
    ```sql
    select -numA from tableA; -- 值是正确的，但是字段名称显示的?column?
    select -numA as numA from tableA; -- 值和字段名都是正确的，字段名称显示的numA
    ```

### 7.3 连接查询
一图胜千言，可以结合韦恩图理解。

链接表、中间表、临时表：这几个都是同一个东西，链接表就是数据库在做查询形成的中间表。本人的理解是在where条件之前形成的表。

多表连接的顺序：先对第一个和第二个表按照两表连接做查询，然后用查询结果和第三个表做连接查询，以此类推，直到所有的表都连接上为止，最终形成一个中间的结果表。

内连接和外连接：inner join（或join）是内连接，left、right、full join是外连接。内连接的特点是两张表地位平等，对于不符合条件的不做连接；而外连接两个表地位不相等，其中有一张是基础表，基础表中的每条数据必须出现，即使另外一张表中没有数据与之匹配，也要用Null补齐。

相等连接（equi-join，或 equijoin）和不等连接：连接符使用`=`的是相等连接，使用`!=`、`<>`等的是不等连接，如，
```sql
```

where、on和having的区别：
1. on条件是在生成临时表时使用的条件，where条件是在临时表生成好后，再对临时表进行过滤的条件。having是对分组后的结果进行过滤（？）。
2. 如果这先后顺序不影响中间结果的话，那最终结果是相同的，此时过滤条件放在哪儿都一样。否则，可以认为效率:on > where > having，过滤条件最好放在对应的位置。
   1. 条件放在on、where哪个比较好呢？个人觉得不影响后续操作的话无所谓，但如果影响的话还是该放在哪儿就放在哪儿。

使用场景的简单判断方法：
1. 查两表关联列相等的数据用内连接。
2. Col_L是Col_R的子集时用右外连接。
3. Col_R是Col_L的子集时用左外连接。
4. Col_R和Col_L彼此有交集但彼此互不为子集时候用全外。
5. 求差操作的时候用联合查询。

#### 内连接：INNER JOIN或JOIN
INNER JOIN产生的结果集中，是左表和右表的交集。写法有两种，显式的和隐式的。如，
```sql
select count(*) from actor t1, film_actor t2 where t1.actor_id = t2.actor_id; -- 隐式的内连接，没有INNER JOIN，形成的中间表为两个表的笛卡尔积
select count(*) from actor t1 join film_actor t2 on  t1.actor_id = t2.actor_id; -- 显示的内连接，有INNER JOIN，形成的中间表为两个表经过ON条件过滤后的笛卡尔积。
select count(*) from actor t1 inner join film_actor t2 on  t1.actor_id = t2.actor_id; -- 和上面相同
```

关于两种写法的效率：区别在于生成的中间表不同，个人觉得，如果这个中间表对后续操作的影响一样，则效率一样，有不同影响，则效率不同。

#### 左连接（左外连接）：LEFT  JOIN或LEFT OUTER JOIN     
LEFT JOIN产生左表的完全集，而右表中匹配的则有值，没有匹配的则以null值取代。
```sql
select * from actor left join film_actor on actor.actor_id = film_actor.actor_id and actor.first_name  = 'Nick' order by actor.actor_id; -- 对于left join，on中的条件不管符不符合，左表都会全部出现在中间表。对于right join同理，其他的区别通过例子自己感受吧。
select * from actor left join film_actor on actor.actor_id = film_actor.actor_id and actor.actor_id  = 1 order by actor.actor_id;
select * from actor left join film_actor on actor.actor_id = film_actor.actor_id and film_actor.film_id  = 1 order by actor.actor_id;
```

#### 右连接（右外连接）：RIGHT  JOIN 或 RIGHT  OUTER  JOIN

#### 全连接（全外连接、完整外连接）FULL  JOIN 或 FULL OUTER JOIN
FULL JOIN 会从左表 和右表 那里返回所有的行（产生左表和右表的并集），"全外=左外 UNION 右外"。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替

```sql
```

#### 交叉连接：cross join，也称笛卡尔连接（cartesian join）
它是所有连接的基础，但一般很少直接使用，因为笛卡尔积运算是最没有效率的。

写法有两种，显式的和隐式的，不带ON子句，返回的是两表的乘积，也叫笛卡尔积。和普通连接的区别是cross join后不能用on条件。如，
```sql
select count(*) from actor, film_actor; -- 隐式的交叉连接，没有CROSS JOIN，结果笛卡尔积，共200*5462=1092400条
select count(*) from actor cross join film_actor; -- 显式的交叉连接，有CROSS JOIN，结果同上
```

可以发现，隐式交叉连接和隐式内连接的写法和效果是一样的，也称为普通连接。

#### USING()
USING()主要用于简化JOIN ON。JOIN USING() 会将每一对相等的输入字段输出为一个字段，其后跟着所有其它字段。因此，USING (a, b, c) 等效于ON (t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c) 只不过是如果使用了ON，那么在结果里a, b和c 字段都会有两个，而用USING的时候就只会有一个。

#### 自然连接：NATURAL XXX JOIN
NATURAL JOIN可以看做是INNER JOIN USING()的简写。SQL2标准中定义的，自然连接无需指定连接列，SQL会检查两个表中是否相同名称的列，且假设他们在连接条件中使用，并且在连接条件中仅包含一个连接列。不允许使用ON语句，不允许指定显示列。对于每种连接类型（除了交叉连接外），均可指定NATURAL。如，
```sql
-- 下面三个SQL是等价的
select *  from actor left join film_actor on actor.actor_id = film_actor.actor_id and actor.last_update = film_actor.last_update order by actor.actor_id;
select *  from actor left join film_actor using(actor_id, last_update) order by actor.actor_id;
select *  from actor natural left join film_actor order by actor.actor_id;
```

#### 联合查询：UNION和UNION ALL
字段：查询结果的列标题为第一个查询语句的列标题。因此，要定义列标题必须在第一个查询语句中定义。要对联合查询结果排序时，也必须使用第一查询语句中的列名、列标题或者列序号。

顺序：多个查询的UNION语句中，其执行顺序是自左至右，使用括号可以改变这一执行顺序。例如:"查询1 UNION (查询2 UNION 查询3)"

UNION和UNION ALL区别：UNION会过滤掉重复的值，而UNION ALL不会。

```sql
-- 例子
```

### 7.4 where条件

#### 7.4.1 =
```sql
select * from person where (id , age) = (1,2); -- 多字段相等的例子
```

#### 7.4.2 like
参考：
1. https://www.postgresql.org/docs/current/functions-matching.html
2. https://dba.stackexchange.com/questions/10694/pattern-matching-with-like-similar-to-or-regular-expressions-in-postgresql

支持标准sql的两个通配符：
1. `_`：匹配单个字符
2. `%`:匹配任意个(包括0个)字符

使用：
1. 一般使用`like pattern`
    
    ```sql
    select name like '%tom%';
    select name like 'tom_';
    
    -- 可以使用正则，参考：https://www.postgresql.org/docs/current/functions-matching.html#POSIX-BRACKET-EXPRESSIONS
    select name ~ '^(张|李).*'; -- 查找所有以张或李开头的name
    select name ~ '^[张李].*'; -- 作用同上，因为使用了character class的写法，所以效率可能会快一点点
    ```
2. 带ESCAPE使用`like 'xxx' ESCAPE 'oneCharacterA'`:默认的转义字符是`\`(转义字符的作用是，让紧跟转义字符的字符变成普通字符处理)，oneCharacterA可以是任意单个字符。
    
    ```sql
    -- 假设有条数据是 test_to'pic
    select * from tableA where fieldA ILIKE '%t\_t%'; -- 能搜索到,因为默认的转义字符就是反斜杠
    select * from tableA where fieldA ILIKE '%t\_t%' escape '\'; -- 能搜索到
    select * from tableA where fieldA ILIKE '%t\_t%' escape 'a'; -- 不能能搜索到，此时转义字符已经变成了a
    
    select * from tableA where fieldA ILIKE '%o''p%'; -- 能搜索到,因为里面的两个单引号实际被认为是一个单引号
    select * from tableA where fieldA ILIKE '%o''p%' escape ''''; -- 不能搜索到,因为单引号现在表示转义字符了
    
    -- 如果我想对多个字符ESCAPE呢，答案是没必要，参考：https://stackoverflow.com/questions/18093403/how-do-i-escape-multiple-characters-in-an-sql-like-string
    ```
3. `SIMILAR TO`语法：它使用的是like和正则表达式的混合体(类似正则的表达式)，感觉没必要浪费脑力学习它，因为
    1. 它会将类似正则的表达式转换为正则表达式，所以我何必直接写正则呢？
    2. 只有pq支持，而标准sql草案后续计划删除它。

操作符：
1. `~~` 等效于LIKE，
2. `~~*` 对应 ILIKE:不区分大小写
3. `!~~` 代表 NOT LIKE
4. `!~~*`   NOT ILIKE。

另外：
1. ~ 匹配正则表达式，大小写相关 'thomas' ~ '.*thomas.*'
2. ~* 匹配正则表达式，大小写无关 'thomas' ~* '.*Thomas.*'
3. !~ 不匹配正则表达式，大小写相关 'thomas' !~ '.*Thomas.*'
4. !~* 不匹配正则表达式，大小写无关 'thomas' !~* '.*vadim.*'

通配符：
1. 

#### 7.4.3 in
`in`里的参数类似于元祖，而且不能为空

```sql
-- 多字段的in的例子
select * from person where (id , age) in ((5,1)); 
select * from person where (id , age) in (select id,age from person where id = 5);
-- 括号中为空会报错
select * from person where id IN (); -- failed
```

#### 7.4.4 any
`IN`和`ANY`的区别参考：
1. https://stackoverflow.com/questions/34627026/in-vs-any-operator-in-postgresql
   1. 大概就是：里面的参数类型不一样，然后查询计划也可能不一样，`any`写法更加通用

`any`里的参数必需是数组类型

```sql
-- 一般用法
select * from orders where id = any('[1, 2, 3]'); -- failed：参数不是数组类型
select * from orders where id = any('{1, 2, 3}'); -- pass
-- 测试为空写法
select * from orders where id = any('{}'); -- pass
select * from orders where id = any(ARRAY[]); -- failed
-- 可以和各种运算符结合使用
SELECT 'foo' LIKE ANY('{FOO,bar,%oo%}');
```

### 7.5 group by
```sql
-- 个人推测：当参数能唯一区分的时候，可以不用写完。比如下面两个例子
select part_id,warehouse_id from storages group by part_id order by part_id; -- failed：column "storages.warehouse_id" must appear in the GROUP BY clause or be used in an aggregate function
select id,warehouse_id from storage.stock_sums group by id order by id; -- pass
```

### 7.6 order by
实测发现，order by跟的字段名优先匹配select后面的字段名和alias，（注意如果字段设置了alias，字段原来的名称将不用做匹配(待验证)）如果有字段名和alias相同，则ambiguous，然后才匹配未出现在select的字段名，如果多个表有相同的字段名，则ambiguous。
```sql
select actor_id as first_name, first_name  from actor order by first_name; -- 有字段名和alias相同，所以ambiguous
select actor_id as first_name  from actor order by first_name; -- 此时匹配的是alias的first_ame
select t1.actor_id
from actor t1
	inner join actor t2 on t1.actor_id != t2.actor_id and t1.last_name = t2.last_name and t1.first_name = t2.first_name
order by actor_id; -- 匹配select跟的t1.actor_id，所以不用带上前缀t1
select t1.actor_id as id
from actor t1
	inner join actor t2 on t1.actor_id != t2.actor_id and t1.last_name = t2.last_name and t1.first_name = t2.first_name
order by actor_id; -- 因为actor_id设置了alias为id，原名称actor_id将不用做匹配，所以order by后跟的actor_id匹配不到select中actor_id的，然后就去匹配未出现在select的字段，因为两个表都有该字段，所以ambiguous
select t1.first_name
from actor t1
	inner join actor t2 on t1.actor_id != t2.actor_id and t1.last_name = t2.last_name and t1.first_name = t2.first_name
order by actor_id; -- 匹配未出现在select的字段，因为两个表都有该字段，所以ambiguous
select t1.first_name
from actor t1
	inner join actor t2 on t1.actor_id != t2.actor_id and t1.last_name = t2.last_name and t1.first_name = t2.first_name
order by t1.actor_id; -- 显式指定了t1.actor_id，所以就匹配它
select actor_id as first_name, first_name as actor_id from actor order by first_name; -- 无意中发现的经典例子，由规则可知，匹配的是"actor_id as first_name"这个
```

```sql
-- 上面的alias可能把人绕晕，这个时候可以考虑order by后面直接跟字段的顺序来排序。缺点是意思不够明确，一般不推荐使用。比如下面两个是相等的
select id, customer, total from purchases order by customer, total desc, id; 
select id, customer, total from purchases order by 2,3 desc, 1; 
```

```sql
-- 值为null的字段的排序：升序的时候，null默认被放在最后，降序的时候，null默认被放在最前面
-- 1. nulls first 时，不管升序还是降序，强制null放在最前，nulls last 时，不管升序还是降序，强制null放在最后
-- 2. 可在 ORDER BY 条件中使用 IS NULL和 IS NOT NULL 修饰符，条件为真 true 将比条件为假false 排在前面
SELECT * FROM tab ORDER BY (col IS NOT NULL); -- 含 NULL 的记录排在结果的上面部分
```

```sql
-- 可使用以下方法提取随机的一行记录： 
SELECT  cols FROM tab ORDER BY random() LIMIT 1 ; 

-- 自定义排序：
-- 1. 可以使用join
```

### 7.7 规定要返回的记录的数目
使用`limit ... offset ...`:`limit all`和省略limit一样；`offset 0`和省略offset一样；如果同时出现OFFSET和LIMIT，则在开始计算返回的LIMIT行之前会跳过OFFSET行。OFFSET子句跳过的行仍然在服务器内部计算过，所以大量的OFFSET可能效率低下。（The rows skipped by an OFFSET clause still have to be computed inside the server; therefore a large OFFSET can be inefficient.）
```sql
select * from actor limit all offset 0;
```

## 8 更新

### 8.1 DML的更新
连表更新的写法如下，对于set后紧跟的赋值语句，左边被认为是属于t1的，不能加上t1这个前缀（别名也不能加），但右边不知道属于谁，所以应该加上。
```sql
UPDATE t1 SET xxx = t2.xxx FROM t2 
WHERE t1.xxx = ...
```

多表(三表+)更新怎么写：查看文档结合网上的资料，结论是其他表的连接条件可以写在from关键字后面。比如
```sql
update t1 set a = tmp.a, b = tmp.b 
from (select * from t2 left join t3 on ...) tmp
where tmp.xxx = t1.xxx
```

关于直接使用inner join行不通的原因分析：之前在网上搜update inner join 的语法，有人说语法如下
```sql
update t1 set a = t2_alias.a
from t1 t1_alias inner join t2 t2_alias on ... 
where t1_alias.xxx = t2_alias.xxx
```
但实测发现不行，将t1.a全部更新为一样的，没有对应起来，最后查看文档和资料可以理解到：这里from后面t1使用了别名t1_alias，而update后面的t1还是t1，也就是说没有被认为是同一张表，所以后面的一堆限制条件都跟update后的t1没关系，所以并没有按条件去更新。如果想关联，可以加上`t1.id = t1_alias.id`，如
```sql
update t1 set a = t2_alias.a
from t1 t1_alias inner join t2 t2_alias on ... 
where t1_alias.xxx = t2_alias.xxx
    and t1.id = t1_alias.id
```
但最好的写法还是遵照官方文档。

### 8.2 DDL的更新
```sql
-- 删除字段
ALTER TABLE table_name DROP COLUMN IF EXISTS column_name;
```

## 9 删除 

## 10 UPSERT（insert on conflict do）
它是原子性的upsert操作。

当插入遇到约束错误时，直接返回或者改为执行 UPDATE。

不存在则插入，存在则更新，如`insert into test values (1,'hello digoal',now()) on conflict (id) do update set info=excluded.info,crt_time=excluded.crt_time;`，`excluded`在upsert语句中，表示`values()`括号里面的值。

不存在则插入，存在则直接返回，即不做任何处理，如`insert into test values (1,'hello digoal',now()) on conflict (id) do nothing;`

不跟`conflict_target`条件的`on conflict`和普通`insert into`的区别：
`on conflict`后的`conflict_target`条件可以为空（写成`on conflict`而不是`on conflict()`），如果插入成功，和普通的insert效果一样；如果数据不满足表的任何约束，都会触发后面的`do nothing`（不能是do update，语法不支持）和`returning`（返回空行）而不是返回错误，而普通的insert此时会返回错误，利用这个可以在插入时判断数据是否存在。
```sql
INSERT INTO parts(xxx...) VALUES (xxx...) ON CONFLICT do nothing returning id; -- 成功插入会返回id，没有插入不返回
```

`conflict_target`必须是unique or exclusion constraint(排它约束)
```sql
-- 比如表t上project_id 只建了普通索引
inser into t(...) values (...) ON CONFLICT(project_id) DO NOTHING; -- 报错：there is no unique or exclusion constraint matching the ON CONFLICT specification
```

有多个唯一约束时，以`conflict_target`条件为准：比如有a、b两个约束，如果`conflict_target`是a，当a冲突时，即使values后面有b的值且不和b冲突，也不会更新b，而是去执行后面的update或者nothing（当然，如果这里的update有更新b的操作，那么会更新b，但不是因为values后面的b）；如果a没冲突，但b冲突了，返回错误。

## 11 操作后的返回值
可以使用`returning xxx as yyy`返回受影响的数据

## 12 流程控制
### 12.1 case when then 
语法形如
```sql
CASE WHEN condition THEN result
        [WHEN condition THEN result ...]
        [ELSE result]
END
```
condition为bool，如果都为true则返回后面的result，如果都为false，则返回ELSE后的result，如果都为false且没有ELSE，则返回null。



### 12.2 流程控制、条件表达式


#### for循环
```sql
declare 
punm number:=1;
begin
for pnum in 1..10 loop
dbms_output.put_line(pnum);
end loop;
end;  
```

### 12.3 COALESCE(value [,...]) 
`COALESCE()`：返回参数中第一个非null的值，要求参数中至少有一个是非null的，否则报错。还要注意里面的表达式也必须是正确的，否则会报错。
```sql
select COALESCE(null,null);  -- 报错
select COALESCE(null,null,'',now()); -- 报错，不能null 乘以 null ，但是如果字段a和字段b的值都为空，可以字段a * 字段b，如下
select COALESCE(a * b, '', now()); -- 不报错。如果该行存在但a、b没有值，则返回''；如果该行不存在，则什么都不会返回

-- 表达式必须是正确的。假如b为0
select COALESCE(a / b, '', now()); -- 报错：division by zero
-- 此时可以用
-- 1. NULLIF来解决这个问题
select COALESCE(a / NULLIF(b, 0)), '', now()); -- pass, a / null 等于 null
-- 2. CASE WHEN来解决这个问题

-- 其他
select COALESCE(null,null,now(),''); -- 结果会得到当前的时间
select COALESCE(null,null,'',now()); -- 结果会得到''
```

### 12.4 NULLIF(value1, value2) 
`NULLIF(value1,value2)`：当value1和value2相等时，NULLIF返回一个空值。 否则它返回value1。

## 13 注释
分两种：添加注释和查询注释

添加注释语法:
1. 给字段添加注释：`comment on column tb.column_name is 'The user ID'`
2. 给表添加注释`comment on tb_name ....`

查询注释:
1. 查询字段上的注释`\d+ tb_name`，不会显示表上的注释
2. 查询表上的注释
    1. `SELECT obj_description('schemaName.tableName'::regclass, 'pg_class')`
    2. `SELECT obj_description(oid) FROM pg_class WHERE relkind = 'r'`

# 四 高级
## 1 psql

### 1.1 元命令/斜杠命令/终端命令
启动psql的时候可以带上`-E`参数，这样它将打印出你在psql中所给出的命令执行时的内部实际使用的SQL查询语句。

常用元命令:
1. 查看连接信息：`\conninfo`
1. 列出该数据库所有table：`\d`(待确认)，所有非sequence table：`\dt`，所有sequence table：`\ds`
3. 切换数据库、用户：切换数据库`\c database_name`,切换用户`\c user_name`
5. 打开执行计时，非常有用:`\timing`
6. 执行shell命令：`\! shell_command`
7. 每SEC秒执行查询，默认2s:`\watch SEC`,e.g.,`select * from orders;\watch 1`
8. 切换对齐与否：`\a`
9. 显示所有全文搜索的配置：`\dF` 
10. 显示已安装的扩展插件：`\dx`
11. 显示所有用户`\du`
11. 横纵显示切换（Expanded display）：`\x`，设为auto的话会自动选择合适的显示方式。
12. `-f`执行文件
13. `-d`指定数据库

## 2 索引
参考：
1. https://yq.aliyun.com/articles/111793

索引分类：
1. 按概念分类：唯一索引、联合索引(复合索引、组合索引)、函数索引


创建索引：specify postgreSQL index type while creating a new index on a table：`CREATE INDEX index_name ON table_name USING index_type (column);`,e.g.,`CREATE INDEX test_index ON numbers using hash (num)`。建索引时会锁住（exclusive lock）整张表，数据量大时会很久，可以改用`CREATE INDEX CONCURRENTLY`保证表不会被lock，不过会花费更多时间。索引的命名空间应该是schema，同一个schema下不能出现同名的索引。
2. 联合索引
    
    ```sql
    ```
3. 函数索引

    ```sql
    -- 对时间建立索引：如果过滤的时候只会用到日期的一部分，对整个时间建立的索引就不会生效，需要对时间的一部分建立索引，如
    create index on t (date_trunc('month', time_column_a::timestamp )); -- 相当于对date_trunc('month', time_column_a::timestamp )建立索引，用的时候也要写成这样才会生效
    ``` 

维护索引：删除数据的时候，会打上删除标记而不是立刻删除，所以，索引大小还是没变。可以重建索引`REINDEX INDEX xxx;`，不过该操作也会锁表，所以可以建一个新的索引b，然后把原来的a索引删除。

主键、unique约束、普通索引（index）和唯一索引（unique index）：主键的字段不能包含空值；pg中unique约束是用btree索引实现的，似乎除了写法上的一点儿不同（unique约束写在创建表的时候；唯一索引写在创建表后，可以带条件），其他和唯一索引作用一样；普通索引可以重复，可以为空。删除索引和约束的语法不一样。

1. unique约束：比如`create table ... unique(field1, field2), field3`，约束中的字段至少有一个不为空，约束中的字段不能重复。
2. unique index：比如`create unique index if not exists brands_mj_name_key on brands (mj_name) where mj_name != ''`，会对所有mj_name不为空的行创建唯一索引，为空的就不创建。
3. 普通索引：字段可以重复。

    ```sql
    create index if not exists age_index on person (age);
    ```
    
删除索引：如果在非public的schema中，需要带上schema，这点官方文档上没说，有点坑。

    ```sql
    drop index if exists sales.order_details_index; -- 删除schema为sales下，名称为order_details_index的索引
    ```


### 2.1 gin
gin只存储tsvector值的lexeme，而不存储权重。

gin天生就适合做多字段索引，不管查询条件覆盖所有索引字段还是仅仅覆盖一个子集，它都可以胜任。一个多字段的 GIN 索引可以用于那些查询条件包含索引字段子集的查询中。 不像B-tree 或 GiST，除了查询条件使用的索引字段外，索引的搜索效率是相同的。

### 2.2 GiST（Generalized Search Tree）

### 2.N 各索引的对比


## 3 transactions
使用BEGIN、COMMIT、ROLLBACK

## 4 execution plan/query plan
参考：
1. https://www.postgresql.org/docs/9.1/sql-explain.html

查看执行计划：`EXPLAIN query_sql`，分析sql但不会真正执行sql

通过执行sql来显式执行计划：`EXPLAIN ANALYZE query_sql`，会真实执行，所以可能比上面耗时更久，但更准确，推荐使用该选项。
1. `analyze`使用随机抽样来估计数据统计（uses random sampling to estimate data statistics）

扫描：分全表扫描（seq scans，也称为顺序扫描sequential scans）、索引扫描（index scans）、位图扫描（bitmap index scans）和ctid扫描（tid scan）。要使用tid进行快速的行扫描，必须开启参数enable_tidscan。一般尽量避免使用全表扫描，在数据量大时会很很慢。

什么时候更适合全表扫描：返回数据量很大时，比如100万条，查询结果有90万条，那么走全表就是最好的。


关闭全表扫描：`set enable_seqscan = off;`

## 5 函数和存储过程
### 5.1 函数
例子`raise notice 'this is raise demo , param1 is % ,param2 is %',param1,param2;`，raise用于打印输出，后面的百分号就是占位符，不用考虑值的类型。notice是级别，可以为debug/log/info/notice/warning/exception，这些级别的信息是直接写到服务端日志还是返回到客户端或是二者皆有，是由log_min_messages和client_min_messages两个参数控制，这两个参数在数据库初始化时用到（？）

`$$`：从`begin`到`end`表示函数主体代码的开始和结束，需要用单引号包裹，为了防止主体代码里面已经存在单引号导致冲突，pg支持用`$$`替代单引号。

### 5.2 常用函数
1. `generate_series(start, stop, step, interval)`：生成多行数据。
    
    ```sql
    SELECT * FROM generate_series(2,4);
    SELECT generate_series(1.1, 4, 1.3);
    SELECT * FROM generate_series('2008-03-01 00:00'::timestamp, '2008-03-04 12:00', '10 hours');
    select generate_series('1920-01-01 00:00:00'::timestamp, '2020-01-01 00:00:00', '5 minutes');
    ```
2. `COALESCE(args1,args2...)`:类似于oracle的`NVL()`和mysql的`IFNULL`

## 6 聚合/聚集函数和窗口函数
参考：https://time-track.cn/postgresql-window-function.html

### 6.1 Aggregate Function(聚合函数)

### 6.2 Window Functions(窗口函数)
什么是窗口函数：官网介绍它可以实现和聚合函数一样的功能，但它不会像常规聚合函数那样将结果分组到某些行上，而是每行都会有结果(简单说就是聚合函数返回各个分组的结果，而窗口函数则为每一行返回结果)。它是OLAP functionality，提供了ranking, cumulative computation, and partitioning aggregation.

为什么需要窗口函数：(待补充)
1. 用聚合也可以实现，但是写起来很累赘

窗口函数：在oracle中称为分析函数。窗口函数不会像聚合一样将参与计算的行合并成一行输出，而是将计算出来的结果带回到了计算行上。语法形如`聚合函数(sum，min，avg……) + OVER (partition by xxx order by xxx)`

```sql
-- 语法
-- 1. OVER后面紧跟的括号及括号中的内容称为window frame
--  a. window frame 里面为空则是对每一行生效
select *, sum(amount) OVER() from xxx; 
--  b. window frame中的partition by用于窗口函数的分组
--  c. window frame如果带了order by，则会从分组的起始值开始一直叠加，直到当前值为止，当忽略order by 参数则会计算分组中所有值的和。所以ORDER BY一般跟一些特殊的聚合函数使用才有意义，比如rank()、row_number()
SELECT *, 
    avg("score") OVER (PARTITION BY "subject") as "subject_avg_score",
            rank() OVER (PARTITION BY "subject" ORDER BY "score" DESC) as "subject_rank_score" 
FROM "testScore"  ;

-- 2. 每一个聚合函数都需要对应一个OVER()。比如同时求总和和平均，要用到sum()和avg()，这是两个聚合函数，所以需要两个OVER()
select case when qty <>0 then sum(price) else avg(taxed_purchase_price) end as price
from xxx where ... group by ...; --pass，聚合函数可以这样写
select case when qty <>0 then sum(price) else avg(taxed_purchase_price) end OVER() as price
from xxx where ... group by ...; --failed, 因为语法不支持，每一个聚合函数都需要一个OVER()
select case when qty <>0 then sum(price) OVER () else avg(taxed_purchase_price) OVER() end as price
from xxx where ...; -- pass, 窗口函数这样写正确
select case when qty <>0 then sum(price) / sum(qty) OVER () else avg(taxed_purchase_price) OVER() end as price
from xxx where ...; -- failed, 这样写也不行
select case when qty <>0 then sum(price) OVER () / sum(qty) OVER() else avg(taxed_purchase_price) OVER() end as price
from xxx where ...; -- pass, 窗口函数这样写正确

-- 3. 当一个查询涉及多个窗口函数的时候，可以用别名的办法来使用，更简洁。语法是有where条件放在其后面，否则放在表名后面
select sum(salary)over w, avg(salary) over w, * from empsalary 
where age > 20 window w as (partition by depname order by salary desc);
```

常用函数，都可以结合window frame的`order by`使用(待实践):
1. `row_number()`: 从当前开始，不间断,如1，2，3，4，5，6。适合单纯做序号，做排名的时候不会出现多个人并列的情况
2. `rank()`:从当前开始，会间断，如1，2，2，4，5，6。它适合用来做排名的功能，它是若两人并列第一，那第三个人就排名第三
3. `dense_rank()`:从当前开始不间断，但会重复，如1，2，2，3，4，5。做排名的时候，若两人并列第一，那第三个人紧随其后排名第二
4. `percent_rank()`:从当前开始，计算在分组中的比例，如0，0.25，0.25，0.75，1，0，1 从0-1不断地循环
5. `cume_dist()`：当前行的排序除以分组的数量,如分组有4行，则值为0.25，0.5，0.75，1
6. `ntile(num_buckets integer)`：从1到当前值，除以分组的的数量，尽可能使分布平均
7. `lag(value any [, offset integer [, default any ]])`：偏移量函数，取滞后值,如`lag(column_name,2,0)`表示字段偏移量为2，没有则用default值代替，这里是0，不写默认是null
8. `lead(value any [, offset integer [, default any ]])`：偏移量函数，取提前值,类上
9. `first_value(value any)`、`last_value(value any)`：返回窗口框架中的第一个值、最后一个值
10. `nth_value(value any, nth integer)`：返回窗口框架中的指定值，如nth_value(salary,2),则表示返回字段salary的第二个窗口函数值


## 7 视图
什么场景适合用视图：
1. 频繁的子查询
2. 给外部提供数据时，避免暴露表结构

## 8 数据备份和恢复
### 8.1 使用COPY TO和COPY FROM导入导出


#### CSV文件
可以直接跟表名，也可以跟查询语句
1. 导出：psql里执行`COPY (select * from my_tab order by id) to 'D:/server_exp_dir/file_name.csv' with csv header;`，路径只能使用绝对路径，需要权限
2. 导入：psql里执行`COPY table_name(xxx) from '/u02/tank/123456.csv' with csv header;`
3. 将远程的数据从标准输出流导出到本地文件中:`psql -h 192.168.xxx.xxx -p 21770 -d db_name -U readonly -c "COPY (select * from table_name where company_id = 518 order by id) TO STDOUT with csv header" > /home/qa2/tmp/ruipai_back/company_stocks_back.csv`，只读权限也可操作
4. 将本地文件中的数据导入到远程数据库中:`psql -h localhost -p 21770 -d db_name -U pgdata -c  "COPY table_name(xxx) from STDIN with csv header" < /home/prod/tmp/back_up/xxx.csv`

#### Text文件
导入导出text文件时，默认的字段分隔符是用的制表符，`\N`表示值为`null`。特殊字符前面需要加上反斜杠`\`转义。比如要想真正插入字符串的`\N`需要写成`\\N`。感觉对格式要求比较严格，恢复的时候稍微改错就会失败。

```sql
-- 比如有staffs表，字段为(staff_id bigint, account_set_id bigint, department_id bigint, user_defined_roles bigint[], builtin_roles text[], created_by bigint, created_at timestamp with time zone, updated_by bigint, updated_at timestamp with time zone)，那么导出文本格式的时候数据如下：

219	16	44	{45}	{purchasesMan}	159	2019-02-12 18:42:21.357137+08	0	\N
197	14	37	{}	{purchasesMan,salesMan}	159	2019-02-12 18:42:21.357137+08	0	\N
```

### 8.2 使用pg_dump导入导出数据库
参考：https://www.postgresql.org/docs/9.6/static/app-pgdump.html

该操作需要角色具有转储权限，如果没有那么需要切换角色或者修改权限。

导出格式包括文本格式：`.sql`和非文本格式`.tar`、`.dump`，如果是非文本格式，需要配合`pg_restore`恢复

导出单个数据库or数据库里的单个表：`pg_dump -h 127.0.0.1 -p 7002 <-t tabel_name> db_name > xxx.sql`
恢复到db（需要先创建db）：`psql -h 127.0.0.1 -p 7002 db_name < xxx.sql`

常用参数(待补充):
1. `-s`(`--schema-only`):只转储结构, 不包括数据
2. `-t`(`--table=TABLE`):只转储指定名称的表
3. `--column-inserts`:以带有列名的INSERT命令形式转储数据

## 9 事务
参考：
1. http://www.postgres.cn/docs/10/transaction-iso.html

ACID

PostgreSQL中支撑ACID的主要是MVCC和WAL两项技术。（原理？）

事务的控制：
1. 开启事务：`BEGIN` or `BEGIN TRANSACTION`
2. 提交事务：`COMMIT`or `END TRANSACTION`
3. 回滚：`ROLLBACK`

```sql
-- pg的DDL语句也实现了事务
begin;
create table t1...
rollback;
\d t1 -- failed:找不到t1
```


SQL标准有4种隔离机制/级别：
- Read Uncommitted（未提交的读取）
- Read Committed（提交的读取）：pgsql默认
- Repeatable Read（可重复读）：mysql默认
- Serializable（可串行化）

表格：待补充

pgsql只实现了2和4

隔离级别命令：
1. 查看当前隔离级别：`show transaction_isolation;`
2. 设置隔离级别：`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE`

### 9.2 Read Committed
在该级别，每个语句看到的是该语句执行前所有已经committed数据的快照，如果不加"begin....commit/rollback"，每一个SQL语句都是一个transaction，都有自己的transaction ID。

### 9.3 Repeatable Read
在这个级别，每个语句看到的是该事务执行前所有已经committed数据的快照。（所以在这个隔离级别，同一个transaction中多次执行同一个select语句会得到相同的结果。）


## 10 并发控制和锁
参考：https://www.cnblogs.com/biterror/p/7161631.html?utm_source=itganhuo&utm_medium=referral

Postgres有3种锁机制：
1. 表级锁
2. row-level locking(行级锁)
3. 页级锁（页级共享/排他锁）：用于控制对共享缓存池里表页的访问。在一行数据被读取或者更新后，这些锁会立即被释放。应用程序开发者通常不需要关注页级的锁。

PostgreSQL采用MVCC的方式进行并发控制，每个事务看到的是一段时间前的数据快照。同时，MVCC并不能够解决所有问题，所以也提供了行级和表级的锁。pg设计锁等待时，以队列方式存储等待锁。

`deadlock_timeout`：在等待一个lock被释放的时间里，多久可以启动deadlock检查机制，默认是1s。查看`show deadlock_timeout`

`lock_timeout`：单位是毫秒，设为0表示无线等待，默认为0。

`statement_timeout`

### 10.1 共享锁/读锁（Shared lock）
表锁的命令形如：`lock table_name ...`

表共享锁：`select`(?)

行共享锁`select ... for update/for share`：无论where有没有触发到索引，都是行级锁。
1. 使用`select ... for update`，数据被锁住时，对数据进行修改操作，会等待，如果设置了`lock_timeout`（非0），超时时会出现“canceling statement due to user request”
2. 使用`select for update nowait`，数据被锁住时，对数据进行修改操作，会报数据库错误
3. `select for update skip locked`，跳过已被锁的数据

注意：
1. 连表查询加锁时，不支持单边连接（left jon等）

### 10.2 排他锁
表排他锁：`drop`(?)

行排他锁：`delete`

### 10.3 死锁
对于事务级别提交读来讲：新增的rows是不会出现死锁的

## 11 主从实现
### 11.1 基于Standby的异步流复制（Streaming Replication）
参考：https://blog.csdn.net/wlwlwlwl015/article/details/53287855

pg的主从分别称为primary和standby，也可以称为master和slave。

## 12 extension
查看已安装extension：`\dx`or`SELECT * FROM pg_extension`。对扩展的操作(create、alter、drop)必须是超级用户(supperuser)

可以说extensions是pg和其他关系型数据库最大的不同

使用：
1. 安装扩展，如`CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`

### 12.1 自带扩展
#### dblink
它可以实现在一个数据库中远程操作另外一个数据库，是实现跨库的一种方法

### 12.2 其他常用扩展
#### pgbench
参考：https://www.postgresql.org/docs/10/pgbench.html
pgbench is a simple program for running benchmark tests on PostgreSQL。内置，可用来生成可扩展的数据。

典型的pgbench输出如下：
```bash
transactiontype: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
# 已经完成的事务和预计应该执行的事务个数。这两个数值应该是相等的，如果不相等说明存在执行失败的情况（如果指定为-T模式，则只打印实际完成的事务数量）。
number of transactions actually processed: 10000/10000 
# 最后两行显示的是每秒完成的事务数量（包含连接建立时间和不包含连接建立时间分别计算出的平均值）。
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
```

参数：
1. `-i [optios] dbNameA`:该命令会创建四个表（pgbench_accounts, pgbench_branches, pgbench_history, 和pgbench_tellers），创建这几个表会执行对应表的删除动作。执行前应确认对应数据库中是否已经有这些表，是否会误删除。四个表的默认初始化行数如下
    1. pgbench_branches       1
    2. pgbench_tellers            10
    3. pgbench_accounts       100000
    4. pgbench_history           0
1. `-s`(`--scale`):即比例因子，该参数来增加初始化时各表的行数。
3. `-c`客户端数量
4. `-t`事务数量`
5. `-T`时间限制
6. `-f`定制脚本
7. `-j`使用的核心数，可以理解为并发数
8. `-c`客户端数，必须是核心数的整数倍

#### pg_trgm
TRGM是一个非常强的插件，用来做相似度匹配，提供快速搜索相似字符串的索引操作符类等，对这类文本搜索场景性能提升非常有效，100万左右的数据量，性能提升有500倍以上。

创建gin类型的trgm索引：`create index t1_f1_gist_idx on t1 using gin(f1 gist_trgm_ops)`

#### 中文分词:zhparser
github：https://github.com/amutu/zhparser

1. 安装SCWS，比如安装在~/opt目录
2. 下载zhparser源码
3. 编译和安装zhparser
4. 创建extension

#### PostGIS

#### fdw系列
可以从任意的数据库上读取数据，目前读取ORACLE, SQL SERVER , MYSQL, MONGODB 等等都不是问题

#### 12.5.1 cstore_fdw
它可以智能地将数据和查询分布在多个节点上，这样就可以扩展数据库并提高查询速度

## 13 全文检索/全文搜索（Full Text Search）
参考：
1. http://www.cnblogs.com/zhenbianshu/p/7795247.html
   

对于文本搜索目的，每一个文档必须被缩减成预处理后的tsvector格式。搜索和排名被整个在一个文档的tsvector表示上执行 — 只有当文档被选择来显示给用户时才需要检索原始文本。我们因此经常把tsvector说成是文档，但是当然它只是完整文档的一种紧凑表示。文档是全文搜索系统中的搜索单元。比如，一篇杂质文章或是一封邮件消息。这里的文档可以跨多个表，代表为我们想要搜索的逻辑实体。

Psql 提供两个数据类型tsvector，tsquery。
1. `tsvector`：是唯一分词的分类列表，把一话一句词格式化为不同的词条，在进行分词处理的时候，tsvector会自动去掉分词中重复的词条，按照一定的顺序装入。参考：

2. `tsquery`：相当于是查询tsvector的查询条件，并且可以联合使用boolean 操作符来连接, & (AND), | (OR), and ! (NOT). 使用括号(),可以强制分为一组
在全文检索的过程中，tsquery与tsvector之间采用@@操作符


`::tsvector`：不执行normalized
`to_tsvector('english', 'The Fat Rats')`：执行normalized，Postgres中to_tesvetor的默认配置的文本搜索是“英语“。它会忽略掉英语中的停用词（stopword，译注：也就是am is are a an等单词)。

`::tsquery`：不执行normalized
`to_tsquery('Fat:ab & Cats')`：执行normalized

lexeme：执行normalized后的各个单词。

`@@`操作符：用来对tsvector搜索。

### 13.1 配置
文本搜索的默认配置是`default_text_search_config(string)`

查看文本搜索的所有配置：`\dF`，查看文本搜索解析器`\dFp`

以zhparser为例：
添加一个以zhparser作为解析器的全文检索配置:`create text search configuration zhcfg (PARSER = zhparser);`

查看zhparser的所有token：`select ts_token_type('zhparser');`

一般情况下，我们只需要按照名词(n)，动词(v)，形容词(a)，成语(i),叹词(e)和习用语(l)6种方式对句子进行划分就可以了，词典使用的是内置的simple词典，即仅做小写转换。所以添加映射：`alter text search configuration zhcfg add mapping for n,v,a,i,e,l with simple;`

查看是否配置成功：`select to_tsvector('chinese', '这周日你有空么');`，输出`'么':2 '有空':1`

### 13.2 创建索引
gist和gin索引都能提高全文检索的速度，如果用gin索引，则字段类型必需是tsvector

## 14 schema
默认是public，列出db里所有schema：
1. `\dn`
2. `select schema_name from information_schema.schemata`

列出schema下面的表格：
1. `\dt schema_name.*`，注意如果是`\d schema_name.*`的话会列出详细信息。
2. `SELECT * FROM information_schema.tables WHERE table_schema = 'public'`or`select * from pg_tables where schemaname='public';`

# 六 问题
## 1 解决
### 1.1 时间和时间戳的转换（待补充）
```sql
--日期转时间戳
SELECT EXTRACT(epoch FROM NOW());
SELECT EXTRACT(epoch FROM CAST('2017-12-06 00:17:10' AS TIMESTAMP));
SELECT EXTRACT(epoch FROM '2017-12-06 00:17:10'::TIMESTAMPTZ);

--时间戳转日期
SELECT TO_TIMESTAMP(1512490630)
```

### 1.2 行列转换
列->行：
1. `string_agg()`
2. `array_agg()`

行->列：
1. `regexp_split_to_table()`

### 1.3 报错：pq: column "field_name" of relation "schema.table_name" does not exist
出现原因：更新表结构时，原来的表还存在。

### 1.4 pq: column "field_name" does not exist
1. 字段不存在
2. 字段存在，但是自己输入的字段名没有加上单引号

### 1.5 插入
1. 当指定的表column数目小于插入的columns of values 时，报错：`ERROR:  INSERT has more expressions than target columns`
2. 当指定的表column数目大于插入的columns of values 时，报错：`ERROR:  INSERT has more target columns than expressions`
3. 当指定的表column类型与实际插入数据（子语句）类型不符，报错：`ERROR:  column "id1" is of type integer but expression is of type character varying`


### 1.6 pg： numeric field overflow 
原因：插入的数值精度比定义的大；修改数值字段类型到更小的类型时，存在会丢失精度的数据

### 1.7 ERROR:  canceling statement due to user request CONTEXT:  while updating tuple (100,31) in relation "xxx"
可能原因：
1. 客户端设置了查询超时
2. 死锁

查看死锁及解决方法：
```sql
SELECT * FROM pg_stat_activity WHERE datname='db_name';
```

其中`state`字段的值有：
1. `active`:当前用户正在执行查询、表结构更改等操作
2. `idle`：表示当前用户空闲。用另一个客户端再登入一个用户先
3. `idle in transaction`:表示当前用户在事务中
4. `idle in transaction (aborted)`:表示当前用户在事务中，但是已经发生错误。注意这时候如果另外有人对带锁的数据进行相关操作，可能导致死锁。

根据pid，kill掉死锁的进程：
```sql
SELECT pg_cancel_backend(PID); -- 只能kill select查询，对update、delete 及DML不生效
SELECT pg_terminate_backend(PID); -- 可以kill掉各种操作(select、update、delete、drop等)操作
```

### 1.8 创建数据库报错：ERROR：new collation (zh_CN.UTF-8) is incompatible with the collation of the template database (en_US.UTF-8)，HINT：Use the same collation as in the template database, or use template0 as temp
参考：https://yq.aliyun.com/articles/43395

使用`create database xxx_test with template template0 lc_collate "zh_CN.UTF-8" lc_ctype "zh_CN.UTF-8" encoding 'UTF8';`创建成功

### 1.9 there is no unique or exclusion constraint matching the ON CONFLICT specification
可能原因：
1. `on conflict()`里的约束条件写错了
2. 表没有约束条件

### 1.10 删除索引或约束

#### cannot drop index xxx because requires it. You can drop constraint ... 
因为xxx既是index又是constraint，需要这样来修改`alter table xxx drop constraint if exists xxx;`

### 1.11 数据库无法启动
执行`pg_ctl -D /usr/local/var/postgres start`出现下面的文字：
```
pg_ctl: another server might be running; trying to start server anyway
waiting for server to start....2019-05-20 00:25:34.336 CST [2723] FATAL:  database files are incompatible with server
2019-05-20 00:25:34.336 CST [2723] DETAIL:  The data directory was initialized by PostgreSQL version 10, which is not compatible with this version 11.2.
 stopped waiting
pg_ctl: could not start server
Examine the log output.
```

执行`psql -h localhost -U develop dvdrental`则出现：
```
psql: could not connect to server: No such file or directory
	Is the server running locally and accepting
	connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
```

可知数据库服务未启动，最后发现是之前安装过Postgresql 10版本，第二次又安装了Postgresql 11.2版本，会导致最后的时候数据库无法启动并报错。

解决办法:
1. 方法一：`brew postgresql-upgrade-database`
1. 方法二
    1. uninstall之后再重新安装最新版。
    2. 此时启动服务还是用的旧版，执行`initdb /usr/local/var/postgres`，如果出现
        ```
        initdb: directory "/usr/local/var/postgres" exists but is not empty
        If you want to create a new database system, either remove or empty
        the directory "/usr/local/var/postgres" or run initdb"
        ```
        
        删除`/usr/local/var/postgres`后再执行`initdb /usr/local/var/postgres`
        
    3. 重启服务，done

### 1.12 can not affect row a second time

### 1.13 for SELECT DISTINCT, ORDER BY expressions must appear in select list
distinct自带排序功能，会先按照distinct后面的字段进行排序，而order by是可以改变distinct自带的排序，所以原因其实就是一个执行先后顺序问题，没有distinct时，order by先执行，select后执行，有了distinct，selcet distinct先执行，order by后执行，如果select distinct执行完后，去除了相应字段，所以order by就没法排序了。

### 1.14 pg: tuple concurrently updated
出现场景：项目用了pgcache，然后执行go test以多线程的方式同时更新同一个表

解决办法是用单线程跑测试用例。

### 1.15 missing FROM-clause entry for table "xxx"
可能原因：form后面没有正确的跟表名

### 1.16 Peer authentication failed for user "postgres"
参考：https://stackoverflow.com/questions/18664074/getting-error-peer-authentication-failed-for-user-postgres-when-trying-to-ge

CentOS安装pg后使用`psql -U postgres`登录出现这个错误，它有两种认证方式，对应的几种解决办法：
1. 切换到系统的postgres用户`su postgres`再登录
2. 如果使用的用户有密码，则修改配置`pg_hba.conf`(比如`/var/lib/pgsql/12/data/pg_hba.conf`)，将`local all postgres peer`改为`local all postgres md5`,然后重启服务，使用密码登录
2. 如果使用的用户没有密码，则修改配置`pg_hba.conf`(比如`/var/lib/pgsql/12/data/pg_hba.conf`)，将`local all postgres peer`改为`local all postgres trust`,然后重启服务，使用无密码的账户登录

### 1.17 password authentication failed for user "postgres"

## 2 未解决
1. 数值型有哪几种，取值范围，默认的是哪种

# 七 待整理
## 1 待笔记
2. upsert语句中returning的返回包括insert和update
3. pgsql自带的表是堆表。

## 2 未整理
1. PostgreSQL的扩展和标准有什么区别
2. 标准sql中用户额角色的区别
4. primary 和uniq等
5. 几种分页方法
6. 和mysql等的区别
7. https://yq.aliyun.com/groups/29
9. 聚合查询so hard？
11. 函数式索引
    1. 对jsonb的索引

12. text才能转jsonb？
15. 待研究
    1. 可以在upsert的更新中连接其他表吗
17. https://blog.csdn.net/sunbocong/article/details/79097713
20. anyelement是任意类型？
    1. numbric和int的区别
    2. numbric和float的区别

22. begin，set，commit
23. 堆表和索引组织表的区别，聚集索引表？
24. 函数索引和联合索引
25. 数据库垃圾清理(vacuumdb/reindexdb)会锁表
26. SSL is not enabled on the server
    1. https://www.postgresql.org/docs/9.4/libpq-ssl.html