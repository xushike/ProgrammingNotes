# 2.1.WebAPIs

# 一 概述

## 1 简介
Web APIs是Web应用程序接口,由w3c制定.有以下三类:
1. Web API接口
    包括DOM,window,event等等.

    mdn上说的是,文档对象模型(DOM)核心是由W3C进行标准化的，它将HTML和XML文档抽象成对象，并在其上定义接口以及操纵这些对象的机制，这些定义都是与编程语言无关的.个人的理解是,js引擎(比如V8)实现了w3c定义的这些接口,然后浏览器通过接口创建宿主对象(比如button?)将DOM反射到js中,在js中就可以操作这些宿主对象
2. WebAPI
    WebAPI指一组设备兼容套件和访问接口，它允许Web应用及其内容访问设备硬件（比如电池状态或设备振动器），同时也可以获取设备上的数据（比如日历或联系人等信息）
3. 事件接口

# 三 基础
## 1 Web API接口
#### 1.1 WorkerGlobalScope
它是专门用于Web Workers的特殊js运行时环境(可以简单理解为Web Workers的全局对象),它无法访问window相关的DOM API,拥有一些核心js对象如JSON,navigator等,拥有自己的event loop.我们不会直接访问它.它的属性和方法由更具体的全局范围(global scopes)继承，如DedicatedWorkerGlobalScope和SharedWorkerGlobalScope等.

常用属性和方法:
1. `self`:返回WorkerGlobalScope对象的引用.
2. `location`:返回关联的 WorkerLocation 对象
3. `close()`:关闭当前线程
4. `importScripts()`:通过url在worker中加载脚本文件
5. `XMLHttpRequest`
6. `setTimeout/setInterval以及addEventListener/postMessage`等



#### 1.2 window
window 对象表示一个包含DOM文档的窗口(可以简单理解为当前标签的全局对象)，其 document 属性指向窗口中载入的 DOM文档.

在标签浏览器（比如Firefox）中，每个标签具有自己的 window 对象（如果你在开发扩展，浏览器窗口也是一个独立的 window）。也就是说，同一个窗口的标签之间不会共享一个 window 对象。有一些方法，如 window.resizeTo 和 window.resizeBy 之类的方法会作用于整个窗口而不是 window 对象所属的那个标签。一般而言，如果无法恰当地作用于标签，则会将其作用于窗口


常用属性和方法:
1. `stop()`:停止加载
2. 弹出dialog
    1. `confirm()`:警告对话框,默认只有确认按钮
    2. `alert()`:确认对话框,有确认和取消按钮,点击确认返回true,点击取消返回false
    3. `prompt()`:提示对话框,不仅有确认和取消按钮,还有可输入的文本框

获取window的尺寸(浏览器窗口的尺寸不包括工具栏和滚动条),有三种方法可以获取:
1. 对于IE9和其他大部分browser:
    - window.innerHeight - 浏览器窗口的内部高度
    - window.innerWidth - 浏览器窗口的内部宽度
2. 对于Internet Explorer 8、7、6、5：
    - document.documentElement.clientHeight
    - document.documentElement.clientWidth
3. 其他:
    - document.body.clientHeight
    - document.body.clientWidth
4. 所以最佳实践如下

    ```javascript
    var w=window.innerWidth
    || document.documentElement.clientWidth
    || document.body.clientWidth;
    ```

常用对象有:console,crypto,document,history

##### 1.2.1 console
##### 1.2.2 crypto
此对象允许网页访问某些加密相关服务

属性和方法:
1. `getRandomValues(typedArray)`:获取符合密码学要求的安全的随机值,传入参数的类型化数组被随机值填充（在加密意义上的随机）

##### 1.2.3 document

属性:

方法:
1. `querySelector()`:
2. `getElementsByTagName("xxx")`

##### 1.2.4 history

## 2 WebAPI
## 3 事件接口
### 3.1 什么是事件
目前,所有js的执行环境都使用事件和事件处理.(事件是js的核心)

事件的完整流程:
1. 首先需要一个**事件目标**,比如button.

2. 创建自定义事件(如果使用浏览器本身触发的事件则不需要此步).也成为合成事件(synthetic events).现代浏览器基本都支持下面两种构造方法:
    1. 使用event的构造函数,形如`var event = new Event('eventType')`
    2. 使用`CustomEvent()`,形如`event = new CustomEvent('eventType', customEventInit)`,其中eventType是自定义的事件名称,customEventInit对象是可选的.注意该方法也可以在Web Worker中使用.
        1. customEventInit的三个参数如下:
            1. detail:一般用来传递一些数据
            2. bubbles:是否冒泡
            3. cancelable:是否可以取消事件的默认行为

    3. 例子如下,

        ```
        let event = new CustomEvent("newMessage", {
            detail: {
            message: msg,
            time: new Date(),
            },
            bubbles: true,
            cancelable: true
        });

        element.addEventListener('newMessage', function (e) { ... }, false);
        element.dispatchEvent(event)
        ```

3. 注册(三种方法).给事件目标**注册事件监听器**:
    1. `addEventListener`:如`myButton.addEventListener('click', function(){alert('Hello world');}, false);`.然后可以通过`removeEventListener('click', func)`移除监听器,这两个方法在大型或者复杂的项目中比较有用.注意ie6-8不支持该方法.
        1. 该方法可以给同一个监听器注册多个处理器,而且不会互相覆盖.如,
            
            ```
            myElement.addEventListener('click', functionA);
            myElement.addEventListener('click', functionB);
            ```
    2. html属性:形如`<button onclick="alert('Hello world!')">`,属性中的js代码可以通过event参数传入 Event 对象.

        mdn官网说的是:"我们应该避免使用这种方式。因为它会使标记数量变大，而可读性却较差。 混用 HTML 和 JavaScript导致内容/结构 和 行为之间没有很好的分离，使得在处理bug时非常困难,文档也很难解析——最好的办法是只在一块地方写 JavaScript 代码,将您的编程逻辑与内容分离也会使您的站点对搜索引擎更加友好",比如有100个按钮,推荐的做法如下,
        
        ```
        var buttons = document.querySelectorAll('button');
        for (var i = 0; i < buttons.length; i++) {
        buttons[i].onclick = xxx;
        }
        ```

    3. DOM 元素属性:形如`myButton.onclick = function(event){alert('Hello world');};`.这种方法的缺点是这种方法的问题在于每个元素和事件只能设置一个处理函数。
        1. 该方法可以给同一个监听器注册多个处理器,但是后面的会覆盖前面的.
4. 事件派发.当事件发生时， event 对象就会被创建并依次传递给事件监听器。处理函数中，将event对象作为第一个参数,可以访问event对象的内容.事件派发有3个阶段:捕获,到达,冒泡.
    1. 事件派发的常见方法:
        1. 使用`eventTarget.dispatchEvent(event)`.如果是自带的事件,也可以调用相关的方法来触发,比如button的点击可以使用`button.click()`,获取焦点使用`xxx.focus()`
        2. 对于IE8-,形如`element.fireEvent('onclick')`

#### 3.1.1 事件目标(event target)
EventTarget是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器,实现了该接口就意味着能够触发事件(emit event).element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如XMLHttpRequest，AudioNode，AudioContext 等等。其中element，document 和 window支持通过`on...`properties和attributes设置event listener和event handler.

#### 3.1.2 事件监听器/侦听器(event listener)和事件处理器（event handler）
除了注册方式,这两者可以认为是一个东西.mdn官网的解释是:事件处理器有时候被叫做事件监听器——从我们的用意来看这两个名字是相同的，尽管严格地说来这块代码既监听也处理事件。监听器留意事件是否发生，然后处理器就是对事件发生做出的回应.

event listener:指通过 `EventTarget.addEventListener()` 注册的函数或对象

event handler:指通过 `on...`属性注册的函数。

#### 3.1.3 事件对象(event)
表示在DOM或其他API中发生的任何事件,包含所有事件通用的属性和方法.

属性:
1. `bubbles`:boolean,表示该事件是否在DOM中冒泡
2. `cancelable`:boolean,表示该事件的默认动作(比如切换复选框是单击复选框的默认操作)是否可以取消.
3. `currentTarget`:当前注册事件的对象的引用。这是一个这个事件目前需要传递到的对象（大概意思就是注册这个事件监听的对象）。这个值会在传递的途中进行改变。
4. `eventPhase`:代表当前执行阶段的整数值

    参考:https://developer.mozilla.org/zh-CN/docs/Web/API/Event/eventPhase

5. `type`:事件的类型,常见的有,
    1. `UIEvents`
    2. `MouseEvents` 
    3. `MutationEvents`
    4. `HTMLEvents`

方法:
2. `stopPropagation()`:
6. `preventDefault()`:取消事件的所有默认动作（如果该动作可取消）该方法不会阻止事件的进一步冒泡,调用该方法后`cancelable`的属性变为false.


#### 3.1.5 事件触发器,事件派发和事件委托

### 3.2 常见事件
事件一般可以分为三类:官方标准事件,浏览器特有事件,自定义事件.

 onclick 几乎可以用在几乎每一个元素上

keypress

# 七 未整理
1. 事件派发有设计模式?

dispatchEvent,事件派发和事件委托

currenttarget和target

2. 能自定义事件目标吗