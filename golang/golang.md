# golang
[TOC]
## 一. 概述
1. 目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。
2. “如果一个特性并不对解决任何问题有显著的价值，那么Go就不提供它”的原则
3. Go语言在语言层面解决软件工程问题的设计哲学
4. Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。

### 1 简介
#### 1.1 优点
- 编译成无依赖二进制:copy部署很方便,拷贝就能跑了.(这也是很多人选go的最大理由)
- 协程
- 强大且完善的库
- 稳定性:go提供了软件生命周期各个环节的工具(开发,测试,部署,维护等)

#### 1.2 缺点
- 语法不容易习惯
- 不能用的变量写成`-`,不方便调试(?)
- go的包管理:感觉不如npm好用
- 不支持泛型
- 没有存储过程(?)
- 错误处理的代码多了很不爽

#### 1.3 他人评价
1. 更好的 c
2. go + java是不错的实践
3. 资深技术专栏作家 Matt Asay 在外媒上发文表示，究其原因，应该是经验的问题，在你拥有了老语言的使用经验后，使用新语言会变得更清晰明了。换句话说，如果你已经花了数年的时间去了解 Java ，那么应该会更容易理解 Go 有多优秀。
4. HackerRank 近日对约 4 万名开发者进行了调查，并发布了名为“2018 年开发者技能报告”:
    
    Go 虽然是一种很酷的语言，但它只占据了一个小小的位置，似乎并没有成为某种基础设施的最擅长的代码。也因此，它没有真正抓住年轻工程师的想象力。
5. Pike说
    1. 它至少在强度上比JavaScript高一级。Google自建Chrome浏览器，部分原因就是加速JavaScript和网页表现，而Google已经融合了本身的技术，如Native Client和Gears。
    2. 我不认为我们能取代任何东西。我们只是创造出这个领域的另一个角色。
6. Go语言标准库难以置信的强大，值得你花时间阅读它的代码，学习它实现的模式。
7. 云风博客:我发现我花了四年时间锤炼自己用 C 语言构建系统的能力，试图找到一个规范，可以更好的编写软件。结果发现只是对 Go 的模仿。缺乏语言层面的支持，只能是一个拙劣的模仿。

### 2 历史
1. go从1.5开始就移除了"最后残余的C代码"

### 3 常识
#### 3.1 未整理
1. Go语言的标准库（通常被称为语言自带的电池）
2. Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
3. Go语言反对函数和操作符重载（overload）
4. 支持匿名函数与闭包
6. 以囊地鼠（Gopher）作为它的吉祥物,Rob Pike的妻子 Renee French绘制的
7. go里面一个中文占三个字节.
8. 有C基础，学Golang非常轻松

#### 3.2 go是用什么语言写的
参考[Golang本身是用什么语言写的？ - CNife的回答 - 知乎](https://www.zhihu.com/question/66944175/answer/248620046)
最开始是c和汇编,从1.5开始,go用语言实现了自己的编译器,即完成了自举,也就是全部都是用go实现的了.

#### 3.3 语句后的分号
1. Go程序并不要求开发者在每个语句后面加上分号表示语句结束，这是与C和C++的一个明显不同之处。
2. Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。举个例子, 函数的左括号{必须和func函数声明在同一行上, 且位于末尾，不能独占一行，而在表达式x + y中，可在+后换行，不能在+前换行。

#### 3.4 语句后的逗号
为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号,最后插入的逗号不会导致编译错误，这是Go编译器的一个特性.如,

```go
input := map[string]interface{}{
    "up_channel_id": ctx.Input.GetString("up_channel_id"),
    "page_index":    ctx.Input.GetString("page_index"),
    "page_size":     ctx.Input.GetString("page_size"),
}
//...
img.SetColorIndex(
    size+int(x*size+0.5), size+int(y*size+0.5),
    blackIndex, 
)
```

#### 3.5 关于go的作者
1. Robert Griesemer：曾协助实现 Java 的 HotSpot 编译器和 JavaScript V8 引擎。
2. Rob Pike：曾是贝尔实验室的 Unix 团队和 Plan9 操作系统成员，与 Thompson 一起创造了 UTF-8 字符编码。
3. Ken Thompson，不用多说了，技术圣殿的人物，创造了 C 语言和 Unix，获得了 1983 年图灵奖和 1988 国家技术奖

#### 3.6 空标识符（blank identifier）
即`_`（也就是下划线）,通常用于丢弃不需要使用的变量,注意`_`不可以单独和`:=`使用.

#### 3.7 简单语句（simple statement）
包括短变量声明、自增语句、赋值语句或函数调用

#### 3.8 go语法定义里为什么把类型写在右边
参考[https://blog.golang.org/gos-declaration-syntax](https://blog.golang.org/gos-declaration-syntax),本人简单概括两点:（待验证）

1. c和java都是先写类型,是巧妙的语法思想，但更适合简单的类型。著名的混淆例子是声明一个函数指针：
    ```c
    int（* fp）（int a，int b）;
    //在这里，fp是一个指向函数的指针，因为如果你写表达式（* fp）（a，b）
    //你会调用一个返回int的函数。如果fp的论点之一本身就是一个函数呢？
    int（* fp）（int（* ff）（int x，int y），int b）
    //变得难以阅读
    ```
2. 类型和表达式语法的区别使得在Go中编写和调用闭包很容易：
    ```go
    sum：= func（a，b int）int {return a + b}（3,4）
    ```
#### 3.9 rune,byte和string的关系
在Go当中 string底层是用byte数组存的，并且是不可以改变的。例如 `s:="Go编程" fmt.Println(len(s)) `输出结果应该是8因为中文字符是用3个字节存的。`len(string(rune('编')))`的结果是3.如果想要获得我们想要的情况的话，需要先转换为rune切片再使用内置的len函数,`fmt.Println(len([]rune(s)))`,结果就是4了。所以用string存储unicode的话，如果有中文，按下标是访问不到的，因为你只能得到一个byte。 要想访问中文的话，还是要用rune切片，这样就能下标表访问。

简单总结就是:rune 能操作 任何字符,byte 不支持中文的操作.

1. string和[]byte的异同

    从源码可知string主要是由[]byte构成.string不可变,每次值改变(重新分配内存空间),指针会指向新的字符串的内存地址,而[]byte值改变的时候指针不会移动,所以[]byte性能比string高.

3. 使用比较
    - string可以直接比较，而[]byte不可以，所以[]byte不可以当map的key值。
    - 因为无法修改string中的某个字符，需要粒度小到操作一个字符时，用[]byte。
    - string值不可为nil，所以如果你想要通过返回nil表达额外的含义，就用[]byte。
    - []byte切片这么灵活，想要用切片的特性就用[]byte。
    - 需要大量字符串处理的时候用[]byte，性能好很多。
注意他们之间的比较用`bytes.Equal(s1, s2) == 0`而不是`bytes.Compare(s1, s2) == 0`

#### 3.10 方法接收者(Receiver)
Receiver 的名称应该缩写，一般使用一个或者两个字符作为Receiver的名称，如`func (f foo) method() {...}`;如果方法中没有使用receiver,还可以省略receiver name,这样更清晰的表明方法中没有使用它:`func (foo) method() {...}`

### 4 文档
1. _Effective Go_(中文名《搞笑Go编程》)
### 5 网址
1. 网友写的Go web编程gitbook，比较详细，应该很值得读：[https://astaxie.gitbooks.io/build-web-application-with-golang/zh/](https://astaxie.gitbooks.io/build-web-application-with-golang/zh/)
2. go语言圣经中文网：[http://books.studygolang.com/gopl-zh/](http://books.studygolang.com/gopl-zh/)
3. 该网址可以找到社区写的package(?):[https://godoc.org](https://godoc.org)

## 二 安装配置
- GOROOT用于指定Go的安装目录,还有它自带的标准库包的位置

    比如存放fmt包的源代码对应目录应该为$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。

- GOPATH对应的工作区目录,有三个子目录

### 1 windows
1. 下载安装

3. 配置GOROOT(C:\Go)和PATH(添加%GOROOT%\bin)，这样就可以在任意地方运行go开头的命令了

4. 配置GOPATH:系统默认的gopath是GOROOT，`fmt`等包在GOROOT中，所以可以直接`import`；当安装了gocode和gopkgs等工具时，还会算上安装工具的目录；但是如果`import`的目录不在这两者当中，那么就会报错找不到，所以要把自己go代码的目录加入到GOPATH中
>设置GOPATH的时候只需要写src前面的目录，会自动去src下找；设置了GOPATH之后，`import`时就只会去GOROOT和GOPATH中找；添加多个目录的时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，大部分情况下会是第一个路径优先，比如：查找包、go get的内容默认放在第一个目录下

5. 配置gobin(需不需要看情况)

### 2 mac
#### 2.1 二进制发行版安装
#### 2.2 第三方工具安装(homebrew等)

### 3 linux
#### 3.1 安装包（二进制发行版）安装(**推荐**)
1. 下载xxx.tar.gz，安装到`/usr/local`下:
```bash
#查看压缩文件内容
tar -ztvf xxx.tar.gz
#解压到目录下
sudo tar -zxvf xxx.tar.gz -C /usr/local 
```

2. 环境变量设置：需要设置GOROOT和GOPATH,GOROOT是go的安装目录,GOPATH是放bin,src,pkg的目录
    - 设置GOROOT:
        1. 设置方式类似于JAVA_HOME，如`export GOROOT=$HOME/xxx`
        2. 把`$GOROOT/bin`加入PATH：`export PATH=$PATH:$GOROOT/bin`
        
    - 设置GOPATH：这个目录用来存放Go源码(src)，Go的可运行文件(bin)，以及相应的编译之后的包文件(pkg)
        >在go1.1到1.7，该变量必须设置，且不能和go安装目录一样;从1.8开始有默认值，在Unix上默认为`$HOME/go`,在Windows上默认为`%USERPROFILE%/go`

        1. 设置GOPATH(**最好不要和go安装目录相同**)
        2. 把GOPATH/bin加入环境变量 

3. 关于GOBIN（待验证）:
将`$GOPATH/bin`加入PATH中，这样可以方便的运行`go install`好的二进制程序。然而，当存在GOPATH中存在多个路径时，这种写法只会将最后一个路径跟上bin。在mac或linux下可以通过这种方式解决：
`${GOPATH//://bin:}/bin`

#### 3.2 源码安装
#### 3.3 第三方工具安装（apt、wget等）

## 三 基础
### 1 程序结构
#### 1.1 命名
Go语言程序员推荐使用 驼峰式 命名

#### 1.2 声明
Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

#### 1.3 变量
1. 变量声明

    其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
    ```go
    //声明变量的方式1:一般是变量类型和初值类型不同时才使用
    var 变量名字 类型 = 表达式
    ```

    ```go
    //声明变量的方式2：零值初始化,也可用于多个变量是同一类型的情况，此时只写最后一个类型
    var i int
    var i, j, k int                 // int, int, int
    //声明变量的方式3:一般用于同时声明多个变量，可省略类型，会自动判断
    var b, f, s = true, 2.3, "four" // bool, float64, string
    ```

    初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。例子如下：

    ```go
    var f, err = os.Open(name) // os.Open returns a file and an error
    ```

    在**函数内部**，有一种称为**简短变量声明**语句的形式可用于声明和初始化局部变量,可以简单理解为`:=`是声明且赋值,例子如下：

    ```go
    //声明变量的方式4:简短变量声明(只能在函数内使用)
    anim := gif.GIF{LoopCount: nframes}
    freq := rand.Float64() * 3.0
    t := 0.0
    //这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用比如for语句的循环的初始化语句部分
    i, j := 0, 1
    ```

    注意：
    1. 简短变量声明语句中必须至少要声明一个新的变量,对于其他已经声明过的变量，则只有赋值操作
    2. 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

2. 变量的初始值
    
    零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。
    1. 数值类型变量对应的零值是0，
    2. 布尔类型变量对应的零值是false，
    3. 字符串类型对应的零值是空字符串

        注意:检查空字符串用`s == ""`而不是`len(s) == 0`
        
    4. 指针,接口和引用类型（包括slice、map、chan和函数）变量对应的零值是nil。

        注意:检查slice,map或者channel的空值用`len(s) > 0`而不是`s != nil && len(s) > 0`
    5. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
    6. 当要声明一个变量或者结构体为零值时,go习惯使用var,这样更明确

4. 类型转换

    不同类型之间转换需要显式转换
    1. int=>float64:`var f float64 = float64(i)`或者`f := float64(i)`
    2. string=>[]byte:`data := []byte(str)`
    3. []byte=>string:`str := string(bytes)`

5. 赋值
    1. 更有效的赋值写法,比如
        ```go
        count[x] = count[x] * scale // 数组、slice或map的元素赋值
        //下面的写法更有效，可以省去对变量表达式的重复计算
        count[x] *= scale
        ```

    2. 元祖赋值：指同时更新多个变量的值,先计算右边再统一更新左边。好处是:
        - 对同时出现在两边的变量很有帮助
        - 可以使一系列琐碎赋值更加紧凑(特别是在for循环的初始化部分)

        但如果表达式太复杂的话，应该尽量避免过度使用元组赋值

    3. 可赋值性：
        1. nil可以赋值给任何指针或引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换
        2. 对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。
        3. 隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句将隐式地将返回操作的值赋值给结果变量.

6. 变量的生命周期

    对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，在局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

    因为一个**变量的有效周期只取决于是否可达**，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

7. 变量的存储位置

    编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。圣经中的例子如下,
    ```go
    var global *int

    func f() {
        var x int
        x = 1
        global = &x
    }

    func g() {
        y := new(int)
        *y = 1
    }
    ```
    分析:f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。不过一般情况下编程不需要想这么多.

#### 1.4 常量
const声明,可以是字符、字符串、布尔或数字类型的值,不能用`:=`定义
最佳实践是:常量一般声明为MaxLength,而不是以下划线分隔MAX_LENGTH或者MAXLENGTH。

#### 1.5 指针
在其它语言中，比如C语言，指针操作是完全不受约束的。
在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。(说的java?)
Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，`&`操作符可以返回一个变量的内存地址，并且`*`操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。

并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。(?)
指针是实现标准库中flag包的关键技术.
指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）
1. 使用

    如果用“var x int”声明语句声明一个x变量，那么`&x`表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是`*int`，指针被称之为“指向int类型的指针”,同时`*p`表达式对应p指针指向的变量的值.操作`*p`只是增加p指向的变量的值，并不改变p指针.

    还可以使用`new`(注意`new`在go中目前只是预定义函数,而不是关键字)来声明变量,作用和普通声明一样,如`p := new(int)`.但是new用得比较少,因为字面量的方式创建指针更方便.每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

    ```go
    p := new(int)
    q := new(int)
    fmt.Println(p == q) // "false"
    ```

3. 指针的比较

    指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

5. 待整理
    1. 在Go语言中，返回函数中局部变量的地址也是安全的。

#### 1.6 类型
新声明的类型提供了一个方法(我还不知道什么方法,底层的一些东西?)，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的,例子如下,

```go
type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度
//Celsius和Fahrenheit是不同的类型,即使他们的底层类型都是float64
```

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的.
比较运算符==和<也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：
```go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // "true"
fmt.Println(f >= 0)          // "true"
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"!
//最后一个测试为真的原因是因为c和g都是零值,Celsius(f)是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。
```

1. 命名的类型的优点
    - 可以提供书写方便,如果是复杂的类型将会简洁很多，比如结构体类型
    - 为该类型的值定义新的行为

#### 1.7 结构体

#### 1.9 包和文件
1. 网友推荐的包目录结构如下：
```bash
dir      
  -- goWorkSpace1   #主要是为了区分自己的鼓捣的一些东西和工作上的项目
  -- goWorkSpace2   #需要把两个workspace都加入gopath
        -- bin
        -- pkg
        -- src                  
           -- myApp1    #src下最好每个项目一个目录
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp2
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp3
              -- .git
              -- models
              -- controllers
              -- main.go
```

2. 包路径

    go推荐使用相对于$GOPATH/src的路径来导入包;也可以用相对当前位置的路径来import，这种方式不依赖GOPATH，但是不推荐.

3. 包导入

    go并不要求包名是唯一的,但是按照惯例，一个包的名字和包的导入路径的最后一个字段相同.比如导入包`import gopl.io/ch2/tempconv`,则包名是`tempconv`
    1. 导入包的重命名:如果两个包的名字一样,就需要用到包的重命名,如

        ```go
        import (
            "crypto/rand"
            mrand "math/rand" // alternative name mrand avoids conflict
        )
        ```

    2. 导入包的分组:通过添加空行来分组,好处是更容易区分,同时go的工具会对每个分组单独排序.如

        ```go
        import (
            "fmt"
            "html/template"
            "os"

            "golang.org/x/net/html"
            "golang.org/x/net/ipv4"
        )
        ```

    3. 包的匿名导入

        有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数,此时可以使用空白标识符,如`import _ "image/png"`

    4. 包的初始化

        导入包的时候一级变量和`init()`会被初始化,所以可以把初始化的东西写在`init()`方法中.

    1. 目录下同级的go文件package必须和包名一样
    3. 一般的: 
        ```bash
        --config
            -- config.go    #假设config目录下有config.go文件
        ```
        config.go中的package名称~~必须~~最好和目录config一致，而文件名可以随便。main.go表示main包，文件名建议为main.go。（注：**不一致时，生成的.a文件名和目录名一致，这样，在import 时，应该是目录名，而引用包时，需要包名。例如：目录为myconfig，包名为config，则生产的静态包文件是：myconfig.a，引用该包：import “myconfig”，使用包中成员：config.LoadConfig()**）

    4. 简单总结就是:
        ```go
        package 最后一层目录名(最好)or其他名字
        import 源文件所在目录src后的完整路径名(go的import查找的是包的路径，并不是包名)
        //使用时最后一层目录名or其他名字来调用
        ```

    6. GOPATH和GOPATH下的src目录不应该添加到源代码管理中

3. 关于包的初始化
    1. 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了
    2. 可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数

4. 待整理
    1. 最外层的go文件的package是main,方法名是main,这应该是go的硬性规定;如果最外层的go文件有多个,方法名都声明为main会出现错误提示,实际使用不受影响.

### 1.10 作用域
go的作用域和生命周期是不同的概念
1. go的三个流程控制语句紧跟的初始化块声明的变量,其作用域和声明在语句`{}`中变量一样
2. 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。

### 2 数据类型
Go语言将数据类型分为四类：
1. 基础类型：包括数字、字符串和布尔型。
2. 复合类型(聚合)：通过组合简单类型，来表达更加复杂的数据结构，包括数组和结构体
3. 引用类型：包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用
4. 接口类型：就是接口

#### 2.1 基础数据类型
##### 整数
##### 字符串
1. raw字符串:就是两个反引号包裹的
最佳实践:正则表达式中使用raw字符串更简洁

#### 2.2 复合数据类型
##### 数组
1. 元素占用内存相同且连续，所以访问元素速度很快
2. 数组的声明
    ```go
    //1.直接声明
    var arr [5]int
    //2.使用字面量声明
    var arr := [5]int{1,2,,5,5,6}
    //3.自动计算长度声明
    var arr := []int{1,3,5} 
    //4.指定特定元素的值
    var arr := [5]int{2:5,3:6}
    ```
3. 数组的赋值
    只有类型和大小一样的数组才能相互赋值
4. 在函数间传递数组
    可以传递值也可以传递指针，后者只需要在栈上开辟8字节的内存，性能更好，但是对指针的改动会影响共享内存

##### 切片
切片可看作go对数组抽象后的类似动态数组的集合,语法和python类似

切片的声明:
```go
//1.使用内置make函数
slice := make([]string,5)
//如果只指定长度，那么容量和长度相等
//也可以分开指定，但必须容量>长度
//2.使用切片字面量来声明切片
//此时长度和容量也是相等的
slice := []string{"a","b","c"}//长度和容量都是3
//3.使用索引声明切片
slice := []stirng{99:"hello"}//长度和容量是100
//4.使用切片创建切片
slice := []int{10,20,30,40,50}
newSlice :=slice[1:3]//newlice的长度为2，容量为4，且和slice同一截数组
//5.使用三个索引创建切片
slice := []string{"a","b","c","d","e"}
newSlice := slice[1:3:4]//newSlice的长度2，容量为3
//其他：1.声明空切片,可用于表示空集合
slice := make([]string,0)
slice := []stirng{}
//其他：2.声明nil切片,需要描述一个不存在的切片时会用到nil切片
slice := []int
```
注意:
- 只要[]里有值，就不是切片而是数组了
- 声明空的slice应该使用`var t []string`而不是`t := []string{}`,前者声明了一个nil slice而后者是一个长度为0的非nil的slice

切片的增长:
- 使用go语言内置的append()，该函数总会增长切片的长度，而容量有可能会变
- 容量<1000时，每次扩容是翻倍；超过1000，每次增加25%
- 当每次容量不够的时候，append()就会分配一个新的数组，所以可以通过设置长度和容量一样的切片来保证第一次append()分配的是新数组

切片的迭代:
- 使用关键字range,第一个返回值是索引，第二个返回值是值的副本
    ```go
    for index,value range slice{
        ...
    }
    ```
- 也可用普通的for循环

在函数间传递切片:
传递的是切片本身(64位上24字节)，而与切片关联的数据包含在底层数组里，不属于切片本身，所以传递切片时不会影响底层的数组,简单快速.
但实际测试有一些细节:
- 对元素赋值等会影响原切片
- append()不会影响原切片,但是传递的是切片指针时会影响

切片常用方法和属性:
- `len()`:返回切片的长度
- `cap()`:返回切片的容量

最佳实践:复制切片用內建的`copy()`

##### 映射map
map是存储无序键值对的集合,map强大的地方在于可以根据键快速检索到值(对集合元素，提供常数时间的存、取或测试操作).go里面map的键可以是任意类型,只要其值可以用"=="比较,最常用的字符串;值则可以是任意类型.从功能和实现上说，Go的map类似于Java语言中的HashMap，Python语言中的dict，Lua语言中的table，通常使用hash实现。


#### 2.3 引用数据类型
#### 2.4 用户自定义类型
有两种声明方法,一种是结构体,一种是基于已有的类型
1. 结构体
2. 基于已有的类型,如`type doration int64`,此时int64是doration的基础类型,但是go并不认为doration和int64是同一个类型
### 3 流程控制
go的三个流程控制语句后都可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用.比如紧跟一个简短变量声明,好处是:
- 让代码更加简单
- 限制这个变量的作用域(易忘点)

go的三个流程控制语句后的条件都不需要加`()`

#### 3.1 for(go中唯一的循环)
一般用法如下,其中initalization可选,如果有,则必须为简单语句;condition也是可选的,是一个布尔表达式，其值在每次循环迭代开始时计算,如果为true则执行循环体语句;post语句也是可选的,在循环体执行结束后执行,之后再次对conditon求值,condition值为false时，循环结束.

```go
for initialization; condition; post {
    // zero or more statements
}
```

更常用的是遍历数组,切片,字符串等时和`range`配合使用,如下

```go
for index,ele := range xxx {
    //...
}
```

1. for后面的三个语句(initialization; condition; post)都可以省略，此时可以看做go的`while`
2. 和其它语言中的`break`和`continue`一样，`break`会中断当前的循环，并开始执行循环之后的内容，而`continue`会中跳过当前循环，并开始执行下一次循环。

#### 3.2 if else

#### 3.3 switch
1. 语法
    1. 从上到下匹配，成功时停止;不需要显式写上`break`,因为匹配某个`case`并执行完成后会自动退出`switch`;
    2. 没有条件的switch等于`switch true`，这种形式叫做无tag switch(tagless switch),可以更清晰的用来编写长的 if-then-else 链：

        ```go
        t := time.Now()
        switch {
        case t.Hour() < 12:
            fmt.Println("Good morning!")
        case t.Hour() < 17:
            fmt.Println("Good afternoon.")
        default:
            fmt.Println("Good evening.")
        }
        ```

    3. `fallthrough`

        该关键字很少用.如果在`case`执行语句末尾加上该关键字,该`case`执行完成后不会退出,而是直接执行下一个`case`(跳过下一个`case`的判断)里的语句,如,

        ```go
        switch {
        case false:
                fmt.Println("The integer was <= 4")
                fallthrough
        case true:
                fmt.Println("The integer was <= 5")
                fallthrough
        case false:
                fmt.Println("The integer was <= 6")
                fallthrough
        case true:
                fmt.Println("The integer was <= 7")
        case false:
                fmt.Println("The integer was <= 8")
                fallthrough
        default:
                fmt.Println("default case")
        }
        ```
2. `switch`中的`continue`,`break`


### 4 函数
1. 基本语法
    1. 所有go函数以`func`开头,函数方法名首字母大写(?)，函数外的每个语句都必须以关键字开始(也就意味着简短声明表达式不能在函数外使用)
    2. 支持多返回值，返回值名称可作为文档使用，且可以像变量一样直接使用
2. go函数的大概结构
    Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。
#### 4.1 函数声明
1. 函数的类型被称为函数的标识符
1. 如果函数在声明时，包含返回值列表，则函数必须以return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环.
2. 函数实参通过值的方式传递，即形参是实参的拷贝，对形参修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。
4. 可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符，如:
    ```go
    package math
    func Sin(x float64) float //implemented in assembly language
    ```
#### 4.2 递归
1. 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题
#### 4.3 多返回值
1. 关于debug：调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值，如下，
    ```go
    log.Println(findLinks(url))
    links, err := findLinks(url)
    log.Println(links, err)
    ```
2. 关于函数命名：准确的变量名可以传达函数返回值的含义(比如长、宽、高等)，不过按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释
3. 关于bare return(裸返回)：如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。
    >当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。
#### 4.5 函数值
1. 关于第一类值(first-class values)和第二类值
    有些语言中function跟int, double的地位是一样的。这种语言就为函数是第一类值；而有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。(这里函数是已经是广义的了，用来表示代码code)。只能存储一个指向函数的指针，这种语言称为函数是第二类值。
2. 函数类型的零值是nil。函数值之间是不可比较的，但函数值可以与nil比较。调用值为nil的函数值会引起panic错误。
#### 4.6 匿名函数(anonymous function)
1. 定义：函数字面量(function literal)的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。
2. 匿名函数的优点:
    1. 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值，而且不必担心函数名冲突
    2. 更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量
3. 简单例子如下
    ```go
    // squares返回一个匿名函数。
    // 该匿名函数每次被调用时都会返回下一个数的平方。
    func squares() func() int {
        var x int
        return func() int {
            x++
            return x * x
        }
    }
    func main() {
        f := squares()
        fmt.Println(f()) // "1"
        fmt.Println(f()) // "4"
        fmt.Println(f()) // "9"
        fmt.Println(f()) // "16"
    }
    ```
#### 4.8 defered函数(待补充)
1. 语法：
2. 配合匿名函数
### 5. 方法
1. 关于方法的接收者选择
    1. 要由接收者类型的本质来决定,感觉有点复杂,简单说就是看使用情况:对于内置类型,基本都是值接收者(?),对于结构类型就要看情况了
    2. 例外是需要让类型值符合某个接口的时候

### 6. 接口
1. go的接口是非侵入式的，只要实现了接口里要求的全部方法，就实现了接口
    带来的优点是：
    1. 不用绘制类库的继承树图
    2. 不用纠结接口需要拆的多细
    3. 不用为了实现一个接口而专门导入一个包
2. 
### 7. Goroutines和Channels
#### 未整理
1. 网友:goroutine 并不是 “把异步回调的代码用同步的方式来写”。而是在用户空间实现了一个 M 对 N 的调度器。 
简单来讲，异步回调一般只开一个线程，有任务了之后会把让这个线程去执行这个任务，无法利用多核。 
而 goroutine 会根据机器的运行情况开 N 个操作系统级别的线程，然后把 M 个用户级别的 goroutine 调度到这 N 个线程上。 
golang 团队一直引以为傲的就是这个 M 对 N 的调度器，这种 M 对 N 调度器在业界也算是比较先进的。
2. 网友:协程不是异步回调，协程是状态的保存和切换，这种思想很容易写出异步代码，实现同样的异步功能， c++或者 java 之类的写到你想吐
#### goroutine
是一种比线程更加轻盈、更省资源的协程.

### 8. 基于共享变量的并发

### 10 测试
### 11 反射
### 12 底层编程
### 13 错误处理
Golang 没有传统的异常机制。
对于非致命的错误，Golang 使用返回值来报告(Golang 支持多返回值).
对于致命的错误，Golang 直接选择“崩溃”掉(当然也有恢复机制), 不过按照 Golang 的哲学，既然是致命错误，就应当挂掉。
还有 defer 关键字，用于将一个语句“绑定”到函数退出时执行，无论是通过各种途径退出，这可是 C/C++ 里面的大问题。
1. 任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。
2. 关于内置的error：
    内置的error是接口类型，可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息，如
    ```go
    fmt.Println(err)
    fmt.Printf("%v", err)
    ```
注意:
1. 为了编写强壮的代码，不用使用_忽略错误，而是要处理每一个错误，尽管代码写起来可能有些繁琐。
2. 尽量不要使用panic。

#### 13.1 错误处理策略(5种？)
1. 传播错误（最常用的方式）
    由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息
2. 重试
    如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
3. 输出错误信息并结束程序
    用于错误发生后，程序无法继续运行。这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非遇到了bug，才能在库函数中结束程序
    1. 关于错误信息的时间：
    log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。
        ```go
        if err := WaitForServer(url); err != nil {
            log.Fatalf("Site is down: %v\n", err)
        }
        ```
4. 只输出错误信息
    ```go
    //log包(log包中的所有函数会为没有换行符的字符串增加换行符)提供函数:log.Printf
    //或者标准错误流输出错误信息:fmt.Fprintf
    ```
5. 忽略掉错误

#### 13.2 go的错误处理方法
检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。

#### 13.3 
通常会把自定义的Error放在package级别中，统一进行维护,并且变量以Err开头,如:`var (ErrCacheMiss = errors.New("memcache: cache miss")...)`

### 14 垃圾回收
Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。(java等也是？)
Go 最初采用的是标记清扫算法，到了 1.5 开始引入三色标记和写屏障，垃圾回收的性能才有了好转。这套机制最终的目标就是在用户业务无感知的情况下实现垃圾回收，希望未来的版本这部分有更优秀的表现。
### 14.1 变量的生命周期
**go中一个变量的有效周期只取决于是否可达**，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在
### 14.2 堆栈分配
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。比如某个局部变量x在函数退出后依然可以通过包一级的global变量找到，那么x必须在堆上分配内存，用Go语言的术语说，这个x局部变量从函数f中逃逸了

### 15 注释
注释有两种形式：
- 行注释以 // 开始，至行尾结束。一条行注释视为一个换行符。
-  块注释 以 /* 开始，至 */ 结束。 块注释在包含多行时视为一个换行符，否则视为一个空格。

注意:
1. 注释不可嵌套
2. 版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。
注释的最佳实践:`//`之后应该加一个空格

## 四 高级
### 1 go的工具(命令行)
1. Go语言提供的工具都通过一个单独的命令go调用
2. 关于go工具的输出：只有在错误的时候才会输出，这点跟unix的哲学一样

#### 1.1 run
#### 1.2 install
1. 首先说一下一般的go项目在GOPATH下的目录结构：
```bash
-- GOPATH  #GOPATH目录
  -- bin  #golang编译可执行文件的存放路径，可自动生成。
  -- pkg  #golang将可执行文件所依赖的各种package编译后的.a(or ?)中间文件存放路径，可自动生成
  -- src  #源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。
```
2. 命令会安装go包所依赖的任何东西
3. 只需要有src目录，bin和pkg会自动生成；install后是跟main.go的父级目录名，生成的可执行文件也是父级目录名；

#### 1.3 build
保存编译结果(可执行二进制文件)以备将来之用,形如`go build hello.go`

#### 1.4 clean
清理生成的可执行文件，如`go clean hello.go`

#### 1.5 run
编译且运行

#### 1.6 get
通过源码控制工具(比如git)递归获取代码包及其依赖,已有的不会再去获取.

简单使用:比如git的地址是`https://github.com/xushike/studyGo.git`,使用git获取代码是`git clone https://github.com/xushike/studyGo.git`,如果用go get命令就是`go get github.com/xushike/studyGo`,然后代码目录就是`GOPATH/src/github.com/studyGO`

参数说明:
- `-u`:强制更新已有的代码包及其依赖
- `-v`:打印出被构建的代码包的名字(待测试)

注意:导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同,是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供

#### 1.7 vet
可以捕获一些常见的错误，如格式化字符串等

#### 1.8 fmt
代码格式化，开发工具中一般都集成了保存的时候自动格式化.以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执,更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。

指定包名时,`fmt`会格式化包中所有`.go`文件,否则格式化当前目录

#### 1.9 doc和godoc
##### go doc
查看文档,挺方便的.如`go doc http.ListenAndServe`可以看到该函数的说明(显示的是函数上被注释的声明),`go doc http`可以直接看到包的说明,`go doc builtin.make`查看内建函数的说明.

##### godoc

### 2 其他与go有关的工具
##### Cgo
编译(静态编译?)一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件

##### gb
社区开发的依赖管理工具，而且也推荐用依赖管理工具来管理依赖

### 3 源码分析
#### 3.1 待整理
编译器源码目录下，src/cmd/compile/internal

## 五 经验
### 1 go编程思想和习惯
写Go代码就要用Go的哲学和思想,而不是抱着java,js等其他语言的思想.弄清楚Go语言的设计选择和背后的动机,理解的简洁和可组合性哲学.

1. 少用模板,多用组合(也是Unix程序设计提倡的思想).
2. go中返回的布尔值通常表示操作是否成功,一般可以命名为`ok`
3. Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。如下,

    ```go
    if f, err := os.Open(fname); err != nil {
        return err
    } else {
        // f and err are visible here too
        f.ReadByte()
        f.Close()
    }
    //更推荐的写法：Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。
    f, err := os.Open(fname)
    if err != nil {
        return err
    }
    f.ReadByte()
    f.Close()
    ```

### 2 常用包和方法
#### fmt
其中以f(表示fomart)结尾的方法(比如`Printf()`,`Errorf`等)可以使用格式化输出,即使用`%d`,`%c`等转换输出格式,这些也被go程序员称为动词（verb）.以ln(表示line)结尾的方法跟`%v`差不多的方式格式化参数，并在最后添加一个换行符。
许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印.
1. 动词（verb）说明

    ```go
    package main
    func main() {
        type point struct {
            x, y int
        }
        p := point{1, 2}
        fmt.Printf("%v\n", p)
    }
    ```

    1. `%v`:未指定时,是打开任意类型的默认格式
    2. `%+v`:如果值是一个结构体，输出内容将包括结构体的字段名.如`{x:1 y:2}`
    3. `%#v`:输出这个值的 Go 语法表示.如`main.point{x:1, y:2}`
    4. `%T`:打印值的类型.如`main.point`
    5. `%t`:格式化布尔值
    6. 进制格式化
        - `%d`:标准十进制格式化
        - `%b`:二进制
        - `%x`:十六
    7. `%c`:输出给定整数的对应字符
    8. 浮点数格式化
        - `%f`:标准十进制格式化
        - `%e`和`%E`:科学计数法
    9. `%s`:对给定字符串进行原样输出.比如字符串有一个空行,输出结果中也会有一个空行
    10. `%p`:输出指针的值.如`fmt.Printf("%p\n", &p)`,会输出`0xc42000e280`
    11. 指定输出宽度,使用`[num]`:如`fmt.Printf("|%6s|%6s|\n", "foo", "b")`,会输出`|   foo|     b|`

        在有宽度的时候,默认是右对齐
    11. 输出左对齐,使用`-`:如`fmt.Printf("|%-6s|%-6s|\n", "foo", "b")`,会输出`|foo   |b     |`


1. [https://studygolang.com/articles/2644](https://studygolang.com/articles/2644)
3. `Printf()`:支持格式化输出
5. `Sprintf()`:格式化并返回一个字符串而不带任何输出
2. `fmt.Errorf`函数使用`fmt.Sprintf`处理错误信息
6. `Fprintf()`:依据指定的格式向第一个参数内写入字符串，第一参数必须实现了 io.Writer 接口。Fprintf() 能够写入任何类型，只要其实现了 Write 方法，包括 os.Stdout,文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。适合任何形式的缓冲写入(?),在缓冲写入的最后千万不要忘了使用 Flush()，否则最后的输出不会被写入。

#### strings
1. `TrimSpace()`:去除字符串左右两边的空格,包括回车符等,但是不会去除字符串里面的空格

    有空研究一下里面的实现原理
2. `Replace(str, " ", "", -1)`:去掉字符中所有的空格(实测回车和换行都去除不掉)
2. `Replace(str, "\n", "", -1)`:去掉字符中所有的换行
4. `Join()`和`Split()`:可以看成两个功能相反的方法

最佳实践:
1. 使用`strings.TrimPrefix／strings.TrimSuffix`掐头去尾,而不是自己去判断

#### strconv
该包用于string类型的各种转换
2. `Atoi()`:string=>int

### 3 go的编译器
#### 为何这么快(from圣经)
Go语言的闪电般的编译速度主要得益于三个语言特性:
1. 所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。
2. 禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。
3. 编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）

### 4 第三方包
1. mysql驱动:[github.com/go-sql-driver/mysql](github.com/go-sql-driver/mysql)

### 5 其他
1. 有空的时候可以多看看Google的工程师是如何实现的

## 六 问题
### 1 已解决
#### 1.1 关于go中的自增自减
自增语句i++给i加1；这和i += 1以及i = i + 1都是等价的。对应的还有i--给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i++非法，而且++和--都只能放在变量名后面，因此--i也非法。

#### 1.2 如何查看内建函数的源代码
参考[Built-In source code location](https://stackoverflow.com/questions/18512781/built-in-source-code-location).大意就是运行时会根据类型等来调用不同的函数(在"cmd/compile/internal/gc/typecheck.go"),内建函数可以看做是多个函数的组合,想看代码的话就只有分析可能调用的方法慢慢找.

#### 1.3 判断变量的类型
1. `reflect.TypeOf()`

#### 1.4 常见错误:err is shadowed during return
作用域问题,在if等语句内部声明的err覆盖了外面的err,当内部执行完毕之后外部的err并没有变.

### 2 未解决
1. 因式分解
3. 编程范式
4. Erlang风格的并发模型
5. go支持Erlang语言为代表的面向消息编程思想
6. 不清楚go的稳定性，所以目前很多公司还不太敢用
7. 从源码安装软件怎么操作？二进制发行版和安装版的区别？
8. return的几种用法
9. go省略返回值形参，只有形参类型的写法
10. protobuf的获得和使用
11. go get如果后面是xxx.go而不是项目的名字，那么引入的是这一个go文件还是整个项目？
12. go的闭包
13. go generate 生成代码
14. go type的几种写法
15. why golang don't support Stored Procedure or Generic?
16. 一些文章
    1. [http://blog.csdn.net/libaineu2004/article/details/49722651](http://blog.csdn.net/libaineu2004/article/details/49722651)

17. go声明字符串和多行字符串可用``(加入笔记)
18. go new 对象
19. 协程是什么
20. 可做笔记
    1. [Golang json用法详解（一）](https://www.cnblogs.com/yangshiyu/p/6942414.html)

21. 网友:string []byte 的转换是会拷贝的?

## 七 待整理
1. go源代码的分析

    本来想看go内建函数copy的源代码的,结果点不进去,于是用上网搜了搜,觉得有两种可能:
    1. 是调用copy()的时候go的编译器将其解析成汇编代码

        如果是这样的话,go的很多方法实现的汇编代码都可以抽空看看,应该值得学习的不少
    2. 调用了某个文件里声明的copy方法

2. [网友写的go学习资料](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md)
3. [为什么那么多开发人员用Go语言来构建自己的新项目](http://www.epubit.com.cn/article/942)
4. [我为什么喜欢Go语言(简洁的Go语言)_Golang](https://edu.aliyun.com/a/12182)
5. go的unsafe,Pointer,uintptr,funcPC,slicestringcopy,copyany

6. go语言圣经
    1. 如何写标准测试程序

7. [极客学院的go学习](http://wiki.jikexueyuan.com/project/the-way-to-go/)
8. 传递map的时候是引用传递
9. 竞态条件
10. Go语言提供了一些很好用的package，并且这些package是可以扩展的。Go语言社区已经创造并且分享了很多很多。所以Go语言编程大多数情况下就是用已有的package来写我们自己的代码。

    如何扩展?
11. 有空的话应该都看完:[极客学院的go教程](http://wiki.jikexueyuan.com/list/go/)

12. flag包是干嘛的 
13. go的socket.

14. [用go写一个windows外挂](http://www.ituring.com.cn/article/468550)

15. golang的升级(笔记)


