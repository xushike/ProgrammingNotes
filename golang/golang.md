# golang
[TOC]
## 一. 概述
1. 目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。
2. “如果一个特性并不对解决任何问题有显著的价值，那么Go就不提供它”的原则
3. Go语言在语言层面解决软件工程问题的设计哲学
### 1. go的一些常识
1. Go语言的标准库（通常被称为语言自带的电池）
2. Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
3. Go语言反对函数和操作符重载（overload）
4. 支持匿名函数与闭包
5. Go程序并不要求开发者在每个语句后面加上分号表示语句结束，这是与C和C++的一个明显不同之处。
6. 以囊地鼠（Gopher）作为它的吉祥物,Rob Pike的妻子 Renee French绘制的
### 2. go的工具(命令)
1. Go语言提供的工具都通过一个单独的命令go调用
2. 关于go工具的输出：只有在错误的时候才会输出，这点跟unix的哲学一样
#### 2.1 run
#### 2.2 install
1. 首先说一下一般的go项目在GOPATH下的目录结构：
```bash
-- GOPATH  #GOPATH目录
  -- bin  #golang编译可执行文件的存放路径，可自动生成。
  -- pkg  #golang将可执行文件所依赖的各种package编译后的.a(or ?)中间文件存放路径，可自动生成
  -- src  #源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。
```
2. 命令会安装go包所依赖的任何东西
#### 2.3 build
1. 用于测试go包的编译情况,不会产生输出文件
#### 2.4 (格式化代码)
一般是在项目所在的目录下(不是GOPATH/src，当然也可以)执行该命令
2. 只需要有src目录，bin和pkg自动生成；install后是跟main.go的父级目录名，生成的可执行文件也是父级目录名；
### 3. go的工具
#### 3.1 Cgo
编译(静态编译?)一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件
### 4. go相关网站
1. 网友写的Go web编程gitbook，比较详细，应该很值得读：[https://astaxie.gitbooks.io/build-web-application-with-golang/zh/](https://astaxie.gitbooks.io/build-web-application-with-golang/zh/)
2. go语言圣经中文网：[http://books.studygolang.com/gopl-zh/](http://books.studygolang.com/gopl-zh/)
## 二. 安装配置
### 1 windows下的安装
1. ...
3. 配置GOROOT(C:\Go)和PATH(添加%GOROOT%\bin)，这样就可以在任意地方运行go开头的命令了
4. 配置GOPATH:系统默认的gopath是GOROOT，`fmt`等包在GOROOT中，所以可以直接`import`；当安装了gocode和gopkgs等工具时，还会算上安装工具的目录；但是如果`import`的目录不在这两者当中，那么就会报错找不到，所以要把自己go代码的目录加入到GOPATH中
>设置GOPATH的时候只需要写src前面的目录，会自动去src下找；设置了GOPATH之后，`import`时就只会去GOROOT和GOPATH中找；添加多个目录的时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，大部分情况下会是第一个路径优先，比如：查找包、go get的内容默认放在第一个目录下

5.配置gobin(需不需要看情况)
### 2 mac下的安装
#### 2.1 二进制发行版安装
#### 2.2 第三方工具安装(homebrew等)
### 3 linux下的安装
#### 3.1 安装包（二进制发行版）安装(**推荐**)
1. 下载xxx.tar.gz，安装到`/usr/local`下:
```bash
#查看压缩文件内容
tar -ztvf xxx.tar.gz
#解压到目录下
sudo tar -zxvf xxx.tar.gz -C /usr/local 
```
2. 环境变量设置：
    1. 设置GOROOT:
        1. 设置方式类似于JAVA_HOME，如`export GOROOT=$HOME/xxx`
        2. 把`$GOROOT/bin`加入PATH：`export PATH=$PATH:$GOROOT/bin`
        
    1. 设置GOPATH：这个目录用来存放Go源码(src)，Go的可运行文件(bin)，以及相应的编译之后的包文件(pkg)
        >在go1.1到1.7，该变量必须设置，且不能和go安装目录一样;从1.8开始有默认值，在Unix上默认为`$HOME/go`,在Windows上默认为`%USERPROFILE%/go`

        1. 设置GOPATH(**最好不要和go安装目录相同**)
        2. 把GOPATH/bin加入环境变量 
3. 关于GOBIN（待验证）:
将`$GOPATH/bin`加入PATH中，这样可以方便的运行`go install`好的二进制程序。然而，当存在GOPATH中存在多个路径时，这种写法只会将最后一个路径跟上bin。在mac或linux下可以通过这种方式解决：
`${GOPATH//://bin:}/bin`
#### 3.2 源码安装
#### 3.3 第三方工具安装（apt、wget等）
## 三. 基础
### 1. 程序结构
#### 1.3 变量
1. 声明变量的语法
    其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
    ```go
    //声明变量的方式1
    var 变量名字 类型 = 表达式
    ```
    ```go
    //声明变量的方式2：多个连续变量是同一类型，则可以只写最后一个类型
    var i, j, k int                 // int, int, int
    //声明变量的方式3:初始化时使用表达式，可省略类型，会自动判断
    var b, f, s = true, 2.3, "four" // bool, float64, string
    ```

    初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。例子如下：
    ```go
    var f, err = os.Open(name) // os.Open returns a file and an error
    ```
    在**函数内部**，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量：
    ```go
    //声明变量的方式4:简短变量声明(只能在函数内使用)
    /*注意":="是一个变量声明且赋值(如果已经声明，则只有赋值;)语句，
    而"="是一个变量赋值操作*/
    anim := gif.GIF{LoopCount: nframes}
    freq := rand.Float64() * 3.0
    t := 0.0
    /*这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用
    比如for语句的循环的初始化语句部分*/
    i, j := 0, 1
    ```
    注意：`:=`是一个变量声明且赋值语句，而`=`是一个变量赋值操作;如果左边的变量已经声明，则只有赋值操作；简短变量声明语句中必须至少要声明一个新的变量
2. 关于为什么go语法定义里把类型写在右边,参考[https://blog.golang.org/gos-declaration-syntax](https://blog.golang.org/gos-declaration-syntax),本人简单概括两点:（待验证）
    1. c和java都是先写类型,是巧妙的语法思想，但更适合简单的类型。著名的混淆例子是声明一个函数指针：
        ```c
        int（* fp）（int a，int b）;
        //在这里，fp是一个指向函数的指针，因为如果你写表达式（* fp）（a，b）
        //你会调用一个返回int的函数。如果fp的论点之一本身就是一个函数呢？
        int（* fp）（int（* ff）（int x，int y），int b）
        //变得难以阅读
        ```
    2. 类型和表达式语法的区别使得在Go中编写和调用闭包很容易：
        ```go
        sum：= func（a，b int）int {return a + b}（3,4）
        ```
3. 关于变量的初始值：零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。
    1. 数值类型变量对应的零值是0，
    2. 布尔类型变量对应的零值是false，
    3. 字符串类型对应的零值是空字符串，
    4. 接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。
    5. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
4. 不同类型之间转换需要显式转换
    ```go
    var i int = 42
    var f float64 = float64(i)
    或者
    f := float64(i)
    //去掉float64 会报错
    ```
5. 关于常量：const声明,可以是字符、字符串、布尔或数字类型的值,不能用`:=`定义
#### 1.6 包和文件
1. 网友推荐的包目录结构如下：
```bash
dir      
  -- goWorkSpace1   #主要是为了区分自己的鼓捣的一些东西和工作上的项目
  -- goWorkSpace2   #需要把两个workspace都加入gopath
        -- bin
        -- pkg
        -- src                  
           -- myApp1    #src下最好每个项目一个目录
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp2
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp3
              -- .git
              -- models
              -- controllers
              -- main.go
```

2. 关于包路径和包名
    1. 同级目录下的文件不能定义不同package
    3. 一般的: 
        ```bash
        --config
            -- config.go    #假设config目录下有config.go文件
        ```
        config.go中的package名称~~必须~~最好和目录config一致，而文件名可以随便。main.go表示main包，文件名建议为main.go。（注：**不一致时，生成的.a文件名和目录名一致，这样，在import 时，应该是目录名，而引用包时，需要包名。例如：目录为myconfig，包名为config，则生产的静态包文件是：myconfig.a，引用该包：import “myconfig”，使用包中成员：config.LoadConfig()**）
    4. 简单总结就是:
        ```go
        package 最后一层目录名(最好)or其他名字
        import 源文件所在目录src后的完整路径名(go的import查找的是包的路径，并不是包名)
        //使用时最后一层目录名or其他名字来调用
        ```
    5. 可以用`./xxx`来import，这种方式不依赖GOPATH，但是不推荐
    6. GOPATH和GOPATH下的src目录不应该添加到源代码管理中
    7. 可执行命令的文件(比如hello.go)的包名必须是package main
### 1.x 注释
go的注释与C++保持一致
### 2. 数据类型
Go语言将数据类型分为四类：
1. 基础类型：包括数字、字符串和布尔型。
2. 复合类型(聚合)：通过组合简单类型，来表达更加复杂的数据结构，包括数组和结构体
3. 引用类型：包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用
4. 接口类型：就是接口
#### 2.1 基础数据类型
#### 2.2 复合数据类型
##### 2.2.3 map

#### 2.3 引用数据类型
### 3 流程控制
#### 3.1 for(go中唯一的循环)
1. 语法说明
    1. 除了不能用`()`外，其他跟c和java很像
    2. 可以省略分号，此时可以看做go的`while`
#### 3.2 if else
1. 语法
    1. 不能用`()`，其他很像c和java
    1. 跟 for 一样，`if` 语句可以在条件之前执行一个简单的语句。由这个语句定义的变量的作用域仅在 if 范围之内。
#### 3.3 switch
1. 语法
    1. ...
    1. 从上到下匹配，成功时停止
    3. 没有条件的switch等于`switch true`，从而可以用更清晰的形式来编写长的 if-then-else 链：
        ```go
        t := time.Now()
        switch {
        case t.Hour() < 12:
            fmt.Println("Good morning!")
        case t.Hour() < 17:
            fmt.Println("Good afternoon.")
        default:
            fmt.Println("Good evening.")
        }
        ```
### 4 函数
1. 基本语法
    1. 所有go函数以`func`开头,函数方法名首字母大写(?)，函数外的每个语句都必须以关键字开始(也就意味着简短声明表达式不能在函数外使用)
    2. 支持多返回值，返回值名称可作为文档使用，且可以像变量一样直接使用
2. go函数的大概结构
    Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。
#### 4.1 函数声明
1. 函数的类型被称为函数的标识符
1. 如果函数在声明时，包含返回值列表，则函数必须以return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环.
2. 函数实参通过值的方式传递，即形参是实参的拷贝，对形参修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。
4. 可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符，如:
    ```go
    package math
    func Sin(x float64) float //implemented in assembly language
    ```
#### 4.2 递归
1. 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题
#### 4.3 多返回值
1. 关于debug：调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值，如下，
    ```go
    log.Println(findLinks(url))
    links, err := findLinks(url)
    log.Println(links, err)
    ```
2. 关于函数命名：准确的变量名可以传达函数返回值的含义(比如长、宽、高等)，不过按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释
3. 关于bare return(裸返回)：如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。
    >当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。
#### 4.5 函数值
1. 关于第一类值(first-class values)和第二类值
    有些语言中function跟int, double的地位是一样的。这种语言就为函数是第一类值；而有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。(这里函数是已经是广义的了，用来表示代码code)。只能存储一个指向函数的指针，这种语言称为函数是第二类值。
2. 函数类型的零值是nil。函数值之间是不可比较的，但函数值可以与nil比较。调用值为nil的函数值会引起panic错误。
#### 4.6 匿名函数(anonymous function)
1. 定义：函数字面量(function literal)的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。
2. 匿名函数的优点:
    1. 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值，而且不必担心函数名冲突
    2. 更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量
3. 简单例子如下
    ```go
    // squares返回一个匿名函数。
    // 该匿名函数每次被调用时都会返回下一个数的平方。
    func squares() func() int {
        var x int
        return func() int {
            x++
            return x * x
        }
    }
    func main() {
        f := squares()
        fmt.Println(f()) // "1"
        fmt.Println(f()) // "4"
        fmt.Println(f()) // "9"
        fmt.Println(f()) // "16"
    }
    ```
#### 4.8 defered函数(待补充)
1. 语法：
2. 配合匿名函数
### 5. 方法
### 6. 接口
1. go的接口是非侵入式的，只要实现了接口里要求的全部方法，就实现了接口
    带来的优点是：
    1. 不用绘制类库的继承树图
    2. 不用纠结接口需要拆的多细
    3. 不用为了实现一个接口而专门导入一个包
2. 
### 7. Goroutines和Channels
#### 7.1 goroutine
是一种比线程更加轻盈、更省资源的协程.
### 8. 基于共享变量的并发
### 9. 包和工具
#### 9.1 包相关
#### 9.2 常用包
##### 9.2.1 fmt
1. [https://studygolang.com/articles/2644](https://studygolang.com/articles/2644)
2. `fmt.Errorf`函数使用`fmt.Sprintf`格式化错误信息并返回
#### 9.3 工具
### 10. 测试
### 11. 反射
### 12. 底层编程
### 13. 错误处理
Golang 没有传统的异常机制。
对于非致命的错误，Golang 使用返回值来报告(Golang 支持多返回值).
对于致命的错误，Golang 直接选择“崩溃”掉(当然也有恢复机制), 不过按照 Golang 的哲学，既然是致命错误，就应当挂掉。
还有 defer 关键字，用于将一个语句“绑定”到函数退出时执行，无论是通过各种途径退出，这可是 C/C++ 里面的大问题。
1. 任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。
2. 关于内置的error：
    内置的error是接口类型，可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息，如
    ```go
    fmt.Println(err)
    fmt.Printf("%v", err)
    ```
#### 13.1 错误处理策略(5种？)
1. 传播错误（最常用的方式）
    由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息
2. 重试
    如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
3. 输出错误信息并结束程序
    用于错误发生后，程序无法继续运行。这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非遇到了bug，才能在库函数中结束程序
    1. 关于错误信息的时间：
    log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。
        ```go
        if err := WaitForServer(url); err != nil {
            log.Fatalf("Site is down: %v\n", err)
        }
        ```
4. 只输出错误信息
    ```go
    //log包(log包中的所有函数会为没有换行符的字符串增加换行符)提供函数:log.Printf
    //或者标准错误流输出错误信息:fmt.Fprintf
    ```
5. 忽略掉错误
#### 13.2 go的错误处理方法
检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。
### 14 垃圾回收
Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。(java等也是？)
## 五. 问题
1. 因式分解
2. lua
3. 编程范式
4. Erlang风格的并发模型
5. go支持Erlang语言为代表的面向消息编程思想
6. 不清楚go的稳定性，所以目前很多公司还不太敢用
7. 从源码安装软件怎么操作？二进制发行版和安装版的区别？
8. return的几种用法
9. go省略返回值形参，只有形参类型的写法