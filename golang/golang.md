# golang
[TOC]
# 一 概述
## 1 简介
### 1.1 优点
1. 强大且完善的库（Batteries Included）
1. Go语言在语言层面解决软件工程问题的设计哲学
1. 编译成无依赖二进制:copy部署很方便,拷贝就能跑了.(这也是很多人选go的最大理由)
1. 协程
1. 稳定性:go提供了软件生命周期各个环节的工具(开发,测试,部署,维护等)
5. Go 语言支持交叉编译.比如说你可以在运行 Linux 系统的计算机上开发运行下 Windows 下运行的应用程序
6. 它是第一门完全支持 UTF-8 的编程语言.这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化
7. Go 语言可以在 Intel 或 ARM 处理器上运行，因此它也可以在安卓系统下运行

### 1.2 缺点
以下列出了go不支持的其他语言的一些特性和缺点,不过在未来的版本可能改善:
1. 语法不容易习惯
1. 不能用的变量写成`-`,不方便调试(?)
1. go的包管理:感觉不如npm好用
1. 没有存储过程(?)
1. 错误处理的代码多了很不爽
1. 为了简化设计，不支持函数重载和操作符重载
2. 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换
3. 不支持动态加载代码
4. 不支持动态链接库
5. 不支持泛型
6. 不支持断言
7. 不支持静态变量


### 1.3 适用场景和不适用场景
适用场景:
1. 高性能分布式系统
2. 游戏服务端
3. 复杂事件处理（CEP,Complex event processing）

不适用场景:
1. 因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件。

### 1.4 他人评价
更好的 c

go + java是不错的实践

深技术专栏作家 Matt Asay 在外媒上发文表示:究其原因，应该是经验的问题，在你拥有了老语言的使用经验后，使用新语言会变得更清晰明了。换句话说，如果你已经花了数年的时间去了解 Java ，那么应该会更容易理解 Go 有多优秀。

HackerRank 近日对约 4 万名开发者进行了调查，并发布了名为“2018 年开发者技能报告”:Go 虽然是一种很酷的语言，但它只占据了一个小小的位置，似乎并没有成为某种基础设施的最擅长的代码。也因此，它没有真正抓住年轻工程师的想象力。

Pike说:
1. 它至少在强度上比JavaScript高一级。Google自建Chrome浏览器，部分原因就是加速JavaScript和网页表现，而Google已经融合了本身的技术，如Native Client和Gears。
2. 我不认为我们能取代任何东西。我们只是创造出这个领域的另一个角色。

网友：Go语言标准库难以置信的强大，值得你花时间阅读它的代码，学习它实现的模式。

云风博客:我发现我花了四年时间锤炼自己用 C 语言构建系统的能力，试图找到一个规范，可以更好的编写软件。结果发现只是对 Go 的模仿。缺乏语言层面的支持，只能是一个拙劣的模仿。

华尔街见闻技术团队:
1. 调试工具强大:自带一些pprof包可以profile当前程序的CPU消耗、内存占用、锁状态、channel阻塞等，非常便利我们定位问题。
2. 有一些优秀的微服务框架:我们选用go-micro

## 2 历史
1. Go 语言本身是由 C 语言开发的，而不是 Go 语言.不过go从1.5开始就移除了"最后残余的C代码"实现了自举.

更新：Go语言的每次版本更新，都会在标准库环节增加强大的功能、提升性能或是提高使用上的便利性。每次版本更新，标准库也是改动最大的部分。

## 3 常识
### 3.1 未整理
1. Go语言的标准库（通常被称为语言自带的电池）
2. Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
3. Go语言反对函数和操作符重载（overload）
4. 支持匿名函数与闭包
6. 以囊地鼠（Gopher）作为它的吉祥物,Rob Pike的妻子 Renee French绘制的
8. 有C基础，学Golang非常轻松

### 3.1 go的哲学
1. 面向接口编程
2. 使用组合编程
3. 少即是多：“如果一个特性并不对解决任何问题有显著的价值，那么Go就不提供它”
4. 开放性，开源

### 3.2 go是用什么语言写的
参考[Golang本身是用什么语言写的？ - CNife的回答 - 知乎](https://www.zhihu.com/question/66944175/answer/248620046)
最开始是c和汇编,从1.5开始,go用语言实现了自己的编译器,即完成了自举,也就是全部都是用go实现的了.

### 3.3 语句后的分号
1. Go程序并不要求开发者在每个语句后面加上分号表示语句结束，这是与C和C++的一个明显不同之处。
2. Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。举个例子, 函数的左括号{必须和func函数声明在同一行上, 且位于末尾，不能独占一行，而在表达式x + y中，可在+后换行，不能在+前换行。

### 3.4 语句后的逗号
为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号,最后插入的逗号不会导致编译错误，这是Go编译器的一个特性.如,

```go
input := map[string]interface{}{
    "up_channel_id": ctx.Input.GetString("up_channel_id"),
    "page_index":    ctx.Input.GetString("page_index"),
    "page_size":     ctx.Input.GetString("page_size"),
}
//...
img.SetColorIndex(
    size+int(x*size+0.5), size+int(y*size+0.5),
    blackIndex, 
)
```

### 3.5 关于go的作者
1. Robert Griesemer：曾协助实现 Java 的 HotSpot 编译器和 JavaScript V8 引擎。
2. Rob Pike：曾是贝尔实验室的 Unix 团队和 Plan9 操作系统成员，与 Thompson 一起创造了 UTF-8 字符编码。
3. Ken Thompson，不用多说了，技术圣殿的人物，创造了 C 语言和 Unix，获得了 1983 年图灵奖和 1988 国家技术奖

### 3.6 空标识符（blank identifier）
即`_`（也就是下划线），它主要有两个作用：
1. 用于丢弃不需要使用的变量(任何类型都可以赋值给它，但任何赋给这个标识符的值都将被抛弃),被丢弃的值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算.
2. 导入包时，如果只想使用其中的`init()`而不希望把整个包导入，就可以用该符号

注意：`_`不可以单独和`:=`使用.

#### 3.6.1 点导入
如果导入包为一个点，那么可以不用加包名前缀来调用包中的方法。

### 3.7 简单语句（simple statement）
包括短变量声明、自增语句、赋值语句或函数调用

### 3.8 go语法定义里为什么把类型写在右边
参考[https://blog.golang.org/gos-declaration-syntax](https://blog.golang.org/gos-declaration-syntax),本人简单概括两点:（待验证）

1. c和java都是先写类型,是巧妙的语法思想，但更适合简单的类型。著名的混淆例子是声明一个函数指针：
    ```c
    int（* fp）（int a，int b）;
    //在这里，fp是一个指向函数的指针，因为如果你写表达式（* fp）（a，b）
    //你会调用一个返回int的函数。如果fp的论点之一本身就是一个函数呢？
    int（* fp）（int（* ff）（int x，int y），int b）
    //变得难以阅读
    ```
2. 类型和表达式语法的区别使得在Go中编写和调用闭包很容易：
    ```go
    sum：= func（a，b int）int {return a + b}（3,4）
    ```
### 3.9 rune,byte和string的关系
在Go当中 string底层是用byte数组存的，并且是不可以改变的。例如 `s:="Go编程" fmt.Println(len(s)) `输出结果应该是8因为中文字符是用3个字节存的。`len(string(rune('编')))`的结果是3.如果想要获得我们想要的情况的话，需要先转换为rune切片再使用内置的len函数,`fmt.Println(len([]rune(s)))`,结果就是4了。所以用string存储unicode的话，如果有中文，按下标是访问不到的，因为你只能得到一个byte。 要想访问中文的话，还是要用rune切片，这样就能下标表访问。

简单总结就是:rune 能操作 任何字符,byte 不支持中文的操作.

1. string和[]byte的异同

    从源码可知string主要是由[]byte构成.string不可变,每次值改变(重新分配内存空间),指针会指向新的字符串的内存地址,而[]byte值改变的时候指针不会移动,所以[]byte性能比string高.

3. 使用比较
    - string可以直接比较，而[]byte不可以，所以[]byte不可以当map的key值。
    - 因为无法修改string中的某个字符，需要粒度小到操作一个字符时，用[]byte。
    - string值不可为nil，所以如果你想要通过返回nil表达额外的含义，就用[]byte。
    - []byte切片这么灵活，想要用切片的特性就用[]byte。
    - 需要大量字符串处理的时候用[]byte，性能好很多。
注意他们之间的比较用`bytes.Equal(s1, s2) == 0`而不是`bytes.Compare(s1, s2) == 0`

### 3.11 2009-11-10 23:00:00 UTC
该日期是go的开源日期,可以看做是go的生日(?).

### 3.12 interface{}类型(待整理)
1. interface{}和其他类型比较的时候,是比较interface{}的实际类型.

### 3.13 程序退出的代码
程序正常退出的代码为 0 即 Program exited with code 0；如果程序因为异常而被终止，则会返回非零值

待补充

### 3.14 var、new()和make()的区别（难点）(待补充)
`new()`和`make()`最大的区别：`new()`只分配内存而不初始化，`make()`不但分配内存还做初始化。比如:
```golang
p := new([]int) //p == nil; with len and cap 0
v := make([]int, 10) // v is initialed with len 10, cap 50
fmt.Println(*p)        //输出[] 
fmt.Println(v)        //输出[0 0 0 0 0 0 0 0 0 0 0]  
```

以下为详细区别：
- `var`:没加等号的话称为“零值初始化”，虽然带有“初始化”三个字，但对三个特殊的引用类型（slice、map、channel）并没有初始化，只是赋值为nil，对其他类型则是正常赋值为对对应的零值并初始化。
- `new(type)`：为变量分配内存，将该内存置零但不初始化该内存，返回指针。对于值类型，它是零值初始化，和var一样；对于引用类型，它不等于nil（不知道为啥，和其他语言不同，有点难理解）。
- `make(type,args)`：分配内存，将内存置零并初始化。只能用于slice、map和channel，因为这三者在go里必须初始化才能使用。

### 3.15 三个点
它是语法糖，有两种用法:
1. 函数有多个不定参数
2. slice可以被打散进行传递

### 3.16 go源码文件
Go源码文件包括三种：命令源码文件、库源码文件和测试源码文件

## 4 文档
1. _Effective Go_(中文名《高效Go编程》)
2. Go语言大神亲述:历七劫方可成为程序员!（看完我怎么感觉有点像是在扯淡）：http://developer.51cto.com/art/201710/553448.htm
3. go命令教程，听说是干货：https://github.com/hyper0x/go_command_tutorial
4. 网友写的md，还没看过，待笔记：https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md

## 5 网址
1. 大神ASTA谢写的Go web编程gitbook，比较详细，应该很值得读：[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md)
2. go语言圣经中文网：[http://books.studygolang.com/gopl-zh/](http://books.studygolang.com/gopl-zh/)
3. 该网址可以找到社区写的package(?):[https://godoc.org](https://godoc.org)
4. go语言官方文档地址：https://golang.org/
    1. 比如想看runtime包，可以访问：https://golang.org/pkg/runtime/

## 6 相关工具
1. 基于web的postgresql数据库GUI工具：https://github.com/sosedoff/pgweb

# 二 安装配置
go的环境变量说明:
1. `$GOROOT`:表示Go的安装目录。一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径,并且会自动将`$GOROOT/bin`加入系统PATH?。go自带的工具命令都在`$GOROOT/bin`里面,`fmt`等基础包也在GOROOT中，所以可以直接`import`.自带的标准库包的位于`GOROOT/src`下,比如存放fmt包的源代码对应目录为`$GOROOT/src/fmt`.目录说明如下(仅了解就行):
    1. `/bin`：包含可执行文件，如：编译器，Go 工具
    1. `/doc`：包含示例程序，代码工具，本地文档等
    1. `/lib`：包含文档模版
    1. `/misc`：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例
    1. `/os_arch`：包含标准库的包的对象文件（.a）
    1. `/src`：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言）
    1. `/src/cmd`：包含 Go 和 C 的编译器和命令行脚本

2. `$GOPATH`:即工作区目录,安装后默认是`~/go`,必须包含三个子目录,bin,src和pkg.项目一般都是放在src下.注意最好不要将`$GOROOT`和`$GOPATH`设置在同一目录下.当安装了gocode和gopkgs等工具时，还会算上安装工具的目录；但是如果`import`的目录不在这两者当中，那么就会报错找不到，所以要把自己go代码的目录加入到GOPATH中,设置了GOPATH之后，`import`时就会去GOROOT和GOPATH中找；添加多个目录的时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，大部分情况下会是第一个路径优先，比如：查找包、go get的内容默认放在第一个目录下.
    1. `bin`:包含可执行文件.如编译器，Go 工具等
    2. `src`:源码文件
    3. `pkg`:包文件

3. `$GOARCH`:表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。
4. `$GOBIN`:表示编译器和链接器的安装位置，默认是`$GOROOT/bin`.一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

那么多个GOPATH的最佳实践是什么(待补充)

除了设置上面的几个环境变量，可能还需要将`$GOPATH/bin`添加到系统PATH里
## 1 windows
1. 下载安装

3. 配置GOROOT(C:\Go)并将%GOROOT%\bin)加入PATH中，不过现在go语言安装工具会自动帮我们加入进去.这样就可以在任意地方运行go开头的命令了

4. 配置GOPATH.默认是`~/go`,想修改的话在系统变量新增一个GOPATH就行.

5. 配置gobin(需不需要看情况)

## 2 mac
### 2.1 二进制发行版安装
1. 下载安装
2. 在~/.bash_profile中设置GOPATH等,然后`source ~/.bash_profile`.

    这里我遇到一个问题,就是上面的设置在新开shell中没有生效.因为zsh加载的是 ~/.zshrc文件，而 ‘.zshrc’ 文件中并没有定义任务环境变量,所以需要在~/.zshrc文件最后，增加一行:source ~/.bash_profile
3. 如果是vscode中开发go,可能还需要设置go.gopath,形如`"go.gopath": "/Users/xushike/work"`

### 2.2 homebrew（最推荐）
先查看go的版本，然后安装

## 3 linux
### 3.1 安装包（二进制发行版）安装(**推荐**)
1. 下载xxx.tar.gz，安装到`/usr/local`下:
```bash
#查看压缩文件内容
tar -ztvf xxx.tar.gz
#解压到目录下
sudo tar -zxvf xxx.tar.gz -C /usr/local 
```

2. 环境变量设置：需要设置GOROOT和GOPATH.
    - 设置GOROOT:
        1. 设置方式类似于JAVA_HOME，如`export GOROOT=$HOME/xxx`
        2. 把`$GOROOT/bin`加入PATH：`export PATH=$PATH:$GOROOT/bin`
        
    - 设置GOPATH：这个目录用来存放Go源码(src)，Go的可运行文件(bin)，以及相应的编译之后的包文件(pkg)
        >在go1.1到1.7，该变量必须设置，且不能和go安装目录一样;从1.8开始有默认值，在Unix上默认为`$HOME/go`,在Windows上默认为`%USERPROFILE%/go`

        1. 设置GOPATH(**最好不要和go安装目录相同**)
        2. 把GOPATH/bin加入环境变量 

3. 关于GOBIN（待验证）:
将`$GOPATH/bin`加入PATH中，这样可以方便的运行`go install`好的二进制程序。然而，当存在GOPATH中存在多个路径时，这种写法只会将最后一个路径跟上bin。在mac或linux下可以通过这种方式解决：
`${GOPATH//://bin:}/bin`

### 3.2 源码安装
### 3.3 第三方工具安装（apt、wget等）

# 三 基础
## 0 Go程序的执行（程序启动）顺序
如下（感觉还不够详细，待补充）：
1. 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
2. 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
3. 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。
4. 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

## 1 程序结构
### 1.1 命名
Go语言程序员推荐使用 驼峰式 命名

### 1.2 声明
Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

### 1.3 变量
#### 1.3.1 变量声明
其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
```go
//声明变量的方式1:一般是变量类型和初值类型不同时才使用
var 变量名字 类型 = 表达式
```

```go
//声明变量的方式2：零值初始化,也可用于多个变量是同一类型的情况，此时只写最后一个类型
var i int
var i, j, k int                 // int, int, int
//声明变量的方式3:一般用于同时声明多个变量，可省略类型，会自动判断
var b, f, s = true, 2.3, "four" // bool, float64, string
```

初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。例子如下：

```go
var f, err = os.Open(name) // os.Open returns a file and an error
```

在**函数内部**，有一种称为**简短变量声明**语句的形式可用于声明和初始化局部变量,可以简单理解为`:=`是声明且赋值,例子如下：

```go
//声明变量的方式4:简短变量声明(只能在函数内使用)
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
//这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用比如for语句的循环的初始化语句部分
i, j := 0, 1
```

注意：
1. 简短变量声明语句中必须至少要声明一个新的变量,对于其他已经声明过的变量，则只有赋值操作
2. 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

#### 1.3.2 变量的初始值
零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。
1. 数值类型变量对应的零值是0，
2. 布尔类型变量对应的零值是false，
3. 字符串类型对应的零值是空字符串

    注意:检查空字符串用`s == ""`而不是`len(s) == 0`
    
4. 指针,接口和引用类型（包括slice、map、chan和函数）变量对应的零值是nil。

    注意:检查slice,map或者channel的空值用`len(s) > 0`而不是`s != nil && len(s) > 0`
5. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
6. 当要声明一个变量或者结构体为零值时,go习惯使用var,这样更明确

4. 类型转换(难点)(待补充)
    1. 显式转换,语法形如`var a typeA = typeA(b)`,这种方式适合以下几种情况
        1. 一个取值范围较小的类型转换到一个取值范围较大的类型.
            1. int=>float64:`var f float64 = float64(i)`或者`f := float64(i)`
            2. string=>[]byte:`data := []byte(str)`
            3. []byte=>string:`str := string(bytes)`
        2. 具有相同字段名称，相同字段类型的结构体（tag可不一样）
        
    2. 具有相同底层类型的变量之间可以相互转换.如,

        ```go
        type IZ int
        var a IZ = 5
        c := int(a)
        d := IZ(c)
        ```

#### 1.3.3 赋值
1. 更有效的赋值写法,比如
    ```go
    count[x] = count[x] * scale // 数组、slice或map的元素赋值
    //下面的写法更有效，可以省去对变量表达式的重复计算
    count[x] *= scale
    ```

2. 元祖赋值：指同时更新多个变量的值,先计算右边再统一更新左边。好处是:
    - 对同时出现在两边的变量很有帮助
    - 可以使一系列琐碎赋值更加紧凑(特别是在for循环的初始化部分)

    但如果表达式太复杂的话，应该尽量避免过度使用元组赋值

3. 可赋值性：
    1. nil可以赋值给任何指针或引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换
    2. 对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。
    3. 隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句将隐式地将返回操作的值赋值给结果变量.
    
4. 匿名变量(没有名称的变量、类型或方法).可以避免定义一堆没用的变量,使代码看起来更加优雅清晰,写法形式如下,
        
    ```go
    func GetName() (firstName, lastName, nickName string) { 
        return "May", "Chan", "Chibi Maruko" 
    } 
    ```             

#### 1.3.4 变量的生命周期
对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，在局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

因为一个**变量的有效周期只取决于是否可达**，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

#### 1.3.5 变量的存储位置
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。圣经中的例子如下,
```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```
分析:f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。不过一般情况下编程不需要想这么多.

### 1.4 常量
使用`const`声明,只可以是字符串、布尔或数字类型的值,不能用`:=`定义.语法形如`const xxx [type] = xxx`,如

```go
const Pi = 3.14159
```

常量也允许使用并行赋值的形式,如：
```go
const beef, two, c = "eat", 2, "veg"
```

常量还可以用作枚举：
```go
const (
	Unknown = 0
	Female = 1
	Male = 2
)
```
#### 1.4.1 iota
参考:https://studygolang.com/articles/2192

最佳实践是:常量一般声明为MaxLength,而不是以下划线分隔MAX_LENGTH或者MAXLENGTH。

### 1.5 指针
指针是可见的内存地址.有些语言中(比如C)指针操作是完全不受约束的;而有些语言中(比如java)指针一般被处理为“引用”，除了到处传递这些指针之外,并不能做其他操作.Go平衡了两者,可以操作指针,但不能对指针进行运算，也就是不能像c语言里可以对指针进行加或减操作。`&`操作符可以返回一个变量的内存地址，`*`操作符可以获取指针指向的变量内容,`*type`表示指针的类型.

并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。(?)

指针是实现标准库中flag包的关键技术.

指针最重要的应用在于:在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）

使用方法:如果用“var x int”声明语句声明一个x变量，那么`&x`表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是`*int`，指针被称之为“指向int类型的指针”,同时`*p`表达式对应p指针指向的变量的值.操作`*p`只是增加p指向的变量的值，并不改变p指针.

还可以使用`new`(注意`new`在go中目前只是预定义函数,而不是关键字)来声明变量,作用和普通声明一样,如`p := new(int)`.但是new用得比较少,因为字面量的方式创建指针更方便.每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

指针的比较:指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

关于go和C/C++语言返回函数中局部变量的指针:
1. 在C/C++中,局部变量分配在栈里,函数返回后，局部变量是被系统自动回收的(其他好几种语言也是这样).返回局部变量的指针是不安全的,但返回局部变量的值是安全的,因为返回的是值的副本
2. 在go中,局部变量可能分配到栈or堆中,而且两者都可以返回.具体参考垃圾回收的堆栈分配笔记

### 1.6 类型
新声明的类型提供了一个方法(我还不知道什么方法,底层的一些东西?)，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的,例子如下,

```go
type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度
//Celsius和Fahrenheit是不同的类型,即使他们的底层类型都是float64
```

底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的.
比较运算符==和<也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：
```go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // "true"
fmt.Println(f >= 0)          // "true"
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"!
//最后一个测试为真的原因是因为c和g都是零值,Celsius(f)是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。
```

1. 命名的类型的优点
    - 可以提供书写方便,如果是复杂的类型将会简洁很多，比如结构体类型
    - 为该类型的值定义新的行为

### 1.9 包
一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包.(?)

1. 网友推荐的包目录结构如下：
```bash
dir      
  -- goWorkSpace1   #主要是为了区分自己的鼓捣的一些东西和工作上的项目
  -- goWorkSpace2   #需要把两个workspace都加入gopath
        -- bin
        -- pkg
        -- src                  
           -- myApp1    #src下最好每个项目一个目录
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp2
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp3
              -- .git
              -- models
              -- controllers
              -- main.go
```

2. 包路径

    如果包名以`./`开头,则是相对路径;以`/`开头,则在绝对路径中查找;不是以`.`或`/`开头.则在全局文件中查找.go推荐使用相对于$GOPATH/src的路径来导入包;也可以用相对当前位置的路径来import，这种方式不依赖GOPATH，但是不推荐.

3. 包导入

    go并不要求包名是唯一的,但是按照惯例，一个包的名字和包的导入路径的最后一个字段相同.比如导入包`import gopl.io/ch2/tempconv`,则包名是`tempconv`.
    1. 导入包的重命名:如果两个包的名字一样,就需要用到包的重命名,如

        ```go
        import (
            "crypto/rand"
            mrand "math/rand" // alternative name mrand avoids conflict
        )
        ```

    2. 导入包的分组:通过添加空行来分组,好处是更容易区分,同时go的工具会对每个分组单独排序.如

        ```go
        import (
            "fmt"
            "html/template"
            "os"

            "golang.org/x/net/html"
            "golang.org/x/net/ipv4"
        )
        ```

    3. 包的匿名导入

        有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的`init()`初始化函数,此时可以使用空白标识符,如`import _ "image/png"`

    4. 包的初始化

        导入包的时候一级变量和`init()`会被初始化,所以可以把初始化的东西写在`init()`方法中.

    5. 目录下同级的go文件package必须和包名一样,比如,

        ```bash
        --config
            -- file.go    #假设config目录下有config.go文件
        ```
        file.go中的package名称~~必须~~最好是`config`，而文件名可以随便。

        注意:最外层的go文件的package必须是main,最外层的go文件有多个,但方法名为main只能有一个.

    6. GOPATH和GOPATH下的src目录不应该添加到源代码管理中

3. 包依赖:Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为`.o`的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。例子如,

```go
A.go 依赖 B.go，而 B.go 又依赖 C.go：
编译 C.go, B.go, 然后是 A.go.
为了编译 A.go, 编译器读取的是 B.o 而不是 C.o.
这种机制对于编译大型的项目时可以显著地提升编译速度。
```

4. 关于包的初始化
    1. 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了
    2. 可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数(但有的地方说只能一个?)

5. 可见性规则

    当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。

### 1.10 作用域
go的作用域和生命周期是不同的概念
1. go的三个流程控制语句紧跟的初始化块声明的变量,其作用域和声明在语句`{}`中变量一样.
2. 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。

## 2 数据类型
Go语言将数据类型分为四类：
1. 基础类型：包括数字、字符串和布尔型。
2. 复合类型(聚合)：通过组合简单类型，来表达更加复杂的数据结构，包括数组和结构体
3. 引用类型：包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用
4. 接口类型：就是接口

不过有的地方将其分为三类,还可以有自定义类型,而且函数也可以是一个确定的类型.总之有空再整理吧.

### 2.1 基础数据类型
包含int、float、bool、string

#### 2.1.1 整数
大概可以分为以下几种类型：
有基于架构的类型，例如：int、uint 和 uintptr.这些类型的长度都是根据运行程序所在的操作系统类型所决定的：int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。uintptr 的长度被设定为足够存放一个指针即可。
1. 查看int类型的位数`strconv.IntSize`，在64位机器上会返回64。也可以根据操作系统架构来判断，比如`runtime.GOARCH`

与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：
整数：
int8（-128 -> 127）
int16（-32768 -> 32767）
int32（-2,147,483,648 -> 2,147,483,647）
int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）

无符号整数：
uint8（0 -> 255）
uint16（0 -> 65,535）
uint32（0 -> 4,294,967,295）
uint64（0 -> 18,446,744,073,709,551,615）

字符类型byte:严格来说，字符并不是 Go 语言的一个类型，字符只是整数的特殊用例。byte 类型是 uint8 的别名，只占用 1 个字节的传统 ASCII 编码.字符使用单引号括起来。几种声明方法如下:

```go
// 下面三种声明方法是等价的
var ch byte = 'A'
var ch byte = 65
var ch byte = '\x41'
```

注意：
1. 直接整数

#### 2.1.2 浮点数
你应该尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。

#### 2.1.3 字符串
分为普通字符串和raw字符串,raw字符串和js6中的模板字符串有点像.

raw字符串:用反引号包裹.正则表达式中使用raw字符串更简洁

字符串截取:可以用类似切片的方式来截取,形如`str[indexA:indexB]`,取出来左闭右开的子字符串.比如
```golang
str := "123456"
str[0:3] // "123"
str[3:] // "456"
str3 := str[6:] // 特别的，如果indexA是字符串的长度，此时str3 == ""为true
```

#### 2.1.4 布尔bool
对于布尔值的好的命名能够很好地提升代码的可读性，例如以 is 或者 Is 开头的 isSorted、isFinished、isVisible，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的`unicode.IsDigit(ch)`

### 2.2 复合(结构化)数据类型
包含array、slice、map、struct、channel.

#### 2.2.1 数组
特点：元素占用内存相同且连续，所以访问元素速度很快.go数组的元素必须是同一个类型,没有指定值的元素默认是零值初始化.注意go的数组是值类型,这点和不少编程语言不一样，比如 js/C/C++ 中是指向首元素的指针。获取go数组的引用可以使用`&`操作符。

数组声明:
1. 使用字面量:`arr := [5]int{1,2,,5,5,6}`
    1. 声明空数组（零值初始化）：形如`var arr [5]int`或者`arr := [3]int{}`,声明了一个长度为5的int类型的空数组,所有元素被初始化为0
3. 自动计算长度，注意三个点必须要有，否则就是切片了:如`arr := [...]int{1,3,5}`，或者`arr := [...]int{2:5,3:6}`
4. 指定特定元素的值:`arr := [5]int{2:5,3:6}`，或者`arr := [...]int{2:5,3:6}`
5. 使用`new()`：如`arr := new([5]int)`，注意此时arr的类型是*[5]int

数组的操作：
1. 数组的读写/存取:
    1. 对数组中元素的访问和赋值：形如`array[num]`。
    2. 对整个数组赋值：只有类型和大小一样的数组才能相互赋值。
2. 数组的长度和容量：数组的长度和容量是相等的，使用`cap()`和 `len()`函数
3. 数组的合并（待补充）
4. 在函数间传递数组:可以传递值也可以传递指针，后者只需要在栈上开辟8字节的内存，性能更好，但是对指针的改动会影响共享内存。
5. 遍历数组:普通for循环和`for range`

#### 2.2.2 切片
切片可看作go对数组抽象后的类似动态数组的集合.是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）.多个切片如果表示同一个数组的片段，它们可以共享数据,因此一个切片和相关数组的其他切片是共享存储的，如果修改该数组，所以关联该数组的切片都会受影响。但切片的容量发生变化时，会重新分配地址，此时切片和原底级数组的关联就会断开。例子如下：

```golang
a := [...]int{1, 2, 3, 4, 5}
s1 := a[:]
s2 := a[:]
s1[0] = 10
fmt.Println(a[:]) // [10,2,3,4,5]  修改切片会影响到底级数组，反之亦然
s2[0] = 20
fmt.Println(s1) // [20,2,3,4,5]  修改切片会影响到基于同一底级数组的切片

s1 = append(s1, []int{6, 7}...) //append 时容量不够时会导致重新分配内存，与原底级数组关系断开
s1[0] = 100
fmt.Println(s1)   // [100,2,3,4,5,6,7]
fmt.Println(a[:]) //[20,2,3,4,5]
fmt.Println(s2)   //[20,2,3,4,5]
```

切片的存储能力（capacity）：可以理解为最大容纳元素个数，与数组不同，切片的存储能力是可以大于它的长度的，最大容纳元素个数减去当前容纳元素个数剩下的空间是隐藏的，不能直接使用。如果要往隐藏空间中新增元素，使用`append()`函数。

切片的声明:
```go
//1.使用内置make函数
slice := make([]string,5)
//如果只指定长度，那么容量和长度相等,也可以分开指定，但必须容量>长度
slice := make([]int,4,8)

//2.使用切片字面量来声明切片,此时长度和容量也是相等的
slice := []string{"a","b","c"}//长度和容量都是3

//3.使用索引声明切片
slice := []stirng{99:"hello"}//长度和容量是100

//4.使用切片创建切片，有几个地方需要注意：选择范围不能超过oldSlice的容量，否则报错；newSlice的容量大小是oldSlice的容量大小减去复制时的起始角标，和终止角标无关，比如下面这个newSlice的容量就是5-1=4
oldSlice := []int{10,20,30,40,50}
newSlice := oldSlice[1:3]//newlice的长度为2，容量为4，且和slice同一截数组

//5.使用三个索引创建切片，第三个参数表示容量，是可选的，不写则大小跟元素个数一样
slice := []string{"a","b","c","d","e"}
newSlice := slice[1:3:4]//newSlice的长度2，容量为3
newSlice2 := slice[5:] //特别的，如果indexA是slice的长度，那么newSlice2是长度为0的非nil切片

//6.基于数组创建切片
array := [...]int{1,2,3}
newSlice := array[m:n]

//其他：声明空切片,可用于表示空集合
slice := make([]string,0)
slice := []stirng{}
```
注意:
1. 使用切片字面量的时候，只要`[]`里有值，就不是切片而是数组了
2. 声明空的slice应该使用`var t []string`而不是`t := []string{}`,前者声明了一个nil slice而后者是一个长度为0的非nil的slice

切片的操作：
1. 往切片末尾追加元素或切片，使用内置的`append()`，该函数会自动处理存储空间不足的问题。追加元素使用内置的`append(slice,ele1,ele2,...,eleN)`函数，追加切片要写成`append(slice1,slice2...)`，这三个点的意思是把slice2所有元素打散后传递给`append()`，这是由于`append()`从第二个参数起的所有参数都必须是待附加的单个元素。:
    1. 当每次容量不够的时候，`append()`就会分配一个新的数组，所以可以通过设置长度和容量一样的切片来保证第一次`append()`分配的是新数组
    2. 容量<1000时，每次扩容是翻倍；超过1000，每次增加25%
2. 切片中元素的插入、删除和替换，go没有提供直接在切片中间插入/删除元素的方法，所以只有使用子切片的方法来实现，而且切片这种数据结构本身也不适合频繁的插入和删除：
    1. 删除元素：可以使用：`s2=append(s1[:index],s1[index+1:]...)`
    2. 插入元素：创建临时切片保存后面的部分，然后类似上面那样。。。
    3. 替换元素：`slice[num]`用于单个元素，`append()`用于单个或多个元素，例子如下

        ```golang
        append(slice1[:index], ele)
        // 当index<slice1的容量时，原index位置的元素被替换成ele；当index>=slice1时，返回的是一个新的切片，对slice1没有影响。
        ```
3. 切片的迭代，和数组一样:
    1.  使用关键字`range`,第一个返回值是索引，第二个返回值是值的副本

        ```go
        for index,value := range slice{
            ...
        }
        ```
    2. 也可用普通的for循环,如

        ```go
        for i:=0; i < len(slice); i++｛
            //...
        }
        ```
4. 切片的复制：使用內建的`copy()`是最佳实践，形如`copy(slice1,slice2)`，它会将slice2中的元素复制到slice1中，复制的元素个数取决于两个切片的长度中最小的那个。例子如下：

    ```golang
    arraySlice1 := []int{1, 2, 3, 4, 5}
	arraySlice2 := []int{5, 4, 3}
	copy(arraySlice2, arraySlice1) // 只会复制arraySlice1的前3个元素到arraySlice2中
	arraySlice3 := []int{1, 2, 3, 4, 5}
	arraySlice4 := []int{5, 4, 3}
	copy(arraySlice3, arraySlice4) // 只会复制arraySlice4的3个元素到arraySlice3的前3个位置
	fmt.Println(arraySlice1)
	fmt.Println(arraySlice2)
	fmt.Println(arraySlice3)
	fmt.Println(arraySlice4)
    ```
5. 在函数间传递切片:传递的是切片本身(64位上24字节)，本人实测传递规则类似于JS数组，而且查看切片的结构体也可以知道是相似的。
6. 切片的长度和容量:`len()`:返回切片的长度，`cap()`:返回切片的容量

#### 2.2.3 映射/字典map
map是存储无序键值对的集合,map强大的地方在于可以根据键快速检索到值(对集合元素，提供常数时间的存、取或测试操作).go里面map的键可以是任意类型,只要其值可以用"=="比较,最常用的字符串;值则可以是任意类型.从功能和实现上说，Go的map类似于Java语言中的HashMap，Python语言中的dict，Lua语言中的table，他们通常使用hash实现。go的map是线程不安全的，虽然在很多语言里map也是不安全的，但是开协程这么容易的go居然不提供线程安全的map，这点值得吐槽。因为slice、map和channel必须初始化才能使用，所以对于多层map，每层都必须初始化才能使用那一层，比如：
```golang
m := make(map[string]map[int]interface{})
//此时只是第一层被初始化了，要想使用第二层，必须初始化第二层
m1 := make(map[int]interface{})
m["m1"] = m1
```

声明方法:
1. "零值初始化"声明:`var map1 map[key_type]value_type`,这种声明方式声明后不能直接赋值，因为没有初始化
2. 初始化为零值的声明`var map1 map[key_type]value_type{}`：似乎等价于`map1 := make(map[key_type]value_type)`
2. 指定容量的声明:`map2 := make(map[string]float32, 100)`，容量是可选的
    ```golang
    // 声明值为func() int类型的map
    mf := map[int]func() int{
        1: func() int { return 10 },
        2: func() int { return 20 },
        5: func() int { return 50 },
    }
    fmt.Println(mf)
    ```

常用操作:
1. 判断某个key是否存在:`_, ok := map1[key1]` // 如果key1存在则ok == true，否则ok为false
2. 从 map中删除key:`delete(map1, key1)`,如果 key1 不存在，该操作不会产生错误。
3. 从map中获取key的值，有两种方式，但应该只使用逗号ok这种：
    1. 最佳实践是使用逗号ok模式：`_,ok := map1[key1]`，ok表示是否存在这个key1，ok为true，再取值
    2. 直接取值`map1[key1]`：如果值存在则返回该值，不存在则返回对应数据类型的零值。

#### 2.2.4 结构体
为什么需要结构体：当需要定义一个类型，它由一系列属性组成，每个属性都有自己的类型和值的时候，就应该使用结构体，它把数据聚集在一起。然后可以访问这些数据，就好像它是一个独立实体的一部分。结构体是复合类型（composite types）也是值类型，因此可以通过 `new()` 函数来创建.组成结构体类型的数据称为 字段（fields），每个字段都有一个类型（可以是任意类型，甚至是结构体类型）和一个名字；在一个结构体中，字段名字必须是唯一的。使用`var`和`new()`零值初始化结构体时，结构体内各字段会被初始化为对应类型的零值。。结构体是自定义类型里比较特殊的类型。

带接收者的函数：go的结构体跟面向对象的编程语言中一个无方法的轻量级类一样，它在go里有着重要的地位，但Go中没有类的概念，要实现类的方法的功能需要使用带接收者的函数。

继承：包含这个匿名字段的struct能调用匿名字段的函数和字段

重载：比如下面的Student和Human都有phone字段，那么访问Student中的phone用`student.phone`,访问student中Human的phone用`student.human.phone`,对于函数也是一样。

注：
1. 数组也可以看作是一种结构体类型，不过它使用下标而不是具名的字段。
2. 在 C 家族的编程语言中名字也是 struct

结构体声明方法：
```golang
// 方法1：普通定义
type Human struct {
    name string
    age int
    weight int
    phone string
}

// 方法2：匿名字段/嵌入字段：只提类型，而不写字段名，此时新的结构体隐式引入了该类型的所有字段和函数(如果有的话)，这里的类型包括所有自定义类型和内置类型
type Student struct {
    Human  // 匿名字段，那么默认Student就包含了Human的所有字段和函数
    speciality string
    phone string
}

// 方法3：匿名结构体:只创建结构体变量而没有定义新的结构体类型，因为没有类型，所以对它的赋值似乎只能使用选择器的方法
emp3 := struct {
    firstName, lastName string
    age, salary         int
}{
    firstName: "Andreah",
    lastName:  "Nikola",
    age:       31,
    salary:    5000,
}

fmt.Println("Employee 3", emp3)// 输出:Employee 3 {Andreah Nikola 31 5000}
```

赋值的几种方法:
```golang
// 方法1：选择器
var s T 
s.a = 5
s.b = 8

// 方法2：基于new()实现
a := new(struct1)
ms := &struct1{10, 15.5, "Chris"} //底层仍然是调用 new ()实现的

// 方法3：混合字面量语法
a := struct1{}
ms := struct1{10, 15.5, "Chris"}
human := Human{name:"tom"}
```

选择器（selector）：无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的选择器符（selector-notation） 来引用结构体的字段。语法形如`structname.fieldname = value`。好处是不用像 C++ 中那样需要使用 -> 操作符，因为Go 会自动做了这样的转换。

结构体的内存布局：Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。不像 Java 中的引用类型，一个对象和它里面包含的对象可能会在不同的内存空间中，这点和 Go 语言中的指针很像

递归结构体：（待补充）比如二叉树

结构体转换：Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，它们可以互相转换，同时需要注意其中非法赋值或转换引起的编译错误。（待补充）

##### 2.2.4.1 带接收者的函数
方法/函数接收者(Receiver)：Receiver 的名称应该缩写，一般使用一个或者两个字符作为Receiver的名称，如`func (f foo) method() {...}`;如果方法中没有使用receiver,还可以省略receiver name,这样更清晰的表明方法中没有使用它:`func (foo) method() {...}`。如果函数的接收者不一样，name方法就不一样。

函数接收者的类型：函数接收者可以是值类型也可以是指针类型，可以把函数接收者看作函数的第一个参数，所以值类型时操作的是副本，指针类型操作的是实例对象。用Rob Pike的话来说就是："A method is a function with an implicit first argument, called a receiver."。

### 2.3 用户自定义类型
自定义类型：使用`type`关键字基于已有的类型来声明新的类型，实际上只是定义了一个别名。struct是自定义类型的一个特殊类型。

声明：比如
```golang
type ages int

type money float32

type months map[string]int
```

#### 2.3.2 基于已有的类型
如`type doration int64`,此时int64是doration的基础类型,但是go并不认为doration和int64是同一个类型


## 3 流程控制
go的三个流程控制语句后都可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用.比如紧跟一个简短变量声明,好处是:
- 让代码更加简单
- 限制这个变量的作用域(易忘点)

go的三个流程控制语句后的条件都不需要加`()`

### 3.1 for(go中唯一的循环)
go的for循环主要有两种：普通for循环和for range。

普通for循环：用法如下,其中initalization可选,如果有,则必须为简单语句;condition也是可选的,是一个布尔表达式，其值在每次循环迭代开始时计算,如果为true则执行循环体语句;post语句也是可选的,在循环体执行结束后执行,之后再次对conditon求值,condition值为false时，循环结束.

```go
for initialization; condition; post {
    // zero or more statements
}
```

for range：主要是遍历数组,切片,字符串等，注意其中的ele是xxx里元素的副本，如下

```go
for index,ele := range xxx {
    //...
}
```

注意：
1. for后面的三个语句(initialization; condition; post)都可以省略，此时可以看做go的`while`
2. 和其它语言中的`break`和`continue`一样，`break`会中断当前的循环，并开始执行循环之后的内容，而`continue`会中跳过当前循环，并开始执行下一次循环。
3. 实测，对于本身就是引用类型的变量，比如slice、map等，这是的xxx不能是这些变量的指针，比如&slice、&map
### 3.2 if else

### 3.3 switch
1. 语法
    1. 从上到下匹配，成功时停止;不需要显式写上`break`,因为匹配某个`case`并执行完成后会自动退出`switch`;
    2. 没有条件的switch等于`switch true`，这种形式叫做无tag switch(tagless switch),可以更清晰的用来编写长的 if-then-else 链：

        ```go
        t := time.Now()
        switch {
        case t.Hour() < 12:
            fmt.Println("Good morning!")
        case t.Hour() < 17:
            fmt.Println("Good afternoon.")
        default:
            fmt.Println("Good evening.")
        }
        ```

    3. `fallthrough`

        该关键字很少用.如果在`case`执行语句末尾加上该关键字,该`case`执行完成后不会退出,而是直接执行下一个`case`(跳过下一个`case`的判断)里的语句,如,

        ```go
        switch {
        case false:
                fmt.Println("The integer was <= 4")
                fallthrough
        case true:
                fmt.Println("The integer was <= 5")
                fallthrough
        case false:
                fmt.Println("The integer was <= 6")
                fallthrough
        case true:
                fmt.Println("The integer was <= 7")
        case false:
                fmt.Println("The integer was <= 8")
                fallthrough
        default:
                fmt.Println("default case")
        }
        ```
2. `switch`中的`continue`,`break`


## 4 函数
基本语法:
1. 所有go函数以`func`开头,函数方法名首字母大写(?)，函数外的每个语句都必须以关键字开始(也就意味着简短声明表达式不能在函数外使用)
2. 支持多返回值，返回值名称可作为文档使用，且可以像变量一样直接使用

函数的命名:返回某个对象的函数或方法的名称一般都是使用名词，没有`Get...`之类的字符，如果是用于修改某个对象，则使用`SetName`

go函数的大概结构:Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。

### 4.1 函数声明
1. 函数的类型被称为函数的标识符
1. 如果函数在声明时，包含返回值列表，则函数必须以return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环.
2. 函数实参通过值的方式传递，即形参是实参的拷贝，对形参修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。
4. 可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符，如:
    ```go
    package math
    func Sin(x float64) float //implemented in assembly language
    ```

### 4.2 递归
1. 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题

### 4.3 多返回值
函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号()将它们括起来，如：

```go
func FunctionName (a typea, b typeb) (t1 type1, t2 type2){
    ...
    return var1, var2
}
```

函数返回值的命名：准确的变量名可以传达函数返回值的含义(比如长、宽、高等)，不过按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释

关于debug：调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值，如下，

```go
log.Println(findLinks(url))
links, err := findLinks(url)
log.Println(links, err)
```

关于bare return(裸返回)：如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。
>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。

### 4.5 函数值
第一类值(first-class values)和第二类值:有些语言中function跟int, double的地位是一样的。这种语言就为函数是第一类值；而有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。(这里函数是已经是广义的了，用来表示代码code)。只能存储一个指向函数的指针，这种语言称为函数是第二类值。

函数类型的零值是nil。函数值之间是不可比较的，但函数值可以与nil比较。调用值为nil的函数值会引起panic错误。

### 4.6 匿名函数(anonymous function)
定义：函数字面量(function literal)的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值称为匿名函数（anonymous function）.

匿名函数的优点:
1. 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值，而且不必担心函数名冲突
2. 最重要的是:通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量.并且go会自动识别被引用的变量,将其分配到堆中.

基本用法,例子1如下:
```go
// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```

和js闭包的对比:个人觉得,两者在功能上是差不多的,只是写法上有一点儿不同.可能因为go要声明返回值,所以被返回的函数只能以匿名函数的方式声明,但是js用js的函数声明(function declaration)来定义被返回的函数.

### 4.8 defered函数(待补充)
1. 语法：
2. 配合匿名函数

## 5. 方法
关于方法的接收者选择：
1. 要由接收者类型的本质来决定,感觉有点复杂,简单说就是看使用情况:对于内置类型,基本都是值接收者(?),对于结构类型就要看情况了
2. 例外是需要让类型值符合某个接口的时候

回调的简单例子，感觉像是提供一个接口让外部去实现：
```golang
package main 
import "fmt" 
type Callback func (x, y int) int 
func main() { 
 x, y := 1, 2 
 fmt.Println(test(x, y, add)) 
} 
func test(x, y int, callback Callback) int { 
 return callback(x, y) 
} 
func add(x, y int) int { 
 return x + y 
}
```

## 6. 接口
1. go的接口是非侵入式的，只要实现了接口里要求的全部方法，就实现了接口
    带来的优点是：
    1. 不用绘制类库的继承树图
    2. 不用纠结接口需要拆的多细
    3. 不用为了实现一个接口而专门导入一个包
2. 
## 7 Goroutines和Channels
### 未整理
1. 网友:goroutine 并不是 “把异步回调的代码用同步的方式来写”。而是在用户空间实现了一个 M 对 N 的调度器。 
简单来讲，异步回调一般只开一个线程，有任务了之后会把让这个线程去执行这个任务，无法利用多核。 
而 goroutine 会根据机器的运行情况开 N 个操作系统级别的线程，然后把 M 个用户级别的 goroutine 调度到这 N 个线程上。 
golang 团队一直引以为傲的就是这个 M 对 N 的调度器，这种 M 对 N 调度器在业界也算是比较先进的。
2. 网友:协程不是异步回调，协程是状态的保存和切换，这种思想很容易写出异步代码，实现同样的异步功能， c++或者 java 之类的写到你想吐

### 7.1 goroutine
是一种比线程更加轻盈、更省资源的协程.使用 4K 的栈内存就可以在堆中创建它们。因为创建非常廉价，必要的时候可以轻松创建并运行大量的协程（在同一个地址空间中 100,000 个连续的协程）。协程的栈会根据需要进行伸缩，从而动态的增加（或缩减）内存的使用，不会出现栈溢出，所以coder不用关心栈的大小；栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。Go 运行时可以聪明的意识到哪些协程被阻塞了，暂时搁置它们并处理其他协程。

存在两种并发方式：确定性的（明确定义排序）和非确定性的（加锁/互斥从而未定义排序）。Go 的协程和通道理所当然的支持确定性的并发方式（例如通道具有一个 sender 和一个 receiver）

实现方式：协程是通过使用关键字 go 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数。协程可以在程序初始化的过程中运行（在 init() 函数中）。main（）函数也可以看成一个协程。

在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 runtime.Gosched()：这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 Gosched() 可以使计算均匀分布，使通信不至于迟迟得不到响应。

协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序。

main() 退出时，main()中创建的协程会随着程序的结束而消亡

使用场景：
1. 比如在一个非常长的数组中查找一个元素。

常用操作：
1. 停止协程：`runtime.Goexit()`，协程可以通过调用该方法来停止，尽管这样做几乎没有必要。

### 7.2 channel
为什么需要channel：一般情况下，协程是独立的，之间没有通信，而channel就是用于协程之间的通信，它可以传输类型化数据，在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争。 数据的所有权（可以读写数据的能力）也因此被传递。所以channel有两个作用：
1. 值的交换
2. 默认是同步的，保证了两个计算（协程）任何时候都是可知状态

channel的特点：channel只能传输一种类型（支持所有类型，甚至chan类型）的数据，它实际上是类型化消息的队列，是先进先出（FIFO）的结构，是引用类型，使用`make()`函数创建。如果使用零值初始化创建则是nil，会一直阻塞，所以最好用`make()`函数创建。

channel的声明。分有缓冲和无缓冲两种，buffer为0或者没有时是无缓冲通道（unbuffered channel），大于0时是有缓冲通道（buffered channel）。无缓冲通道用于顺序执行、同步，缓冲通道通常用来处理异步事件，只要往里面扔就行了，缓冲使程序更具有伸缩性（scalable）。可以使用内置`cap()`函数查看缓冲容量，`len()`查看当前元素个数。为了可读性，通道的命名通常以 ch 开头或者包含 chan：
1. 无缓冲通道，只能包含一个元素，容量为0，读和写同时准备好了，channel才会开始通信，只有读或者写，则会一直阻塞：形如`var ch chan datatype`或`ch = make(chan datatype)`，如`ch1 := make(chan int)`
2. 有缓冲通道，写数据时，直到写满为止才会阻塞，而读则是直到为channel为空时才会阻塞.：形如`ch := make(chan datatype, buffer)`,其中buffer是缓冲容量，即元素个数，与元素类型无关。

channel的方向。默认是双向的，可以用注解来表示只发送或者只接收：
1. 只接收：`var recv_only <-chan int`
2. 只发送：`var send_only chan<- int`

关于chan类型的chan：（待补充）

channel的发送和接收。使用通信操作符`<-`。通道的发送和接收操作都是自动的，一般两个协程需要通信的话，我们是把channel作为参数传给协程。当channel被装满之后如果无协程接收，则channel的发送操作变成阻塞的，此时无法再往里面发送，同理，如果channel是空的且没有协程往里面发送，则它的接收操作是阻塞的：
1. 往channel中发送数据，此时的协程可以称为生产者：形如`ch <- int`，比如`ch1 <- 100`
2. 从channel中接收数据，有两种方式，此时的协程可以称为消费者：
    1. 接收并赋值：如`int1 := <- ch1`
    2. 直接获取通道的（下一个）值：如`<- ch`,可以不用`_`去接收，该值会被丢弃

关闭channel。只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。关闭方法有以下几种：（待补充）
1. 直接使用`close(ch)`或者加上defer语句：`defer close(ch)`
2. 使用ok判断：`v, ok := <-ch   // ok is true if v received value`
3. 可以使用`for range`来遍历通道，它会自动判断通道是否关闭

信号量模式：（待补充）

关于main协程和其他协程共同操作channel的死锁错误，分接收和发送两种情况，稍微有点复杂，重在理解：
1. 如果main协程要从channel中接收值，执行到这一步时main协程会判断之前声明的协程里是否有等次数的往channel中发送值的方法（这里等次数的意思是，如果接收了n（n>0）次值，那么发送值的次数要>=n），如果有则程序继续执行，如果没有则会在第n次接收前抛出如下错误：

    ```goalng
    fatal error: all goroutines are asleep - deadlock!
    chan receive (nil chan)...
    ```
2. 如果main协程要往channel中发送值，执行到这一步时，会判断之前声明的协程里是否有等次数的从channel中接收值的方法（这里等次数的意思是，如果发送了n（n>0）次值，那么接收值的次数要>=n），如果有，则程序继续运行，如果没有则会在第n次发送前抛出如下错误，

    ```golang
    fatal error: all goroutines are asleep - deadlock!
    .. [chan send]:
    ```

注意：
1. 如果移除操作channel的协程的go关键字，程序无法运行，运行时会抛出死锁错误，似乎和main中操作channel的死锁错误差不错。
2. 不要使用打印状态来表明通道的发送和接收顺序，因为打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。可能是下面的例子（本人暂时也不太确定是不是下面这个例子），后面输出的数字可能比前面小，

    ```golang
    func main() {
        var ch chan int
        for i := 0; i < 20; i++ {
            go func(i int) {
                fmt.Println("num:", i)
            }(i)
        }
    }
    //输出结果
    num: 6
    num: 7
    num: 12
    num: 9
    num: 10
    num: 11
    Beginning shortWait()
    num: 1
    num: 16
    num: 13
    ```

#### 7.2.1 使用select切换协程
语法和switch非常相似，也称为通信开关。

为什么需要它：它监听进入通道的数据，也可以是用通道发送值(?)

注意：
1. 如果多个条件都满足，那么会随机执行其中一个。

## 8 基于共享变量的并发

## 10 测试
## 11 反射
## 12 底层编程
## 13 错误处理
Golang 没有传统的异常机制:对于非致命的错误，Golang 使用返回值来报告;对于致命的错误，Golang 直接选择“崩溃”掉(当然也有恢复机制), 不过按照 Golang 的哲学，既然是致命错误，就应当挂掉。

还有`defer`关键字，用于将一个语句“绑定”到函数退出时执行，无论是通过各种途径退出，这可是 C/C++ 里面的大问题。
1. 任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。
2. 关于内置的error：内置的error是接口类型，可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息，如

    ```go
    fmt.Println(err)
    fmt.Printf("%v", err)
    ```

注意:
1. 为了编写强壮的代码，不用使用`_`忽略错误，而是要处理每一个错误，尽管代码写起来可能有些繁琐。
2. 尽量不要使用panic。

### 13.1 错误处理策略(5种？)
1. 传播错误（最常用的方式）:由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息

2. 重试:如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。

3. 输出错误信息并结束程序:用于错误发生后，程序无法继续运行。这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非遇到了bug，才能在库函数中结束程序
    1. 关于错误信息的时间：log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。

        ```go
        if err := WaitForServer(url); err != nil {
            log.Fatalf("Site is down: %v\n", err)
        }
        ```

4. 只输出错误信息:
```go
//log包(log包中的所有函数会为没有换行符的字符串增加换行符)提供函数:log.Printf
//或者标准错误流输出错误信息:fmt.Fprintf
```

5. 忽略掉错误

### 13.2 go的错误处理方法
检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。

### 13.3 
通常会把自定义的Error放在package级别中，统一进行维护,并且变量以Err开头,如:`var (ErrCacheMiss = errors.New("memcache: cache miss")...)`

### 13.4 关于panic,refer和recover
`panic(string)`:会停掉当前正在执行的程序（注意，不只是协程），但是与`os.Exit(-1)`这种直愣愣的退出不同，panic的撤退比较有秩序，他会先处理完当前goroutine已经defer挂上去的任务，然后如果没被recover捕获就继续打印调用栈，最终调用exit(-2)退出整个进程。panic仅保证当前goroutine下的defer都会被调到，但不保证其他协程的defer也会调到。

`defer func(){...}`:defer的存在，让我们有更多的选择，比如在defer中通过recover截取panic，从而达到`try..catch`的效果。defer的特点就是LIFO，即后进先出，所以如果在同一个函数下多个defer的话，会逆序执行。注意defer要在panic之前声明才能捕获panic,最好写到最前面.

`recover()`:用于在当前的goroutine的defer中使用recover来捕捉panic,此时跳转到包含recover()的defer函数执行，recover捕获panic，此时panic就不继续传递．但是recover之后，程序并不会返回到panic那个点继续执行以后的动作,而是执行完所有defer之后退出.注意:recover只在defer的函数中有效，如果不是在refer上下文中调用，recover会直接返回nil。例子如下,

```go
func main() {
    defer func() {
        fmt.Println("1")
    }()
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err)
        }
    }()
    panic("fault")
    fmt.Println("2")
    //运行后输出
    //fault
    //1
}
```

## 14 垃圾回收
Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。(java等也是？)

Go 最初采用的是标记清扫算法，到了 1.5 开始引入三色标记和写屏障，垃圾回收的性能才有了好转。这套机制最终的目标就是在用户业务无感知的情况下实现垃圾回收，希望未来的版本这部分有更优秀的表现。

## 14.1 变量的生命周期
**go中一个变量的有效周期只取决于是否可达**，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在

## 14.2 堆栈分配
局部变量分配到堆或者栈上并不是由用var还是new声明变量的方式决定的,编译器会做逃逸分析(escape analysis),当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆上.比如某个局部变量x在函数退出后依然可以通过包一级的global变量找到，那么x必须在堆上分配内存，用Go语言的术语说，这个x局部变量从函数f中逃逸了.所以不用担心会不会导致内存泄漏(memory leak),go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。

## 15 注释
注释有两种形式：
1. 行注释以`//`开始，至行尾结束。一条行注释视为一个换行符。
2. 块注释 以`/*`开始，至`*/`结束。 块注释在包含多行时视为一个换行符，否则视为一个空格。

注意:
1. 注释不可嵌套
2. 版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。

注释的最佳实践:`//`之后应该加一个空格.(其他语言也应该这样))

### 15.1 文档注释
几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 "Abcd..." 作为开头。如,

```go
// enterOrbit causes Superman to fly into low Earth orbit, a position
// that presents several possibilities for planet salvation.
func enterOrbit() error {
   ...
}
```

## 16 和其他语言的交互
了解就行

# 四 高级
## 1 go自带的工具（go tool套件）
Go语言提供的工具都通过`go xxx`或`go tool xxx`命令调用，`go xxx`是对`go tool xxx`的简单封装，调用后只有在错误的时候才会输出，这点跟unix的哲学一样。工具的目录是`$GOROOT/pkg/tool/$GOOS_$GOARCH`,比如我的mac上该位置是`$GOROOT/pkg/tool/darwin_amd64`。

### 1.1 go run
`go run ...`编译且运行。后面可跟一个命令源码文件以及若干个库源码文件（必须同属于main包）作为文件参数。比如main.go中引用了a.go，那么运行时应该写成：
```
go run main.go a.go
#或者
go run *.go
```

### 1.2 go install
安装自身包和依赖包.

1. 首先说一下一般的go项目在GOPATH下的目录结构：
```bash
-- GOPATH  #GOPATH目录
  -- bin  #golang编译可执行文件的存放路径，可自动生成。
  -- pkg  #golang将可执行文件所依赖的各种package编译后的.a(or ?)中间文件存放路径，可自动生成
  -- src  #源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。
```
2. 命令会安装go包所依赖的任何东西
3. 只需要有src目录，bin和pkg会自动生成；install后是跟main.go的父级目录名，生成的可执行文件也是父级目录名；

### 1.3 go build
编译并安装自身包和依赖包.形如`go build hello.go`

### 1.4 go clean
清理生成的可执行文件，如`go clean hello.go`

### 1.6 go get
通过源码控制工具(比如git)递归获取代码包及其依赖,并进行编译和安装,已存在则默认不会再去获取。也就是说该命令做三件事：获取，编译，安装。所以该命令接受所有可用于go build命令和go install命令的标记。

简单使用:比如git的地址是`https://github.com/xushike/studyGo.git`,使用git获取代码是`git clone https://github.com/xushike/studyGo.git`,如果用go get命令就是`go get github.com/xushike/studyGo`,然后代码目录就是`GOPATH/src/github.com/studyGO`

参数说明:
- `-u`:强制更新已有的代码包及其依赖
- `-v`:打印出所有被构建的代码包的名字。建议加上该命令，可以大概了解进度。
- `-insecure`：允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。
- `...`：在后面加上三个点表示。。。

注意:
1. 导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同,是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供。（是不是意味着可以有重定向一样的功能？）

如果不能编译和安装，还会获取吗？

### 1.7 go vet
作用是检查Go语言源代码并且报告可疑的代码编写问题,可以捕获一些常见的错误，如格式化字符串等。

### 1.8 go fmt
代码格式化.开发工具中一般都集成了保存的时候自动格式化.以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执,更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。

指定包名时,`fmt`会格式化包中所有`.go`文件,否则格式化当前目录

### 1.9 go doc和godoc
#### 1.9.1 go doc
查看文档,挺方便的.如`go doc http.ListenAndServe`可以看到该函数的说明(显示的是函数上被注释的声明),`go doc http`可以直接看到包的说明,`go doc builtin.make`查看内建函数的说明.

#### 1.9.2 godoc

### 1.10 go fix
用于将你的 Go 代码从旧的发行版迁移到最新的发行版

### 1.11 go test（重要）
轻量级的单元测试框架。golang需要测试文件一律用”_test.go”结尾，测试的函数都用Test开头。go test命令默认是以包为单位进行测试的（运行包下所有的"_test.go"结尾的文件），默认不会打印辅助信息。因为go test命令中包含了编译动作，所以它可以接受可用于go build命令的所有参数。

对多个包进行测试(package tests)：以空格分割多个包的包名

对单个或多个文件进行测试（file tests）：形如`go test -v a_test.go b_test.go ...`，命令程序会为指定的源码文件生成一个虚拟代码包“command-line-arguments”，此时如果源码文件调用了其他包中的函数而没有声明的话，而需要加入对应的源码文件。比如a_test.go中调用了a.go中的Foo()方法，则会出现`undefined：Foo`错误，此时应该把a.go也加入进去`o test -v a_test.go a.go`

对单个或多个函数进行测试：加上`-test.run methodName`，形如`go test -v -test.run TestBar bar_test.go`，和上面一样会被指定虚拟包。

参数:
1. 打印辅助信息：`-v`,辅助信息大概如下，

    ```bash
    === RUN   Testxxx
    ...
    --- PASS: Testxxx (0.20s)
    ```

`t *testing.T`的方法:
1. `Fatal(err)`
2. `Log()`

## 2 其他与go有关的工具
### 2.1 Cgo
编译(静态编译?)一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件

### 2.2 gb
社区开发的依赖管理工具，而且也推荐用依赖管理工具来管理依赖

## 3 go runtime运行时
尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。

## 3 源码分析
### 3.1 待整理
编译器源码目录下，src/cmd/compile/internal

## 4 golang json处理
例子1:

```golang
// 结构体
type Product struct {
	Name      string `json:"name"`
	ProductId int64 `json:"productId,string"`
	Number    int
	Price     float64
	IsOnSale  bool
	VehBrand  string `sql:"varchar(100) default ''" json:"vehBrand" comment:"车辆品牌"`
}

// 设置值
p := &Product{}
p.Name = "Xiao mi 6"
p.IsOnSale = true
p.Number = 10000
p.Price = 2499.00
p.ProductId = 1
p.VehBrand = "大众"
```

Go类型和JSON类型的对应关系如下：
- bool 代表 JSON booleans,
- float64 代表 JSON numbers（如果json的number转go类型的话，以go类型为准，比如写的int就是int，写的int64就是int64）
- string 代表 JSON strings,
- nil 代表 JSON null.
- interface{} 按照内部的实际类型进行转换

标签tag：就是上面的结构体每个字段后面反引号包裹的内容.
1. 如果tag设置为`json:"-"`，那么这个字段不会输出到JSON
2. tag中带有自定义名称，那么这个自定义名称会出现在JSON的字段名中，例如上面的vehBrand
3. tag中如果带有"omitempty"选项，那么如果该字段值为空，就不会输出到JSON串中
4. 如果字段类型是bool, string, int, int64等，而tag中带有",string"选项，那么这个字段在输出到JSON的时候会把该字段对应的值转换成JSON字符串

解析JSON`func Unmarshal(data []byte, v interface{}) error`:注意这儿v必须是指针
1. 解析到结构体(已知被解析的JSON数据结构)
    1. 例如JSON的key是Foo，那么怎么找对应的字段呢？
        1. 首先查找tag含有Foo的可导出的struct字段(首字母大写)
        2. 其次查找字段名是Foo的导出字段
        3. 最后查找类似FOO或者FoO这样的除了首字母之外其他大小写不敏感的导出字段
    2. 能够被赋值的字段必须是可导出字段(即首字母大写）。同时JSON解析的时候只会解析能找得到的字段，找不到的字段会被忽略，这样的一个好处是：当你接收到一个很大的JSON数据结构而你却只想获取其中的部分数据的时候，你只需将你想要的数据对应的字段名大写，即可轻松解决这个问题。
2. 解析到interface{}(未知)：例子如下，

    ```golang
    b := []byte(`{"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]}`)
    var f interface{}
    err := json.Unmarshal(b, &f)
    // 这个时候f里面存储了一个map类型，他们的key是string，值存储在空的interface{}里.我们可以通过断言的方式来访问这些数据
    m := f.(map[string]interface{})

    f = map[string]interface{}{
        "Name": "Wednesday",
        "Age":  6,
        "Parents": []interface{}{
            "Gomez",
            "Morticia",
        },
    }

    ```

生成JSON`func Marshal(v interface{}) ([]byte, error)`：
1. 默认输出字段名的首字母都是大写的，如果你想用小写的首字母怎么办呢？首先想到的是把结构体的字段名改成首字母小写的，但是JSON输出的时候，只有导出的字段才会被输出，如果如果修改字段名首字母小写，那么就会发现什么都不会输出，所以必须通过struct tag定义来实现。

生成json需要注意的：
1. JSON对象只支持string作为key，所以要编码一个map，那么必须是map[string]T这种类型(T是Go语言中任意的类型)
2. Channel, complex和function是不能被编码成JSON的，会返回UnsupportedTypeError
3. 嵌套的数据是不能编码的，不然会让JSON编码进入死循环
4. 指针在编码的时候会输出指针指向的内容，而空指针会输出null(待补充)
5. 多个相同名字的字段：假设结构体a里嵌套有b、c两个结构体，然后b和c有相同的字段Name，如果两个Name都没有tag或者两个Name的tag所声明的json名称一样，那么生成json的时候两个Name都不会被编码；如果b和c中有Name字段，a里有Name字段（不在b或c中），那么以a中的Name字段会覆盖掉（不是替换）b和c中的。这些特性可实现以下技巧：
    1. 临时忽略某些字段：

## 5 go连接其他数据库
postgresql：
1. https://godoc.org/github.com/lib/pq

## 6 正则

## 7 位运算

# 五 经验
## 1 go编程思想和习惯
写Go代码就要用Go的哲学和思想,而不是抱着java,js等其他语言的思想.弄清楚Go语言的设计选择和背后的动机,理解的简洁和可组合性哲学.

1. 少用模板,多用组合(也是Unix程序设计提倡的思想).
2. go中返回的布尔值通常表示操作是否成功,一般可以命名为`ok`
3. Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。如下,

    ```go
    if f, err := os.Open(fname); err != nil {
        return err
    } else {
        // f and err are visible here too
        f.ReadByte()
        f.Close()
    }
    //更推荐的写法：Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。
    f, err := os.Open(fname)
    if err != nil {
        return err
    }
    f.ReadByte()
    f.Close()
    ```

## 2 常用包和方法

### fmt
其中以f(表示fomart)结尾的方法(比如`Printf()`,`Errorf`等)可以使用格式化输出,即使用`%d`,`%c`等转换输出格式,这些也被go程序员称为动词（verb）.以ln(表示line)结尾的方法跟`%v`差不多的方式格式化参数，并在最后添加一个换行符。

许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印.

动词（verb）说明:

```go
package main
func main() {
    type point struct {
        x, y int
    }
    p := point{1, 2}
    fmt.Printf("%v\n", p)
}
```

1. `%v`:是打开任意类型的默认格式.
2. `%+v`:如果值是一个结构体，输出内容将包括结构体的字段名.如`{x:1 y:2}`
3. `%#v`:输出这个值的 Go 语法表示(包括字段和限定类型名称在内的实例的完整信息).如`main.point{x:1, y:2}`
4. `%T`:打印值的类型.例如,

    ```go
    a := "hello world"
	b := []string{"a", "b", "c"}
	fmt.Println(fmt.Sprintf("%T", a))//string
	fmt.Println(fmt.Sprintf("%T", b))//[]string
    ```
5. `%t`:格式化布尔值
6. 进制格式化
    - `%d`:标准十进制格式化
    - `%b`:二进制
    - `%x`:十六
7. `%c`:输出给定整数的对应字符
8. 浮点数格式化
    - `%f`:标准十进制格式化
    - `%e`和`%E`:科学计数法
9. `%s`:对给定字符串进行原样输出.比如字符串有一个空行,输出结果中也会有一个空行
10. `%p`:输出指针的值.如`fmt.Printf("%p\n", &p)`，会输出`0xc42000e280`。同一个对象的不同引用的指针是一样的。
11. 指定输出宽度,使用`[num]`:如`fmt.Printf("|%6s|%6s|\n", "foo", "b")`,会输出`|   foo|     b|`

    在有宽度的时候,默认是右对齐
11. 输出左对齐,使用`-`:如`fmt.Printf("|%-6s|%-6s|\n", "foo", "b")`,会输出`|foo   |b     |`

其他:
1. [https://studygolang.com/articles/2644](https://studygolang.com/articles/2644)
3. `Printf()`:支持格式化输出
5. `Sprintf()`:格式化并返回一个字符串而不带任何输出
2. `fmt.Errorf`函数使用`fmt.Sprintf`处理错误信息
6. `Fprintf()`:依据指定的格式向第一个参数内写入字符串，第一参数必须实现了 io.Writer 接口。Fprintf() 能够写入任何类型，只要其实现了 Write 方法，包括 os.Stdout,文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。适合任何形式的缓冲写入(?),在缓冲写入的最后千万不要忘了使用 Flush()，否则最后的输出不会被写入。

### os
os包中实现了平台无关的接口，设计向Unix风格，但是错误处理是go风格，当os包使用时，如果失败之后返回错误类型而不是错误数量．

os包可以操作目录、操作文件、操作环境变量、退出程序、替换字符串中的`$xxx`、获取用户/组/环境信息、操作进程等

1. `Args[xxx]`：返回命令行参数，比如`go run xxx.go p1 p2 ...`中的p1、p2...
2. 操作系统架构:`runtime.GOARCH`

### rand
该包实现了伪随机数的生成

### reflect
反射机制就是在运行时动态的调用对象的方法和属性，每种语言的反射模型都不同，反射的原理：待补充

反射回来的类型大概有：

### runtime
runtime包主要用于调试和分析运行时信息，在很多场合都会用到，比如日志和调试。函数表面看起来简单，但是功能强大，常用的几个函数如下：
1. `Caller(skip int)`:提供当前goroutine的栈上的函数调用信息。返回当前的PC值、正在执行的文件名（绝对路径）、代码行号。参数 skip 是要跳过的栈帧数, 若为 0 则表示 runtime.Caller 的调用者。由于历史原因, 该参数和runtime.Callers 中的 skip 含义并不相同。
    1. 网友实测, Go的普通程序的启动顺序如下:
        1. runtime.goexit 为真正的函数入口(并不是main.main)
        2. 然后 runtime.goexit 调用 runtime.main 函数
        3. 最终 runtime.main 调用用户编写的 main.main 函数
2. `runtime.Callers()`
3. `runtime.FuncForPC(pc uintptr)`:返回包含给定 pc 地址的函数, 如果是无效 pc 则返回 nil。可以用来获取函数名。

基于上面几个方法，可以做一个获取调用者的函数名/文件名/行号等用户友好的信息的简单函数：
```golang
func CallerName(skip int) (name, file string, line int, ok bool) {
	var pc uintptr
	if pc, file, line, ok = runtime.Caller(skip + 1); !ok {
		return
	}
	name = runtime.FuncForPC(pc).Name()
	return
}
```

### sort
排序相关算法,原理待补充：
1. 对整数切片排序`sort.Ints(slice []int)`
2. Float64
3. Strings

### strings
1. `TrimSpace()`:去除字符串左右两边的空格,包括回车符等,但是不会去除字符串里面的空格

    有空研究一下里面的实现原理
2. `Replace(str, " ", "", -1)`:去掉字符中所有的空格(实测回车和换行都去除不掉)
2. `Replace(str, "\n", "", -1)`:去掉字符中所有的换行
4. `Join()`和`Split()`:可以看成两个功能相反的方法

最佳实践:
1. 使用`strings.TrimPrefix／strings.TrimSuffix`掐头去尾,而不是自己去判断

### strconv
该包用于string类型的各种转换
1. `Atoi()`:string=>int
2. `FormatFloat(f float64, fmt byte, prec, bitSize int) string`(待整理):float64=>string,`fmt`表示...;`prec`表示精度,负数的话就取最小的实际精度,正数的话是多少就取多少位;bitSize是64或者32
3. 查看int的位数`strconv.IntSize`

### sync

#### sync/atomic
提供一些原子操作，比如：
1. 增或减：`AddUint32(x,x)`
2. 以‘CompareAndSwap’为前缀的CAS操作,比如`CompareAndSwapInt32()`，趋于乐观

### time
时间戳：为什么时间戳基于1970年1月1日0时？综合网上的资料可知，最早unix的是32位的，按照秒来计时，最多只能表示大概68年的时间，于是在第一版unix程序员手册（20世纪70年代早期）里将GMT定为1971年1月1日0时，后来64位系统出现了，根本不用担心这个问题，就将1971改为1970更方便。

10位的时间戳表示秒，以此类推，13位表示毫秒，16微秒，19纳秒
1. `Unix()`:时间戳（秒）

### unicode
包含了一些针对测试字符的非常有用的函数.

1. 判断是否为字母：`unicode.IsLetter(ch)`
2. 判断是否为数字：`unicode.IsDigit(ch)`
3. 判断是否为空白符号：`unicode.IsSpace(ch)`

### utf8
与 rune 相关的函数

### encoding/json
参考json部分

## 3 go的编译器
### 3.1 为何这么快(from圣经)
Go语言的闪电般的编译速度主要得益于三个语言特性:
1. 所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。
2. 禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。
3. 编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）

## 4 第三方包
1. mysql驱动:[github.com/go-sql-driver/mysql](github.com/go-sql-driver/mysql)

## 5 其他
1. 有空的时候可以多看看Google的工程师是如何实现的

# 六 问题
## 1 已解决
### 1.1 关于go中的自增自减
自增语句i++给i加1；这和i += 1以及i = i + 1都是等价的。对应的还有i--给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i++非法，而且++和--都只能放在变量名后面，因此--i也非法。

### 1.2 如何查看内建函数的源代码
参考[Built-In source code location](https://stackoverflow.com/questions/18512781/built-in-source-code-location).大意就是运行时会根据类型等来调用不同的函数(在"cmd/compile/internal/gc/typecheck.go"),内建函数可以看做是多个函数的组合,想看代码的话就只有分析可能调用的方法慢慢找.

### 1.3 获取参数的类型的几种方法
1. `fmt.Sprintf("%T",xxx)`:通过fmt包获取,其实也是通过反射获取的
2. `reflect.TypeOf(xxx)`:通过反射获取
3. `xxx.(<类型>)`:类型断言

注意:注意上面的方法都可以获取interface{}的实际类型

### 1.4 常见错误:err is shadowed during return
作用域问题,在if等语句内部声明的err覆盖了外面的err,当内部执行完毕之后外部的err并没有变.
`
### 1.5 debug.gcstackbarrieroff undefined ...
我当时是覆盖安装新版本go后使用`go build`命令出现的这个问题,网上搜了下,答案是删除``(待补充)

### 1.6 cannot use card.CardLib literal (type *card.CardLib) as ty`pe card.ICardLib in field value: *card.CardLib does not implement card.ICardLib (missing SwitchCardGPRS method)
一般都是方法所有者不对

### 1.7 missing argument to conversion to ...
本来是调用类的方法的,结果写成调用类了

### 1.8 import cycle not allowed
golang不允许循环引用，比如a引用b，b引用c，c再引用a这种在golang里也算循环引用。解决方法有两种：
1. 最简单的就是给头或尾建立子包
2. 去掉头或尾的引用

## 2 未解决
1. 因式分解
3. 编程范式
4. Erlang风格的并发模型
5. go支持Erlang语言为代表的面向消息编程思想
6. 不清楚go的稳定性，所以目前很多公司还不太敢用
7. 从源码安装软件怎么操作？二进制发行版和安装版的区别？
10. protobuf的获得和使用
11. go get如果后面是xxx.go而不是项目的名字，那么引入的是这一个go文件还是整个项目？
13. go generate 生成代码
14. go type的几种写法
15. why golang don't support Stored Procedure or Generic?
16. 一些文章
    1. [http://blog.csdn.net/libaineu2004/article/details/49722651](http://blog.csdn.net/libaineu2004/article/details/49722651)
21. 网友:string []byte 的转换是会拷贝的?

# 七 待整理
1. go源代码的分析

    本来想看go内建函数copy的源代码的,结果点不进去,于是用上网搜了搜,觉得有两种可能:
    1. 是调用copy()的时候go的编译器将其解析成汇编代码

        如果是这样的话,go的很多方法实现的汇编代码都可以抽空看看,应该值得学习的不少
    2. 调用了某个文件里声明的copy方法

2. [网友写的go学习资料](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md)
3. [为什么那么多开发人员用Go语言来构建自己的新项目](http://www.epubit.com.cn/article/942)
4. [我为什么喜欢Go语言(简洁的Go语言)_Golang](https://edu.aliyun.com/a/12182)
5. go的unsafe,Pointer,uintptr,funcPC,slicestringcopy,copyany

6. go语言圣经
    1. 如何写标准测试程序

7. [极客学院的go学习](http://wiki.jikexueyuan.com/project/the-way-to-go/)
8. 传递map的时候是引用传递
9. 竞态条件
10. Go语言提供了一些很好用的package，并且这些package是可以扩展的。Go语言社区已经创造并且分享了很多很多。所以Go语言编程大多数情况下就是用已有的package来写我们自己的代码。

    如何扩展?
11. 有空的话应该都看完:[极客学院的go教程](http://wiki.jikexueyuan.com/list/go/)

12. flag包是干嘛的 
13. go的socket.

14. [用go写一个windows外挂](http://www.ituring.com.cn/article/468550)

15. golang的升级(笔记)
16. 大量使用 type assertion 代码是非常丑陋的。所以一定要尽量避免使用这个类型
    1.  golang wiki 上面对这个问题的解释 https://github.com/golang/go/wiki/InterfaceSlice golang wiki 是个好东西，有时间建议把内容都过一遍，可以让你少踩好多坑

17. 深入理解Go语言中的闭包:https://www.jb51.net/article/108972.htm
    1. 闭包好理解,注意作者最后的分析工具怎么用的

18. 学习go的教程:https://github.com/Unknwon/the-way-to-go_ZH_CN
19. 问题
    1. 合并两个map
    2. 数组里查找元素

21. go工具链，有空再研究吧：https://blog.csdn.net/phantom_111/article/details/79981579
22. go的官方博客？：https://blog.golang.org/
23. 在 Golang 中，如果字符串中出现中文字符不能直接调用 len 函数来统计字符串字符长度，这是因为在 Go 中，字符串是以 UTF-8 为格式进行存储的，在字符串上调用 len 函数，取得的是字符串包含的 byte 的个数。
24. 获取字符串长度的几种方法：https://blog.csdn.net/skh2015java/article/details/53258249
25. 加密解密：
    encoding/pem
    crypto/x509
    crypto/rsa
    crypto/sha256

26. 关于golang的ID和id，参考：https://github.com/golang/go/wiki/CodeReviewComments#initialisms；大意就是说golint认为ID才是正确的并且暂时不会改变这个规则，所以只有自己维护一个golint版本来忽略该提示。
    1. 还有网友推荐了这个东西：https://github.com/alecthomas/gometalinter
        1. allows you to configure which warnings are displayed (including those from golint).