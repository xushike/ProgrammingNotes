# golang
[TOC]
## 一. 概述
1. 目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。
2. “如果一个特性并不对解决任何问题有显著的价值，那么Go就不提供它”的原则
3. Go语言在语言层面解决软件工程问题的设计哲学
### 1 简介
#### 比较明显的特点
- 编译成无依赖二进制

    copy部署很方便,拷贝exe就能跑了.
- 协程
- 完善的库
- 开箱即用的测试／调试工具

#### 比较明显的缺点
- 语法不容易习惯
- 不能用的变量写成`-`,不方便调试(?)
- go的包管理:感觉不如npm好用
- 不支持泛型
- 没有存储过程(?)
- 错误处理的代码多了很不爽

#### 网友评价
1. 更好的 c
2. go + java是不错的实践

### 3 常识
1. Go语言的标准库（通常被称为语言自带的电池）
2. Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
3. Go语言反对函数和操作符重载（overload）
4. 支持匿名函数与闭包
5. Go程序并不要求开发者在每个语句后面加上分号表示语句结束，这是与C和C++的一个明显不同之处。
6. 以囊地鼠（Gopher）作为它的吉祥物,Rob Pike的妻子 Renee French绘制的

#### 关于go的作者
1. Robert Griesemer：曾协助实现 Java 的 HotSpot 编译器和 JavaScript V8 引擎。
2. Rob Pike：曾是贝尔实验室的 Unix 团队和 Plan9 操作系统成员，与 Thompson 一起创造了 UTF-8 字符编码。
3. Ken Thompson，不用多说了，技术圣殿的人物，创造了 C 语言和 Unix，获得了 1983 年图灵奖和 1988 国家技术奖
### 6 go的工具(命令)
1. Go语言提供的工具都通过一个单独的命令go调用
2. 关于go工具的输出：只有在错误的时候才会输出，这点跟unix的哲学一样
#### 2.1 run
#### 2.2 install
1. 首先说一下一般的go项目在GOPATH下的目录结构：
```bash
-- GOPATH  #GOPATH目录
  -- bin  #golang编译可执行文件的存放路径，可自动生成。
  -- pkg  #golang将可执行文件所依赖的各种package编译后的.a(or ?)中间文件存放路径，可自动生成
  -- src  #源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。
```
2. 命令会安装go包所依赖的任何东西
3. 只需要有src目录，bin和pkg会自动生成；install后是跟main.go的父级目录名，生成的可执行文件也是父级目录名；
#### 2.3 build
1. 编译go源文件，如`go build hello.go`
#### 2.4 clean
清理生成的可执行文件，如`go clean hello.go`
#### 2.5 run
编译且运行
#### 2.6 get
通过源码控制工具(比如git)递归获取代码包及其依赖,已有的不会再去获取,如`go get github.com/xushike/studyGo`
1. 参数`-u`:强制更新已有的代码包及其依赖
2. 参数`-v`:打印出被构建的代码包的名字
#### 2.7 vet
可以捕获一些常见的错误，如格式化字符串等
#### 2.7 fmt
代码格式化，开发工具中一般都集成了保存的时候自动格式化
#### 2.8 doc和godoc
查看文档，如`go doc tar`
### 3. 其他与go有关的工具
#### 3.1 Cgo
编译(静态编译?)一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件
#### 3.2 gb
社区开发的依赖管理工具，而且也推荐用依赖管理工具来管理依赖
### 4. go相关网站
1. 网友写的Go web编程gitbook，比较详细，应该很值得读：[https://astaxie.gitbooks.io/build-web-application-with-golang/zh/](https://astaxie.gitbooks.io/build-web-application-with-golang/zh/)
2. go语言圣经中文网：[http://books.studygolang.com/gopl-zh/](http://books.studygolang.com/gopl-zh/)
## 二. 安装配置
### 1 windows下的安装
1. ...
3. 配置GOROOT(C:\Go)和PATH(添加%GOROOT%\bin)，这样就可以在任意地方运行go开头的命令了
4. 配置GOPATH:系统默认的gopath是GOROOT，`fmt`等包在GOROOT中，所以可以直接`import`；当安装了gocode和gopkgs等工具时，还会算上安装工具的目录；但是如果`import`的目录不在这两者当中，那么就会报错找不到，所以要把自己go代码的目录加入到GOPATH中
>设置GOPATH的时候只需要写src前面的目录，会自动去src下找；设置了GOPATH之后，`import`时就只会去GOROOT和GOPATH中找；添加多个目录的时候Windows是分号，Linux系统是冒号，当有多个GOPATH时，大部分情况下会是第一个路径优先，比如：查找包、go get的内容默认放在第一个目录下

5.配置gobin(需不需要看情况)
### 2 mac下的安装
#### 2.1 二进制发行版安装
#### 2.2 第三方工具安装(homebrew等)
### 3 linux下的安装
#### 3.1 安装包（二进制发行版）安装(**推荐**)
1. 下载xxx.tar.gz，安装到`/usr/local`下:
```bash
#查看压缩文件内容
tar -ztvf xxx.tar.gz
#解压到目录下
sudo tar -zxvf xxx.tar.gz -C /usr/local 
```
2. 环境变量设置：
    1. 设置GOROOT:
        1. 设置方式类似于JAVA_HOME，如`export GOROOT=$HOME/xxx`
        2. 把`$GOROOT/bin`加入PATH：`export PATH=$PATH:$GOROOT/bin`
        
    1. 设置GOPATH：这个目录用来存放Go源码(src)，Go的可运行文件(bin)，以及相应的编译之后的包文件(pkg)
        >在go1.1到1.7，该变量必须设置，且不能和go安装目录一样;从1.8开始有默认值，在Unix上默认为`$HOME/go`,在Windows上默认为`%USERPROFILE%/go`

        1. 设置GOPATH(**最好不要和go安装目录相同**)
        2. 把GOPATH/bin加入环境变量 
3. 关于GOBIN（待验证）:
将`$GOPATH/bin`加入PATH中，这样可以方便的运行`go install`好的二进制程序。然而，当存在GOPATH中存在多个路径时，这种写法只会将最后一个路径跟上bin。在mac或linux下可以通过这种方式解决：
`${GOPATH//://bin:}/bin`
#### 3.2 源码安装
#### 3.3 第三方工具安装（apt、wget等）
## 三. 基础
### 1. 程序结构
#### 1.3 变量
1. 声明变量的语法
    其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
    ```go
    //声明变量的方式1
    var 变量名字 类型 = 表达式
    ```
    ```go
    //声明变量的方式2：多个连续变量是同一类型，则可以只写最后一个类型
    var i, j, k int                 // int, int, int
    //声明变量的方式3:初始化时使用表达式，可省略类型，会自动判断
    var b, f, s = true, 2.3, "four" // bool, float64, string
    ```

    初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。例子如下：
    ```go
    var f, err = os.Open(name) // os.Open returns a file and an error
    ```
    在**函数内部**，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量：
    ```go
    //声明变量的方式4:简短变量声明(只能在函数内使用)
    /*注意":="是一个变量声明且赋值(如果已经声明，则只有赋值;)语句，
    而"="是一个变量赋值操作*/
    anim := gif.GIF{LoopCount: nframes}
    freq := rand.Float64() * 3.0
    t := 0.0
    /*这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用
    比如for语句的循环的初始化语句部分*/
    i, j := 0, 1
    ```
    注意：
    1. `:=`是一个变量声明且赋值语句，而`=`是一个变量赋值操作;如果左边的变量已经声明，则只有赋值操作；简短变量声明语句中必须至少要声明一个新的变量
    2. 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。
2. 关于为什么go语法定义里把类型写在右边,参考[https://blog.golang.org/gos-declaration-syntax](https://blog.golang.org/gos-declaration-syntax),本人简单概括两点:（待验证）
    1. c和java都是先写类型,是巧妙的语法思想，但更适合简单的类型。著名的混淆例子是声明一个函数指针：
        ```c
        int（* fp）（int a，int b）;
        //在这里，fp是一个指向函数的指针，因为如果你写表达式（* fp）（a，b）
        //你会调用一个返回int的函数。如果fp的论点之一本身就是一个函数呢？
        int（* fp）（int（* ff）（int x，int y），int b）
        //变得难以阅读
        ```
    2. 类型和表达式语法的区别使得在Go中编写和调用闭包很容易：
        ```go
        sum：= func（a，b int）int {return a + b}（3,4）
        ```
3. 关于变量的初始值：零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。
    1. 数值类型变量对应的零值是0，
    2. 布尔类型变量对应的零值是false，
    3. 字符串类型对应的零值是空字符串，
    4. 接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。
    5. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
    6. 当要声明一个变量或者结构体为零值时,go习惯使用var,这样更明确
4. 不同类型之间转换需要显式转换
    ```go
    var i int = 42
    var f float64 = float64(i)
    或者
    f := float64(i)
    //去掉float64 会报错
    ```
5. 关于赋值
    1. 更有效的写法,比如
        ```go
        count[x] = count[x] * scale // 数组、slice或map的元素赋值
        //下面的写法更有效，可以省去对变量表达式的重复计算
        count[x] *= scale
        ```
    2. 自增和自减是语句，而不是表达式，所以这样写是错的：
        ```go
        x = i++
        ```
    3. 可以用下划线空白标识符_来丢弃不需要的值
        ```go
        _, err = io.Copy(dst, src) // 丢弃字节数
        _, ok = x.(T)              // 只检测类型，忽略具体值
        ```
    3. 元祖赋值：允许同时更新多个变量的值,先计算右边再统一更新左边。
        优点：
        - 对同时出现在两边的变量很有帮助
        - 可以使一系列琐碎赋值更加紧凑
    5. 可赋值性：
        1. nil可以赋值给任何指针或引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换
        2. 对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。
#### 1.4 常量
const声明,可以是字符、字符串、布尔或数字类型的值,不能用`:=`定义
#### 1.5 指针
指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）
#### 1.6 类型
#### 1.7 结构体
1. 
#### 1.9 包和文件
1. 网友推荐的包目录结构如下：
```bash
dir      
  -- goWorkSpace1   #主要是为了区分自己的鼓捣的一些东西和工作上的项目
  -- goWorkSpace2   #需要把两个workspace都加入gopath
        -- bin
        -- pkg
        -- src                  
           -- myApp1    #src下最好每个项目一个目录
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp2
              -- .git
              -- models
              -- controllers
              -- main.go 
           -- myApp3
              -- .git
              -- models
              -- controllers
              -- main.go
```

2. 关于包路径和包名
    1. 同级目录下的文件不能定义不同package
    3. 一般的: 
        ```bash
        --config
            -- config.go    #假设config目录下有config.go文件
        ```
        config.go中的package名称~~必须~~最好和目录config一致，而文件名可以随便。main.go表示main包，文件名建议为main.go。（注：**不一致时，生成的.a文件名和目录名一致，这样，在import 时，应该是目录名，而引用包时，需要包名。例如：目录为myconfig，包名为config，则生产的静态包文件是：myconfig.a，引用该包：import “myconfig”，使用包中成员：config.LoadConfig()**）
    4. 简单总结就是:
        ```go
        package 最后一层目录名(最好)or其他名字
        import 源文件所在目录src后的完整路径名(go的import查找的是包的路径，并不是包名)
        //使用时最后一层目录名or其他名字来调用
        ```
    5. 可以用`./xxx`来import，这种方式不依赖GOPATH，但是不推荐
    6. GOPATH和GOPATH下的src目录不应该添加到源代码管理中
    7. 可执行命令的文件(比如hello.go)的包名必须是package main

3. 关于包的初始化
    1. 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了
    2. 可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数
### 1.10 作用域
1. 一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系（但实际最好不要这样），内部声明的将屏蔽外部的声明
    1. 例子1
        ```go
        func main() {
            x := "hello!"
            for i := 0; i < len(x); i++ {
                x := x[i]
                if x != '!' {
                    x := x + 'A' - 'a'
                    fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
                }
            }
        }
        ```
    2. 例子2,同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：
        ```go
        func main() {
            x := "hello"
            for _, x := range x {
                x := x + 'A' - 'a'
                fmt.Printf("%c", x) // "HELLO" (one letter per iteration)
            }
        }
        ```
    3. 例子3，和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域：
        ```go
        if x := f(); x == 0 {
            fmt.Println(x)
        } else if y := g(x); x == y {
            fmt.Println(x, y)
        } else {
            fmt.Println(x, y)
        }
        fmt.Println(x, y) // compile error: x and y are not visible here
        ```
        第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后每个是每个分支的词法域。
2. 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。
3. 更推荐的写法
    ```go
    /*对于如下代码，下面有go更推荐的写法*/
    if f, err := os.Open(fname); err != nil {
        return err
    } else {
        // f and err are visible here too
        f.ReadByte()
        f.Close()
    }
    /*更推荐的写法：Go语言的习惯是在if中处理错误然后直接返回，
    这样可以确保正常执行的语句不需要代码缩进。*/
    f, err := os.Open(fname)
    if err != nil {
        return err
    }
    f.ReadByte()
    f.Close()
    ```

### 1.x 注释
go的注释与C++保持一致
### 2. 数据类型
Go语言将数据类型分为四类：
1. 基础类型：包括数字、字符串和布尔型。
2. 复合类型(聚合)：通过组合简单类型，来表达更加复杂的数据结构，包括数组和结构体
3. 引用类型：包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用
4. 接口类型：就是接口
#### 2.1 基础数据类型
#### 2.2 复合数据类型
##### 2.2.1 数组
1. 元素占用内存相同且连续，所以访问元素速度很快
2. 数组的声明
    ```go
    //1.直接声明
    var arr [5]int
    //2.使用字面量声明
    var arr := [5]int{1,2,,5,5,6}
    //3.自动计算长度声明
    var arr := []int{1,3,5} 
    //4.指定特定元素的值
    var arr := [5]int{2:5,3:6}
    ```
3. 数组的赋值
    只有类型和大小一样的数组才能相互赋值
4. 在函数间传递数组
    可以传递值也可以传递指针，后者只需要在栈上开辟8字节的内存，性能更好，但是对指针的改动会影响共享内存
##### 2.2.2 切片
切片可看作go对数组抽象后的类似动态数组的集合,len()返回切片的长度，cap()返回切片的容量
1. 切片的声明
    ```go
    //1.使用内置make函数
    slice := make([]string,5)
    //如果只指定长度，那么容量和长度相等
    //也可以分开指定，但必须容量>长度
    //2.使用切片字面量来声明切片
    //此时长度和容量也是相等的
    slice := []string{"a","b","c"}//长度和容量都是3
    //3.使用索引声明切片
    slice := []stirng{99:"hello"}//长度和容量是100
    //4.使用切片创建切片
    slice := []int{10,20,30,40,50}
    newSlice :=slice[1:3]//newlice的长度为2，容量为4，且和slice同一截数组
    //5.使用三个索引创建切片
    slice := []string{"a","b","c","d","e"}
    newSlice := slice[1:3:4]//newSlice的长度2，容量为3
    //其他：1.声明空切片
    //可用于表示空集合
    slice := make([]string,0)
    slice := []stirng{}
    //其他：2.声明nil切片
    //需要描述一个不存在的切片时会用到nil切片
    slice := []int
    ```
    注意只要[]里有值，就不是切片而是数组了
2. 切片的增长
    1. 使用go语言内置的append()，该函数总会增长切片的长度，而容量有可能会变
    2. 容量<1000时，每次扩容是翻倍；超过1000，每次增加25%
    3. 当每次容量不够的时候，append()就会分配一个新的数组，所以可以通过设置长度和容量一样的切片来保证第一次append()分配的是新数组
3. 切片的迭代
    1. 使用关键字range,第一个返回值是索引，第二个返回值是值的副本
        ```go
        for index,value range slice{
            ...
        }
        ```
    2. 也可用普通的for循环
4. 在函数间传递切片
    传递的是切片本身(64位上24字节)，而与切片关联的数据包含在底层数组里，不属于切片本身，所以传递切片时不会影响底层的数组,简单快速.
    但实际测试有一些细节:
    1. 对元素赋值等会影响原切片
    1. append()不会影响原切片,但是传递的是切片指针时会影响

##### 2.2.3 映射map
map是存储无序键值对的集合,map强大的地方在于可以根据键快速检索到值.本人感觉原理跟布隆过滤器很像 
#### 2.3 引用数据类型
#### 2.4 用户自定义类型
有两种声明方法,一种是结构体,一种是基于已有的类型
1. 结构体
2. 基于已有的类型,如`type doration int64`,此时int64是doration的基础类型,但是go并不认为doration和int64是同一个类型
### 3 流程控制
#### 3.1 for(go中唯一的循环)
1. 语法说明
    1. 除了不能用`()`外，其他跟c和java很像
    2. 可以省略分号，此时可以看做go的`while`
#### 3.2 if else
1. 语法
    1. 不能用`()`，其他很像c和java
    1. 跟 for 一样，`if` 语句可以在条件之前执行一个简单的语句。由这个语句定义的变量的作用域仅在 if 范围之内。
#### 3.3 switch
1. 语法
    1. ...
    1. 从上到下匹配，成功时停止
    3. 没有条件的switch等于`switch true`，从而可以用更清晰的形式来编写长的 if-then-else 链：
        ```go
        t := time.Now()
        switch {
        case t.Hour() < 12:
            fmt.Println("Good morning!")
        case t.Hour() < 17:
            fmt.Println("Good afternoon.")
        default:
            fmt.Println("Good evening.")
        }
        ```
### 4 函数
1. 基本语法
    1. 所有go函数以`func`开头,函数方法名首字母大写(?)，函数外的每个语句都必须以关键字开始(也就意味着简短声明表达式不能在函数外使用)
    2. 支持多返回值，返回值名称可作为文档使用，且可以像变量一样直接使用
2. go函数的大概结构
    Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。
#### 4.1 函数声明
1. 函数的类型被称为函数的标识符
1. 如果函数在声明时，包含返回值列表，则函数必须以return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环.
2. 函数实参通过值的方式传递，即形参是实参的拷贝，对形参修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。
4. 可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符，如:
    ```go
    package math
    func Sin(x float64) float //implemented in assembly language
    ```
#### 4.2 递归
1. 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题
#### 4.3 多返回值
1. 关于debug：调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值，如下，
    ```go
    log.Println(findLinks(url))
    links, err := findLinks(url)
    log.Println(links, err)
    ```
2. 关于函数命名：准确的变量名可以传达函数返回值的含义(比如长、宽、高等)，不过按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释
3. 关于bare return(裸返回)：如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。
    >当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。
#### 4.5 函数值
1. 关于第一类值(first-class values)和第二类值
    有些语言中function跟int, double的地位是一样的。这种语言就为函数是第一类值；而有些语言是不能存储函数，不能动态创建函数，不能动态销毁函数。(这里函数是已经是广义的了，用来表示代码code)。只能存储一个指向函数的指针，这种语言称为函数是第二类值。
2. 函数类型的零值是nil。函数值之间是不可比较的，但函数值可以与nil比较。调用值为nil的函数值会引起panic错误。
#### 4.6 匿名函数(anonymous function)
1. 定义：函数字面量(function literal)的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。
2. 匿名函数的优点:
    1. 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值，而且不必担心函数名冲突
    2. 更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量
3. 简单例子如下
    ```go
    // squares返回一个匿名函数。
    // 该匿名函数每次被调用时都会返回下一个数的平方。
    func squares() func() int {
        var x int
        return func() int {
            x++
            return x * x
        }
    }
    func main() {
        f := squares()
        fmt.Println(f()) // "1"
        fmt.Println(f()) // "4"
        fmt.Println(f()) // "9"
        fmt.Println(f()) // "16"
    }
    ```
#### 4.8 defered函数(待补充)
1. 语法：
2. 配合匿名函数
### 5. 方法
1. 关于方法的接收者选择
    1. 要由接收者类型的本质来决定,感觉有点复杂,简单说就是看使用情况:对于内置类型,基本都是值接收者(?),对于结构类型就要看情况了
    2. 例外是需要让类型值符合某个接口的时候
### 6. 接口
1. go的接口是非侵入式的，只要实现了接口里要求的全部方法，就实现了接口
    带来的优点是：
    1. 不用绘制类库的继承树图
    2. 不用纠结接口需要拆的多细
    3. 不用为了实现一个接口而专门导入一个包
2. 
### 7. Goroutines和Channels
#### 未整理
1. 网友:goroutine 并不是 “把异步回调的代码用同步的方式来写”。而是在用户空间实现了一个 M 对 N 的调度器。 
简单来讲，异步回调一般只开一个线程，有任务了之后会把让这个线程去执行这个任务，无法利用多核。 
而 goroutine 会根据机器的运行情况开 N 个操作系统级别的线程，然后把 M 个用户级别的 goroutine 调度到这 N 个线程上。 
golang 团队一直引以为傲的就是这个 M 对 N 的调度器，这种 M 对 N 调度器在业界也算是比较先进的。
2. 网友:协程不是异步回调，协程是状态的保存和切换，这种思想很容易写出异步代码，实现同样的异步功能， c++或者 java 之类的写到你想吐
#### goroutine
是一种比线程更加轻盈、更省资源的协程.

### 8. 基于共享变量的并发
### 9. 包和工具
#### 9.1 包相关
#### 9.2 常用包
##### 9.2.1 fmt
1. [https://studygolang.com/articles/2644](https://studygolang.com/articles/2644)
2. `fmt.Errorf`函数使用`fmt.Sprintf`格式化错误信息并返回
#### 9.3 工具
### 10. 测试
### 11. 反射
### 12. 底层编程
### 13. 错误处理
Golang 没有传统的异常机制。
对于非致命的错误，Golang 使用返回值来报告(Golang 支持多返回值).
对于致命的错误，Golang 直接选择“崩溃”掉(当然也有恢复机制), 不过按照 Golang 的哲学，既然是致命错误，就应当挂掉。
还有 defer 关键字，用于将一个语句“绑定”到函数退出时执行，无论是通过各种途径退出，这可是 C/C++ 里面的大问题。
1. 任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。
2. 关于内置的error：
    内置的error是接口类型，可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息，如
    ```go
    fmt.Println(err)
    fmt.Printf("%v", err)
    ```
#### 13.1 错误处理策略(5种？)
1. 传播错误（最常用的方式）
    由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息
2. 重试
    如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
3. 输出错误信息并结束程序
    用于错误发生后，程序无法继续运行。这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非遇到了bug，才能在库函数中结束程序
    1. 关于错误信息的时间：
    log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。
        ```go
        if err := WaitForServer(url); err != nil {
            log.Fatalf("Site is down: %v\n", err)
        }
        ```
4. 只输出错误信息
    ```go
    //log包(log包中的所有函数会为没有换行符的字符串增加换行符)提供函数:log.Printf
    //或者标准错误流输出错误信息:fmt.Fprintf
    ```
5. 忽略掉错误
#### 13.2 go的错误处理方法
检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。
### 14 垃圾回收
Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。(java等也是？)
Go 最初采用的是标记清扫算法，到了 1.5 开始引入三色标记和写屏障，垃圾回收的性能才有了好转。这套机制最终的目标就是在用户业务无感知的情况下实现垃圾回收，希望未来的版本这部分有更优秀的表现。
### 14.1 变量的生命周期
**go中一个变量的有效周期只取决于是否可达**，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在
### 14.2 堆栈分配
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。比如某个局部变量x在函数退出后依然可以通过包一级的global变量找到，那么x必须在堆上分配内存，用Go语言的术语说，这个x局部变量从函数f中逃逸了
## 五. 问题
1. 因式分解
3. 编程范式
4. Erlang风格的并发模型
5. go支持Erlang语言为代表的面向消息编程思想
6. 不清楚go的稳定性，所以目前很多公司还不太敢用
7. 从源码安装软件怎么操作？二进制发行版和安装版的区别？
8. return的几种用法
9. go省略返回值形参，只有形参类型的写法
10. protobuf的获得和使用
11. go get如果后面是xxx.go而不是项目的名字，那么引入的是这一个go文件还是整个项目？
12. go的闭包
13. go generate 生成代码
14. go type的几种写法
15. why golang don't support Stored Procedure or Generic?
16. 一些文章
    1. [http://blog.csdn.net/libaineu2004/article/details/49722651](http://blog.csdn.net/libaineu2004/article/details/49722651)

17. go声明字符串和多行字符串可用``(加入笔记)
18. go new 对象
19. 协程是什么
20. 可做笔记
    1. [Golang json用法详解（一）](https://www.cnblogs.com/yangshiyu/p/6942414.html)

21. 网友:string []byte 的转换是会拷贝的?