# goroutine

# 一 概述
golang的goroutine笔记，因为内容复杂，所以单独弄一个笔记，主要是goroutine，也包括相关的内容。

## 3 常识
### 3.1 linux进程分类
- 内核线程（或者叫核心进程）：
    1. 内核线程没有独立的地址空间
    2. 只在内核空间运行，从来不切换到用户空间去。内核进程和 普通进程一样，可以被调度，也可以被抢占
- 用户进程
- 用户线程

# 三 基础
## 1 线程的状态
阻塞、唤醒、执行、销毁、挂起、睡眠、休眠（待整理）

## 1 sync.WaitGroup
作用：它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成

# 四 高级
## 1 go的线程模型
三个核心元素支撑起了这个模型的主框架：
- M：machine的缩写。一个M代表一个内核线程，或者“工作线程”。
- P：processor的缩写。一个P代表执行一个Go代码片段所必需的资源（或称“上下文环境”）。
- G：goroutine的缩写。一个G代表一个Go代码片段。前者是对后者的一种封装。

## 2 go的CSP并发模型
CSP模型：是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel

CSP

哲学：不要通过共享内存来通信， 应该通过通信来共享内存。

# 六 问题

# 七 未整理
1. 死锁，活锁，优先级反转
2. 基于内存共享和基于消息共享内存的对比
3. 网友：goroutine 并不是 “把异步回调的代码用同步的方式来写”。而是在用户空间实现了一个 M 对 N 的调度器。

    简单来讲，异步回调一般只开一个线程，有任务了之后会把让这个线程去执行这个任务，无法利用多核。

    而 goroutine 会根据机器的运行情况开 N 个操作系统级别的线程，然后把 M 个用户级别的 goroutine 调度到这 N 个线程上。

    golang 团队一直引以为傲的就是这个 M 对 N 的调度器，这种 M 对 N 调度器在业界也算是比较先进的。

    1. 网友2：其实就是用户态线程
    2. 网友3：goroutine 是个很神奇的东西，他的调度能在行级，不是简单的 yield 一下就做到的。这种特性可以保证某个线程不会被拿不到资源被饿死。我也不相信 java 用线程模型造出来的东西性能可以好到哪里。
    3. 网友4：golang 对内部所有可能的阻塞系统调用都做了封装, 当遇到可能发生阻塞的系统调用自动切换, 关于这方面可以浏览相关 goroutine 切换原理.

4. 内核和用户态