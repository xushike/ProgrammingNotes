# java
[TOC]
## 一. 概述
1. ide(eclipse)中，设置里的compiler版本是jdk的编译版本，而installed JREs是jre(运行环境)的版本，前者不应该比后者高，否则编译出来会出问题，大概就是：  
>JDK1.5编译的程序在JRE1.6中能不能运行？可以。
>JDK1.6编译的程序在JRE1.5中能不能运行？一定不可以。  

比如我前者是1.7，后者是1.6，当我代码打包后放到用1.7去运行应该没问题，但是用1.6去运行就可能出问题。
在eclipse中每个项目可以单独设置自己的compiler版本(即jdk的版本)，但是jre的版本是和eclipse的设置通用的。
还有运行时服务器需要的jdk or jre版本我还没研究，因为目前我都是在jetty容器中测试的，而上面的可能只是针对项目，跟容器可能不一样，所以上面的结论可能都是错的(虽然网友也是上面的结论)。
再加一条网友的结论吧：
>Java Compiler选择的版本必须和'Project Facets'中指定的java版本一致。
>否则eclipse会抛异常：Java compiler level does not match the version of the installe

2. 关于project facets，相当于针对语言或者框架的首选项，比如里面的java设置了1.6，那么我新建一个项目，某人的jdk应该是1.6(当然我还要测试一下这个设置和项目以及ide设置的优先级才能确定)

3. 在eclipse中我引入了dorado-hibernate的jar包，引用其中的方法没问题，但是点进去想看看方法的实现结果显示source not found，于是百度出解决方法：  
安装jd-gui
### 1.2关于clazz、Klass、JavaClass、ClassMirror等
RednaxelaFX大神的解释说是C++里class是关键字，所以要避开，就用这几个代替成习惯吧

## 二. 安装配置
### 2.1 windows下的安装配置
1. 下载jdk并安装，路径中不能有中文，最好不要有空格
2. 配置PATH、JAVA_HOME、CLASSPATH（ClASSPATH在1.5之后可以不用配置，最好配上）
    1. PATH的目的是将`jdk/bin`目录添加到执行路径中
    2. CLASSPATH的目的是告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包。（注意配置的时候前面加上.，待补充）
3. 安装库源文件和文档
    1. 库源文件在是jdk目录中src.zip
    2. 文档去官网下载，一般是jdk-version-docs-all.zip
4. 命令行下的简单运行
```
javac xxx.java  //编译
java xxx        //运行
```
5. 如果上面都配置正确了，结果运行的时候发现java或者javac其中某个不能正确运行，那么可能是
    1. java能运行但javac不行（似乎跟C:\Windows\System32里的三个java执行程序有关，待补充）
    2. javac能运行但java不行：
    我当时出现这个情况是因为我的java文件是在eclipse下写的，文件头声明了自己建的包，此时有两种解决办法，一种是去掉声明的包运行，第二种是不去掉包的声明直接去包所在的目录运行java文件，比如我的包名是study，那么我应该去study所在的目录执行
    ```
    javac study/XXX.java
    java study/XXX
    ```

### 2.2 mac下的安装配置
1. 安装后的路径查看：mac上安装之后查看java路径：
```
/usr/libexec/java_home
```
一般显示结果是：/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home
2. 将`jdk/bin`目录添加到执行路径中——执行路径是操作系统查找可执行文件时所遍历的目录列表
（此处待补充）
### 2.3 linux下的安装配置
1. 如果是prm文件安装，则检查是否在`/usr/java/jdk1.8_version`下；但是推荐下载.tar.gz格式的文件安装，可以直接解压到任何地方

## 三. 基础
### 3.1 面向对象
#### 3.1.1 类、对象、构造器、方法
##### 3.1.1.1  类和对象
##### 3.1.1.2  构造器
##### 3.1.1.3  方法
##### 3.1.1.4  成员变量和局部变量
#### 3.1.2 java三大特性
##### 3.1.2.1 封装
##### 3.1.2.2 继承
##### 3.1.2.3 多态polymorphism
指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
### 3.2 字符串
String对象是不可变的，这里的不可变指的字符串对象本身，比如
```java
String str="hello";
str="world";
```
字符串"hello"被创建后不可变，但是str作为引用可以指向别的字符串
#### 3.2.1 字符串的创建
##### 3.2.1.1 字面量创建
```java
String str1="aaaa";
```
JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容（用equels()比较）的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用
##### 3.2.1.2 使用new创建
```java
String str1=new String("aaaa");
```
使用new来构造字符串对象的时候，JVM首先也会对这个字面量进行检查，有就不管，如果没有就创建，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。此时想将这个对象的引用加入到字符串常量池，可以使用intern方法。调用intern后，首先检查字符串常量池中是否有该对象的引用，如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。（这里也有问题，网上的资料基本都是说的new会在堆中创建String对象，同时会复制该对象到字符串常量池中，待补充）
###### 3.2.1.2.1 关于new创建了几个对象
注意这里的new指的直接new，和用"+"连接的new表达式是不一样的。网上大部分观点都是创建了一个或两个：在类加载时，如果常量池有该字符串，则不创建，如果没有，则在常量池中创建一个该字符串；然后在类执行时，会从常量池复制一个对象到堆中(还有另外一种说法：加载时不确定，在执行的时候先在常量池中中创建"aaaa"字面量，然后创建new String（"aaaa"）对象)
##### 3.2.1.3 使用+创建(难点)
1. 只有使用引号包含文本的方式或者加上final的变量创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。
2. 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。（根本原因在于它的值在编译期无法确定，只有在程序运行期调用方法后才能知道，类似的还有通过函数获取的字符串值）
    典型的例子是
```java
        String str2 = new String("str")+new String("01");
        str2.intern();
        String str1 = "str01";
        System.out.println(str2==str1);
        System.out.println(str2==str2.intern());
        System.out.println(str1==str2.intern());
```
在jdk1.6下输出的结果是：false false true
在jdk1.7及以上输出的结果是：true true true
这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。

#### 3.2.2 字符串常量池
也叫字符串驻留池
##### 3.2.2.1 常量池存的是字符串对象引用还是对象
字符串是字面量，网友的观点也是各不相同，两种说法都有道理，我个人觉得可以把字面量(本质是char数组)看作jvm特殊处理过的对象，可以存在常量池中，这样就两种都有，很多地方就可以更好地解释。
##### 3.2.2.2 字符串的垃圾回收
字符串常量池中持有了共享的字符串对象的引用，这就是说是不是会导致这些对象无法回收？
>在早期的版本中确实存在这样的问题，但是随着弱引用的引入，目前这个问题应该没有了。
（待补充）
##### 3.2.2.3 优缺点
* 优点：节省内存空间，
* 缺点：牺牲了CPU计算时间来换空间，不过内部实现为HashTable，所以计算成本较低。（也有大神做实验发现常量池中String多了之后常量池的速度会降下来。）
## 五. 问题
1. 公有和私有jre的区别，什么时候用到？
