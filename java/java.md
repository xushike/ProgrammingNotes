# java
[TOC]
## 一. 概述
1. ide(eclipse)中，设置里的compiler版本是jdk的编译版本，而installed JREs是jre(运行环境)的版本，前者不应该比后者高，否则编译出来会出问题，大概就是：  
>JDK1.5编译的程序在JRE1.6中能不能运行？可以。
>JDK1.6编译的程序在JRE1.5中能不能运行？一定不可以。  

比如我前者是1.7，后者是1.6，当我代码打包后放到用1.7去运行应该没问题，但是用1.6去运行就可能出问题。
在eclipse中每个项目可以单独设置自己的compiler版本(即jdk的版本)，但是jre的版本是和eclipse的设置通用的。
还有运行时服务器需要的jdk or jre版本我还没研究，因为目前我都是在jetty容器中测试的，而上面的可能只是针对项目，跟容器可能不一样，所以上面的结论可能都是错的(虽然网友也是上面的结论)。
再加一条网友的结论吧：
>Java Compiler选择的版本必须和'Project Facets'中指定的java版本一致。
>否则eclipse会抛异常：Java compiler level does not match the version of the installe

2. 关于project facets，相当于针对语言或者框架的首选项，比如里面的java设置了1.6，那么我新建一个项目，某人的jdk应该是1.6(当然我还要测试一下这个设置和项目以及ide设置的优先级才能确定)

3. 在eclipse中我引入了dorado-hibernate的jar包，引用其中的方法没问题，但是点进去想看看方法的实现结果显示source not found，于是百度出解决方法：  
安装jd-gui
### 1.2关于clazz、Klass、JavaClass、ClassMirror等
RednaxelaFX大神的解释说是C++里class是关键字，所以要避开，就用这几个代替成习惯吧

### 1.4 java工具和进程
#### 1.4.1 jar（Java Archive File）
意思是java档案文件，与zip兼容，与zip的区别是jar文件中默认包含了META-INF/MANIFEST.MF的清单文件，该文件在生成jar文件时自动创建。
#### 1.4.2 jusched
jusched.exe是与Java有关的一个进程，每当Java检测到更新时，此进程就会出现在任务栏管理器的进程列表中，不过好在一般一个月才会检测一次，但问题是这个进程会占用极大的CPU和内存，往往会造成机器很卡。 
#### 1.4.3 java

## 二. 安装配置
### 2.1 windows下的安装配置
1. 下载jdk并安装，路径中不能有中文，最好不要有空格
2. 配置JAVA_HOME、PATH、CLASSPATH（ClASSPATH在1.5之后可以不用配置，最好配上）
    1. PATH的目的是将`jdk/bin`目录添加到执行路径中
    2. CLASSPATH的目的是告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包。（注意配置的时候前面加上.，待补充）
3. 安装库源文件和文档
    1. 库源文件在是jdk目录中src.zip
    2. 文档去官网下载，一般是jdk-version-docs-all.zip
4. 命令行下的简单运行
```
javac xxx.java  //编译
java xxx        //运行
```
5. 如果上面都配置正确了，结果运行的时候发现java或者javac其中某个不能正确运行，那么可能是
    1. java能运行但javac不行（似乎跟C:\Windows\System32里的三个java执行程序有关，待补充）
    2. javac能运行但java不行：
    我当时出现这个情况是因为我的java文件是在eclipse下写的，文件头声明了自己建的包，此时有两种解决办法，一种是去掉声明的包运行，第二种是不去掉包的声明直接去包所在的目录运行java文件，比如我的包名是study，那么我应该去study所在的目录执行
    ```
    javac study/XXX.java
    java study/XXX
    ```

### 2.2 mac下的安装配置
1. 安装后的路径查看：mac上安装之后查看java路径：
```
/usr/libexec/java_home
```
一般显示结果是：/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home
2. 将`jdk/bin`目录添加到执行路径中——执行路径是操作系统查找可执行文件时所遍历的目录列表
（此处待补充）
### 2.3 linux下的安装配置
1. 如果是prm文件安装，则检查是否在`/usr/java/jdk1.8_version`下；但是推荐下载.tar.gz格式的文件安装，可以直接解压到任何地方

## 三. 基础
### 1 面向对象
#### 1.1 类、对象、构造器、方法
##### 1.1.1  类和对象
定义类的主要作用就是定义变量、创建实例和作为父类被继承。
###### 1.1.1.1  对象的this引用
this关键字总是指向调用该方法的对象。所以static修饰的方法里不能使用this。
可以用在在类的一个方法里调用另一个方法（如果不加this就需要在方法里再创建一个实例），也可以用于调用类的成员变量（比如局部变量和成员变量同名的时候），使编程更加灵活。
###### 1.1.1.2  super
1. 用于限定该对象调用的它从父类继承得到的实例变量或方法，super如this一样不能出现在static修饰的方法中
###### 1.1.1.3  不可变类
1. 不可变类指的的是...
2. java的八个包装类和String都是不可变类
3. 不可变类的实力状态不会改变，所以如果经常使用到的不可变类，可以考虑缓存，然后共享
比如
```java
Integer in1 = new Integer(6);//这种方式不会缓存
Integer in2 = Integer.valueOf(6);//用这种方式创建，会缓存(-128~127)之间的Integer对象
Integer in3 = Integer.valueOf(6);
System.out.println(in1 == in2);//输出false
System.out.println(in3 == in2);//输出true
```
###### 1.1.1.4  抽象类
在某些情况下，父类只是知道其子类应该包含怎样的方法，但无法准确的知道子类如何实现这些方法。这个时候就可以用抽象类。
>比如有个Shape类，这个类应该提供一个计算周长的方法callPerimeter()，但不同的子类对周长的计算不一样，即Shape也不知道子类会如何实现该方法。有人会问，不知道那就不管它不就行了。这不是一个好思路，这样的话Shape类就不能调用该方法了，必须强制转换成其子类才能调用，降低了程序的灵活性。
所以抽象类的作用是为子类提供模板，避免子类设计的随意性。

抽象类和抽象方法的规则如下：
1. 都必须用abstract修饰，而且定义抽象类只需要在普通类上增加abstract修饰符即可
2. 抽象类不能被实例化，所以抽象类的构造器主要用于被其子类调用（抽象类只能被继承），抽象方法必须由子类提供实现（即重写，所以抽象方法不能用private修饰）。而final修饰的类不能被继承，final修饰的方法不能被重写，所以final和abstract永远不能同时使用。
3. 抽象方法不能有方法体
4. 含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法这三种情况）只能被定义为抽象类
5. abstract只能修饰类和方法，不能修饰构造器等
6. static和abstract不能同时修饰某个方法，但是可以同时修饰内部类
7. 抽象类可以包含成员变量、方法(普通方法和抽象方法都可以)、构造器、初始化块、内部类（接口、枚举）5种成分。
###### 1.1.1.5  接口
接口可以看做是抽象类的更抽象，接口是多个相似类抽象出来的规范，接口不提供任何实现（接口里不能包含普通方法），接口里的所有方法都是抽象方法。java8对接口进行了改进，允许在接口中定义默认方法。
接口体现的是规范和实现分离的设计哲学。接口定义的是多个类共同的公共行为规范，意味着接口里通常是定义一组公用方法。
1. 接口的修饰符可以是public或省略，省略的话则默认采用包权限访问修饰符。
2. 一个接口可以有多个直接父接口（接口的继承和类继承不一样，接口支持多继承），但接口只能继承接口，不能继承类。接口也不能实现(implements)接口
3. 接口定义的是一种规范，所以接口里不能包含构造器和初始化块，可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）这3种，区别于抽象类中5种都有。接口里的所有成员都是public访问权限，如果省略也会默认加上public，而且，对于接口里的静态常量，还会自动加上static final;对于接口里的普通方法，还会自动加上abstract修饰符；对于接口里的默认方法(java8新增)，必须**自己加上default**修饰符，且默认方法只能用public default修饰；对于接口里的类方法，必须**自己加上static**修饰，且只能用public static修饰；对于接口里的内部类，还会自动加上static；
4. 一个类可以实现多个接口，也就是java提供的所谓的模拟多继承
5. 如果一个类实现接口后没有实现接口里的所有抽象方法，那这个类必须声明为抽象类
###### 1.1.1.6  抽象类和接口异同
1. 前者主要是用于模板设计，被子类继承；后者主要是体现一种规范，被其他类遵守、实现
2. 两者都不能实例化
3. 前者包含5种成员，后者只能有3种；而且前者可以包含普通方法，后者不能
###### 1.1.1.7  内部类(待补充)

##### 1.1.2  构造器
1. java语法规定：构造器返回类的实例，无需定义返回类型，不要显示调用return。
2. 在程序创建对象的时候，在调用构造器之前其实就已经创建了一个对象，只不过此时该对象不能被外部程序访问，只能在改构造器中用this来引用。
3. 构造器重载：类似方法的重载，但是，想在一个构造器中使用另一个构造器，则可以使用this（形参）的方式来调用，如果使用this来调用构造器，则this必须放在构造体的第一行。
4. 用super调用父类的构造器与this类似
5. 当子类初始化时，父类构造器总会在子类构造器之前执行，而且一直上溯其父类构造器，所以创建任何java对象，最先执行的总是java.lang.Object类的构造器
##### 1.1.3  方法
1. 方法声明中的参数为形参，调用时传进去的参数为实参
2. java方法参数的传递方式为**值传递**，即将实际参数值的副本（复制品）传入方法内，而参数本身不会受任何影响。
3. 形参个数可变的方法：jdk1.5后允许，在最后一个形参的类型后加三个点表明该形参可以接受多个参数值。形参个数可变的参数的本质就是一个数组参数。
数组形式的形参可以处于参数列表的任意位置，但形参个数可变的形参只能处于形参列表的最后，也就是说一个方法中最多只能有一个形参个数可变的形参。
4. 递归方法：方法体重调用了方法自身就是递归方法，递归一定要向已知方向递归。常用于数学函数、遍历路径下所有的文件等。
5. 方法重载：同一个类中方法名下相同，参数列表不同（包括参数的顺序、个数和类型？）。至于其他部分，比如方法返回值类型、修饰符等，与方法重载没有关系。
##### 1.1.4  成员变量和局部变量
![](../picture/java/0-5-bianliang.jpg "java成员变量和局部变量（图片来自网络）")

1. 成员变量无需显示初始化，系统会进行默认初始化，默认初始化规则和数组一样。
2. 局部变量包括：形参、方法局部变量、代码块局部变量。前两者在方法内有效。除了形参之外，另外两个必须显示地初始化。
3. 能用局部变量就尽量用局部变量，这样程序的性能会更好。
###### 1.1.4.1 访问修饰符

![](../picture/java/0-6-AccessModifiers.jpg "java访问修饰符（图片来自于网络）")
1. 注意：如果java源文件里定义的所有类都没有public修饰，则该源文件的文件名可以是任何一个合法的文件名。如果源文件里定义了一个public修饰的类，则源文件名必须和public修饰的类的类名相同。
2. 如果一个java类的所有实例变量都用private修饰，并为每个实例变量提供了public修饰的setter和getter方法，那么这个类就是一个符合JavaBean规范的类。
3. 使用原则：
    1. 有些方法只用于辅助实现该类的其他方法，这些方法被称为工具方法，应该用private修饰。
    2. 如果某个类主要用作其他类的父类，该类里大部分方法可能仅希望被其子类重写，而不想被外界直接调用，则应该使用protected修饰这些方法。
    3. 希望暴露出来给其他类自由调用的方法应该用public修饰，因此，类的构造器通过使用public修饰允许在其他地方创建该类的实例。
###### 1.1.4.2 其他修饰符分类
1. 按类修饰符分：public、abstract、final、默认
2. 按成员变量修饰符分：public、private、protected、默认、final、static、transient（过渡修饰符）、volatile（易失修饰符）
3. 按方法修饰符分：public、private、protected、final、static、synchronize、native
4. 具体介绍
    1. static
        1. 静态初始化块比普通初始化块先执行
        2. 静态成员不能访问非静态成员
    2. final
        1. final修饰的成员变量必须显式地赋初值，且只能赋一次
        2. final如果修饰引用类型，则只保证引用类型所引用的地址不变，即一直引用同一个对象，但这个对象完全可以改变
        ```java
        final int[] iArr = {1,3,99};
        iArr[2] = -8;//合法
        iArr = null;//对iArr重新赋值，非法
        ```
        3. final修饰的方法仅仅是不能被重写，并不是不能被重载

###### 1.1.4.3 package和import
1. import可以导入指定包层次下的某个或全部类，jdk1.5后增加了静态导入import static，可以导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。一句话归纳就是：import可以省略写包名，而使用import static则可以连类名都省略了。
#### 1.2 面向对象的三大特性
##### 1.2.1 封装
##### 1.2.2 继承
子类继承（extends）了父类，也可以说成父类派生（derive）了子类。extends的意思是扩展，但是国内翻译成继承，更加形象。
1. java子类没有继承父类的构造器（待补充）
2. 不要在父类构造器中调用将要被子类重写的方法（可能会引发空指针异常等）
3. 如果父类的构造器都用private修饰，那么子类将无法调用父类的构造器，也就无法继承父类
4. 关于何时使用继承
    1. 子类需要额外增加的属性，而不仅仅是属性值的改变
    2. 子类需要增加自己独有的行为方式(包括增加新的方法或重写父类的方法)
###### 1.2.2.1 override（重写）
子类包含与父类同名方法的现象称为方法的重写（override）
1. 方法的重写遵循“两同两小一大”（待补充）的原则，而且覆盖方法和被覆盖的方法要么都是类方法，要么都是实例方法。
2. 子类中调用父类中被覆盖的方法：如果是实例方法，用**super**；如果是类方法，用**类名**
3. 如果子类定义了和父类同名的实例变量，则会发生子类实例变量隐藏父类实例变量的情形。注意不是完全覆盖，系统依然会为被隐藏的变量分配内存空间。
4. 对于父类中private(或final private)修饰的方法，子类可以定义与其具有相同方法名、相同形参列表和返回值的方法，但是这不是方法的重写，而是重新定义一个方法。
###### 1.2.2.2 overload（重载等）
1. 注意：父类方法和子类方法之间也可能发生重载，只需要子类中定义一个与父类方法名相同但参数列表不同的方法。

###### 1.2.2.3 组合
因为java的继承有个最大的缺点：破坏封装。所以有时候也可以考虑用组合，简单讲，组合就是把其他类当成另一个类的组合成分，最好用private修饰。组合和继承的开销是一样的。
1. 什么时候用继承或组合
要看两个类所代表的现实意义之间的关系：比如动物和猫、狗，如果用动物组合成猫狗就不合适，用继承更好；如果是人和手，用组合就好些。一个是is-a，一个是has-a
###### 1.2.2.4 初始化块
1. 初始化块总在构造器之前执行，多个初始化块依次执行
2. 初始化块其实是一个假象，在编译后，初始化块代码会消失，被"还原"到每个构造器中，且位于构造器所有代码的前面
3. 初始化块的修饰符只能是static，修饰后变为静态初始化块，静态初始化块只在类加载时执行，且只执行一次
4. **java创建一个对象时，系统先为该对象的所有实例变量分配内存(前提是该类已经被加载过了)，然后对这些实例变量执行初始化，其初始化顺序是：先执行初始化块或声明实例变量时指定的初始值(根据这两者的源代码的排列顺序)**
##### 1.2.3 多态polymorphism
指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
例如
```java
BaseClass ploymophicBc = new SubClass();
```
编译时类型是BaseClass，运行时类型是SubClass，在编译阶段只能调用BaseClass中声明的方法和变量，但在运行时则执行它运行时类型所具有的方法。如果调用的方法被SubClass重写了，那么会调用被重写的方法；如果调用的是变量，那么会用BaseClass的变量(实例变量不具备多态性)；如果直接调用仅SubClass有的方法，编译时会报错(但是可以通过反射来执行该方法)。
总结就是：**相同类型的变量，调用同一个方法时呈现多种不同的行为特征，这就是多态。**

###### 1.2.3.1 引用类型的类型转换
1. 引用类型的自动类型转换
java允许把子类对象直接赋给父类引用对象，无须任何类型转换，或者被称为向上转型(Upcasting)，向上转型由系统自动完成。
2. 引用类型的强制类型转换
只能在具有继承关系的两个类型之间进行，因此可以在转换之前先通过**instanceOf**(用于判断前面的对象是否是后面的类、子类、实现接口的实例)运算符来判断，让程序更健壮。

### 2 数据类型和运算符
java是一门强类型语言，强类型的包括两个含义：
1. 所有变量必须先声明、后使用
2. 指定类型的变量只能接受类型匹配的值
强类型语言可以在编译时发现代码错误，保证程序更加健壮
#### 2.1 注释
##### 2.1.1 为什么要用注释
1. 不要过于相信自己的理解力，不加注释过段时间可能就看不懂了
2. 可读性第一，效率第二
3. 代码即文档
##### 2.1.2 三种注释类型
1. 单行注释
```java
//XXX
```
2. 多行注释
```java
/*
XXX
*/
```
3. 文档注释:通过jdk的javadoc工具可以将文档注释提取成一份系统的api文档
```java
/**
XXX
*/
```
#### 2.2 标识符和关键字
##### 2.2.1 分隔符
包括分号、花括号、方括号、圆括号、空格、圆点
##### 2.2.2 标识符
1. 以字母、下划线、美元符开头，后门可以跟任意的字母、下划线、美元符和数字，这里的字母不局限于英文，也包括中文、日文等
2. java支持Unicode6.2.0字符集，所以标识符可以使用Unicode6.0.0所能表示的多种语言字符
3. 不能包含空格和特殊符号（@、#等）
##### 2.2.3 关键字（keyword）
1. java所有关键字都是小写的
#### 2.3 数据类型
![](../picture/java/0-4-primitiveType.png "java数据类型")
##### 2.3.1 基本数据类型
jdk7引入了新功能，可以在数值中使用下划线，可以更直观地分辨数值，不影响数值。
###### 2.3.1.1 整型
1. byte:在内存里占8位，即1个字节，表数范围-128(-2^7^)到127(2^7^-1)
2. short
3. int
4. long
###### 2.3.1.2 字符型
通常用于表示单个的字符，必须用单引号包裹，java语言使用16位的Unicode字符集作为编码方式。而Unicode被设计成支持世界上所有书面语言的字符。char类型的值可以直接作为整型值来使用。
字符型有三种表示方式：
1. 直接的单个字符，如：'a'
2. 通过转义字符表示特殊的字符型值：'\n'、'\t'
![](../picture/java/0-2-character.jpg "常见转义字符")
3. 直接用Unicode值来表示，格式是'\uXXXX'，XXXX代表一个十六进制的整数，范围是'\u0000'到'\uFFFF'，一共可以表示65536个，其中前256个（'\0000'到'\00FF'）和ASCII码中的字符完全重合
###### 2.3.1.3 浮点型
java默认的浮点数类型是double，如果要用float，应该在尾部加上F或者f。double比float精确，两者都可能不能精确表示一个浮点数，如果需要精确保存一个浮点数，可以用BigDecimal类。
java表示浮点数的两种形式：
1. 十进制
2. 科学计数法形式：如5.12e2（即5.12*10^2^）（而且只有java中只有浮点数才可以用科学计数法表示）
java有三个特殊的浮点数值用来表示溢出和出错：
1. 正无穷大：POSITIVE_INFINITY
2. 负无穷大:NEGATIVE_INFINITY
3. 非数：NaN
关于正负无穷大的细节：
1. 所有的正无穷大都是相等的，负无穷也是，而NaN不和任何数相等，包括自身
2. 只有浮点数除以0才可以得到正负无穷大，因为java会自动把浮点数运算的0当作0.0处理，而整数值除以0会抛出ArithmeticException：/by zero异常
###### 2.3.1.4 布尔型
##### 2.2.1.5 关于类型转换
###### 2.2.1.5.1 自动类型转换

![](../picture/java/0-3-typeChange.jpg "java自动类型转换")

1. 特别的：当把基本类型的值和字符串进行连接运算时，基本类型的值会自动转换为字符串类型。如
```java
int a=9527；
String str=a+""; //str="9527"
System.out.println(3+4+"hello");//7hello
```
```java
System.out.println("Hello"+'a'+7);//Helloa7
System.out.println('a'+7+"Hello");//104Hello
```
2. 表达式类型的自动提升，当一个算术表达式中包括多个基本类型的值时（不管这些基本类型是不是同一类型）：
    1. 所有byte、short、char都将提升到int,典例：
    ```java
    short a = 5;
    a = a-5;//右边的a-5已经被提升到int类型了，但左边还是short类型，从而引起错误
    ```
    2. 整个算术表达式的数据类型自动提升到表达式中最高等级操作数同样的类型
    >第二条是严格遵守的，比如两个整数相除除不尽，也会把结果转成整数
    

###### 2.2.1.5.2 强制类型转换
1. 把浮点整数强制转换成整数时，java将直接截断浮点数的小数部分。
还有下面这个例子容易出错：
```java
float a = 5.6//5.6是double型，应该用强转
```
2. 字符串转基本类型可以通过基本类型对应的包装类实现：
```java
String a = "45";
int iValue = Integer.parseInt(a);
```

##### 2.3.2 引用数据类型
引用类型包括类、接口和数组。还有一个null类型，可以被忽略，实际开发的时候可以看做引用类型的一个特殊直接量。
##### 2.3.3 java中的进制
java中整型有四种表示方式：二、八、十、十六进制
1. 二进制：jdk7新增了对二进制整数的支持，以0B、0b开头
2. 八进制：以0开头
3. 十六进制：以0x、0X开头，10到15用以a~f表示（不分大小写）
##### 2.3.4 关于原码、补码、反码
所有数字在计算机底层都是以二进制的形式存的，原码是直接将一个数值换算成二进制数。计算机以补码的形式保存所有的整数。正数的补码和原码相同，负数的补码是其反码+1。反码是对原码按位取反，只是最高位（符号位）保持不变。

#### 2.4 运算符
java中运算符分为：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、类型相关运算符
##### 2.4.1 算术运算符
java的7个基本算术运算符：加减乘除、求余、自加自减
1. 求余：求余的结果不一定总是整数
```java
double a = 5.2;
double b = 3.1;
System.out.println(a%b);//2.1
```
2. 自加自减;不能操作常量或表达式
##### 2.4.2 位运算符（难点，待补充）
##### 2.4.3 扩展后的赋值运算符
1. 只要能使用就使用，因为扩展后的赋值运算符性能更好，而且程序会更加健壮
```java
byte a = 5;
//a = a +2;
a += 2;//用上面那个就会报错，但是这个就不会
```
##### 2.4.4 比较运算符
1. ==：如果比较的是数值类型，即使他们的数据类型不同，只要值相同就会返回true；
```java
97=='a';
5.0==5;
//以上两个都返回true
```
如果比较的是引用类型，那么只有当两个引用变量的类型具有父子关系时才可以比较（不然会报Incompatible operand types错误），而且两个引用指向同一个对象才会返回true。也支持两个boolean类型的比较。
##### 2.4.5 运算符的结核性和优先级

### 3 流程控制
#### 3.1 分支结构
java有两种：if和switch
##### 3.1.1 if
```java
int a=4;
if(a>3)
    a--;
    System.out.println("a大于3");//这里会报错，因为下面的else和上面的if并没有匹配上
else
    System.out.println("a不大于3");
```

##### 3.1.2 switch
switch的控制表达式的数据类型只能是byte、short、int、char四种，jdk7开始才支持java.lang.String(注意不是StringBuffer或StringBuilder)
#### 3.2 循环结构
##### 3.2.1 while
##### 3.2.2 do while
##### 3.2.3 for循环
1. 在循环体中加上continue的时候，和上面两个while循环的处理是不一样的：上面两个循环会直接停掉；而for循环因为迭代语句不在循环体中，所以只是会停止本次循环体的剩余部分，然后继续下一次的迭代。
2. 建议不要在循环体内修改循环变量（也叫循环计数器）
3. 选择循环变量时，习惯上用i、j、k
#### 3.3 控制循环结构
java提供了continue、break来控制循环结构，还有return可以结束整个方法。
##### 3.3.1 break
1. 直接使用，可以完全结束其所在的循环
2. 后面跟标签的时候，可以结束标签所在的外层循环
```java
public static void main(String[] args) {
		outer:
		for (int i = 0; i < 5; i++) {
			for (int j = 0; j <6; j++) {
				System.out.println(j);//输出：0    1
				if(j==1){
					break outer;
				}
			}
		}
	}
```
##### 3.3.2 continue
用法跟break类似，只不过continue是跳过本次循环剩下的语句，也可以在后面加标签
##### 3.3.3 return
return直接结束整个方法，不管在多少层循环之内
### 4 数组
1. 定义数组的时候不能指定数组的长度，因为定义时只是定义了一个引用变量，并未指向任何有效的内存。
2. 初始化分为两种
#### 4.1 数组的初始化
注意：不能同时使用静态和动态初始化。
##### 4.1.1 静态初始化
##### 4.1.2 动态初始化
只指定数组的长度，由系统为每个数组元素指定初始值。
* 整数类型：初始值为0
* 浮点类型：初始值为0.0
* 字符类型：初始值为'\u0000'
* 布尔类型：初始值为false
* 引用类型：初始值是null

#### 4.2 foreach循环
jdk5之后又了foreach循环。使用foreach循环无需获取数组长度和索引，迭代的时候将每次访问的数组元素的值赋给临时变量，改变这个临时变量并不能改变数组元素的值。
#### 4.3 java8增强工具类：Arrays
java.util.Arrays里包含了一些static方法，可以直接操作数组（待补充）:
1. int binarySearch(type[] a,type key)：用二分法查询元素key在数组a中的索引，如果没有则返回负数，要求a已经按升序排列。
还提供了利用多cpu的工具方法（待补充）：











### 2 字符串
String对象是不可变的，这里的不可变指的字符串对象本身，比如
```java
String str="hello";
str="world";
```
字符串"hello"被创建后不可变，但是str作为引用可以指向别的字符串
#### 2.1 字符串的创建
##### 2.1.1 字面量创建
```java
String str1="aaaa";
```
JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容（用equels()比较）的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用
##### 2.1.2 使用new创建
```java
String str1=new String("aaaa");
```
使用new来构造字符串对象的时候，JVM首先会去常量池对这个字面量进行检查，如果没有，就创建字面量，然后放入常量池。然后调用String类的构造器来创建一个新的String对象，保存在堆内存中。对于非"宏替换"生成的字符串，不会去常量池中生成字面量，此时想将这个对象的引用(字面量？)加入到字符串常量池，可以使用intern方法。调用intern后，首先检查字符串常量池中是否有该对象的引用（字面量？），如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。
###### 2.1.2.1 关于new创建了几个对象
注意这里的new指的直接new，和用"+"连接的new表达式是不一样的。答案是创建了一个或两个：在类加载时，如果常量池有该字符串，则不创建，如果没有，则在常量池中创建一个该字符串；然后在类执行时，会从常量池复制一个对象到堆中(还有另外一种说法：在执行的时候先在常量池中中创建"aaaa"字面量，然后创建new String（"aaaa"）对象。两种说法的区别只是创建字面量和对象的时间描述不一致)
##### 2.1.3 使用+创建(难点)
1. 只有使用引号包含文本的方式或者加上final的变量创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。（涉及到"宏替换"，待补充）
2. 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。（根本原因在于它的值在编译期无法确定，只有在程序运行期调用方法后才能知道，类似的还有通过函数获取的字符串值）
    典型的例子是
```java
        String str2 = new String("str")+new String("01");
        str2.intern();
        String str1 = "str01";
        System.out.println(str2==str1);
        System.out.println(str2==str2.intern());
        System.out.println(str1==str2.intern());
```
在jdk1.6下输出的结果是：false false true
在jdk1.7及以上输出的结果是：true true true
这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串（字面量）拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。

#### 2.2 字符串常量池
也叫字符串驻留池
##### 2.2.1 常量池存的是字符串对象引用还是对象
字符串是字面量，网友的观点也是各不相同，两种说法都有道理，我个人觉得可以把字面量(本质是char数组)看作jvm特殊处理过的对象，可以存在常量池中，这样就两种都有，很多地方就可以更好地解释。
##### 2.2.2 字符串的垃圾回收
字符串常量池中持有了共享的字符串对象的引用，这就是说是不是会导致这些对象无法回收？
>在早期的版本中确实存在这样的问题，但是随着弱引用的引入，目前这个问题应该没有了。
（待补充）
##### 2.2.3 优缺点
* 优点：节省内存空间，
* 缺点：牺牲了CPU计算时间来换空间，不过内部实现为HashTable，所以计算成本较低。（也有大神做实验发现常量池中String多了之后常量池的速度会降下来。）
## 五. 问题
1. 公有和私有jre的区别，什么时候用到？
2. 如果继承树里的某一个类需要被初始化，则系统会同时初始化该类的所有父类。

