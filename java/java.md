# java
[TOC]
## 一. 概述
1. ide(eclipse)中，设置里的compiler版本是jdk的编译版本，而installed JREs是jre(运行环境)的版本，前者不应该比后者高，否则编译出来会出问题，大概就是：  
>JDK1.5编译的程序在JRE1.6中能不能运行？可以。
>JDK1.6编译的程序在JRE1.5中能不能运行？一定不可以。  

比如我前者是1.7，后者是1.6，当我代码打包后放到用1.7去运行应该没问题，但是用1.6去运行就可能出问题。
在eclipse中每个项目可以单独设置自己的compiler版本(即jdk的版本)，但是jre的版本是和eclipse的设置通用的。
还有运行时服务器需要的jdk or jre版本我还没研究，因为目前我都是在jetty容器中测试的，而上面的可能只是针对项目，跟容器可能不一样，所以上面的结论可能都是错的(虽然网友也是上面的结论)。
再加一条网友的结论吧：
>Java Compiler选择的版本必须和'Project Facets'中指定的java版本一致。
>否则eclipse会抛异常：Java compiler level does not match the version of the installe

2. 关于project facets，相当于针对语言或者框架的首选项，比如里面的java设置了1.6，那么我新建一个项目，某人的jdk应该是1.6(当然我还要测试一下这个设置和项目以及ide设置的优先级才能确定)

3. 在eclipse中我引入了dorado-hibernate的jar包，引用其中的方法没问题，但是点进去想看看方法的实现结果显示source not found，于是百度出解决方法：  
安装jd-gui
### 1.2关于clazz、Klass、JavaClass、ClassMirror等
RednaxelaFX大神的解释说是C++里class是关键字，所以要避开，就用这几个代替成习惯吧

## 二. 安装配置
### 2.1 windows下的安装配置
1. 下载jdk并安装，路径中不能有中文，最好不要有空格
2. 配置PATH、JAVA_HOME、CLASSPATH（ClASSPATH在1.5之后可以不用配置，最好配上）
    1. PATH的目的是将`jdk/bin`目录添加到执行路径中
    2. CLASSPATH的目的是告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包。（注意配置的时候前面加上.，待补充）
3. 安装库源文件和文档
    1. 库源文件在是jdk目录中src.zip
    2. 文档去官网下载，一般是jdk-version-docs-all.zip
4. 命令行下的简单运行
```
javac xxx.java  //编译
java xxx        //运行
```
5. 如果上面都配置正确了，结果运行的时候发现java或者javac其中某个不能正确运行，那么可能是
    1. java能运行但javac不行（似乎跟C:\Windows\System32里的三个java执行程序有关，待补充）
    2. javac能运行但java不行：
    我当时出现这个情况是因为我的java文件是在eclipse下写的，文件头声明了自己建的包，此时有两种解决办法，一种是去掉声明的包运行，第二种是不去掉包的声明直接去包所在的目录运行java文件，比如我的包名是study，那么我应该去study所在的目录执行
    ```
    javac study/XXX.java
    java study/XXX
    ```

### 2.2 mac下的安装配置
1. 安装后的路径查看：mac上安装之后查看java路径：
```
/usr/libexec/java_home
```
一般显示结果是：/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home
2. 将`jdk/bin`目录添加到执行路径中——执行路径是操作系统查找可执行文件时所遍历的目录列表
（此处待补充）
### 2.3 linux下的安装配置
1. 如果是prm文件安装，则检查是否在`/usr/java/jdk1.8_version`下；但是推荐下载.tar.gz格式的文件安装，可以直接解压到任何地方

## 三. 基础
### 1 面向对象
#### 1.1 类、对象、构造器、方法
##### 1.1.1  类和对象
##### 1.1.2  构造器
##### 1.1.3  方法
##### 1.1.4  成员变量和局部变量
#### 1.2 java三大特性
##### 1.2.1 封装
##### 1.2.2 继承
##### 1.2.3 多态polymorphism
指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
### 2 数据类型和运算符
java是一门强类型语言，强类型的包括两个含义：
1. 所有变量必须先声明、后使用
2. 指定类型的变量只能接受类型匹配的值
强类型语言可以在编译时发现代码错误，保证程序更加健壮
#### 2.1 注释
##### 2.1.1 为什么要用注释
1. 不要过于相信自己的理解力，不加注释过段时间可能就看不懂了
2. 可读性第一，效率第二
3. 代码即文档
##### 2.1.2 三种注释类型
1. 单行注释
```java
//XXX
```
2. 多行注释
```java
/*
XXX
*/
```
3. 文档注释:通过jdk的javadoc工具可以将文档注释提取成一份系统的api文档
```java
/**
XXX
*/
```
#### 2.2 标识符和关键字
##### 2.2.1 分隔符
包括分号、花括号、方括号、圆括号、空格、圆点
##### 2.2.2 标识符
1. 以字母、下划线、美元符开头，后门可以跟任意的字母、下划线、美元符和数字，这里的字母不局限于英文，也包括中文、日文等
2. java支持Unicode6.2.0字符集，所以标识符可以使用Unicode6.0.0所能表示的多种语言字符
3. 不能包含空格和特殊符号（@、#等）
##### 2.2.3 关键字（keyword）
1. java所有关键字都是小写的
#### 2.3 数据类型
![](../picture/java/0-primitiveType.png "java数据类型")
##### 2.3.1 基本数据类型
jdk7引入了新功能，可以在数值中使用下划线，可以更直观地分辨数值，不影响数值。
###### 2.3.1.1 整型
1. byte:在内存里占8位，即1个字节，表数范围-128(-2^7^)到127(2^7^-1)
2. short
3. int
4. long
###### 2.3.1.2 字符型
通常用于表示单个的字符，必须用单引号包裹，java语言使用16位的Unicode字符集作为编码方式。而Unicode被设计成支持世界上所有书面语言的字符。char类型的值可以直接作为整型值来使用。
字符型有三种表示方式：
1. 直接的单个字符，如：'a'
2. 通过转义字符表示特殊的字符型值：'\n'、'\t'
![](../picture/java/0-2-character.jpg "常见转义字符")
3. 直接用Unicode值来表示，格式是'\uXXXX'，XXXX代表一个十六进制的整数，范围是'\u0000'到'\uFFFF'，一共可以表示65536个，其中前256个（'\0000'到'\00FF'）和ASCII码中的字符完全重合
###### 2.3.1.3 浮点型
java默认的浮点数类型是double，如果要用float，应该在尾部加上F或者f。double比float精确，两者都可能不能精确表示一个浮点数，如果需要精确保存一个浮点数，可以用BigDecimal类。
java表示浮点数的两种形式：
1. 十进制
2. 科学计数法形式：如5.12e2（即5.12*10^2^）（而且只有java中只有浮点数才可以用科学计数法表示）
java有三个特殊的浮点数值用来表示溢出和出错：
1. 正无穷大：POSITIVE_INFINITY
2. 负无穷大:NEGATIVE_INFINITY
3. 非数：NaN
关于正负无穷大的细节：
1. 所有的正无穷大都是相等的，负无穷也是，而NaN不和任何数相等，包括自身
2. 只有浮点数除以0才可以得到正负无穷大，因为java会自动把浮点数运算的0当作0.0处理，而整数值除以0会抛出ArithmeticException：/by zero异常
###### 2.3.1.4 布尔型
##### 2.2.1.5 关于类型转换
###### 2.2.1.5.1 自动类型转换

![](../picture/java/0-3-typeChange.jpg "java自动类型转换")

1. 特别的：当把基本类型的值和字符串进行连接运算时，基本类型的值会自动转换为字符串类型。如
```java
int a=9527；
String str=a+""; //str="9527"
System.out.println(3+4+"hello");//7hello
```
```java
System.out.println("Hello"+'a'+7);//Helloa7
System.out.println('a'+7+"Hello");//104Hello
```
2. 表达式类型的自动提升，当一个算术表达式中包括多个基本类型的值时（不管这些基本类型是不是同一类型）：
    1. 所有byte、short、char都将提升到int,典例：
    ```java
    short a = 5;
    a = a-5;//右边的a-5已经被提升到int类型了，但左边还是short类型，从而引起错误
    ```
    2. 整个算术表达式的数据类型自动提升到表达式中最高等级操作数同样的类型
    >第二条是严格遵守的，比如两个整数相除除不尽，也会把结果转成整数
    

###### 2.2.1.5.2 强制类型转换
1. 把浮点整数强制转换成整数时，java将直接截断浮点数的小数部分。
还有下面这个例子容易出错：
```java
float a = 5.6//5.6是double型，应该用强转
```
2. 字符串转基本类型可以通过基本类型对应的包装类实现：
```java
String a = "45";
int iValue = Integer.parseInt(a);
```

##### 2.3.2 引用数据类型
引用类型包括类、接口和数组。还有一个null类型，可以被忽略，实际开发的时候可以看做引用类型的一个特殊直接量。
##### 2.3.3 java中的进制
java中整型有四种表示方式：二、八、十、十六进制
1. 二进制：jdk7新增了对二进制整数的支持，以0B、0b开头
2. 八进制：以0开头
3. 十六进制：以0x、0X开头，10到15用以a~f表示（不分大小写）
##### 2.3.4 关于原码、补码、反码
所有数字在计算机底层都是以二进制的形式存的，原码是直接将一个数值换算成二进制数。计算机以补码的形式保存所有的整数。正数的补码和原码相同，负数的补码是其反码+1。反码是对原码按位取反，只是最高位（符号位）保持不变。

#### 2.4 运算符
java中运算符分为：算术运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、类型相关运算符
##### 2.4.1 算术运算符
java的7个基本算术运算符：加减乘除、求余、自加自减
1. 求余：求余的结果不一定总是整数
```java
double a = 5.2;
double b = 3.1;
System.out.println(a%b);//2.1
```
2. 自加自减;不能操作常量或表达式
##### 2.4.2 位运算符（难点，待补充）
##### 2.4.3 扩展后的赋值运算符
1. 只要能使用就使用，因为扩展后的赋值运算符性能更好，而且程序会更加健壮
```java
byte a = 5;
//a = a +2;
a += 2;//用上面那个就会报错，但是这个就不会
```
##### 2.4.4 比较运算符
1. ==：如果比较的是数值类型，即使他们的数据类型不同，只要值相同就会返回true；
```java
97=='a';
5.0==5;
//以上两个都返回true
```
如果比较的是引用类型，那么只有当两个引用变量的类型具有父子关系时才可以比较（不然会报Incompatible operand types错误），而且两个引用指向同一个对象才会返回true。也支持两个boolean类型的比较。
##### 2.4.5 运算符的结核性和优先级

### 3 流程控制
#### 3.1 分支结构
java有两种：if和switch
##### 3.1.1 if
```java
int a=4;
if(a>3)
    a--;
    System.out.println("a大于3");//这里会报错，因为下面的else和上面的if并没有匹配上
else
    System.out.println("a不大于3");
```

##### 3.1.2 switch
switch的控制表达式的数据类型只能是byte、short、int、char四种，jdk7开始才支持java.lang.String(注意不是StringBuffer或StringBuilder)
#### 3.2 循环结构
##### 3.2.1 while
##### 3.2.2 do while
##### 3.2.3 for循环
1. 在循环体中加上continue的时候，和上面两个while循环的处理是不一样的：上面两个循环会直接停掉；而for循环因为迭代语句不在循环体中，所以只是会停止本次循环体的剩余部分，然后继续下一次的迭代。
2. 建议不要在循环体内修改循环变量（也叫循环计数器）
3. 选择循环变量时，习惯上用i、j、k
#### 3.3 控制循环结构
java提供了continue、break来控制循环结构，还有return可以结束整个方法。
##### 3.3.1 break
1. 直接使用，可以完全结束其所在的循环
2. 后面跟标签的时候，可以结束标签所在的外层循环
```java
public static void main(String[] args) {
		outer:
		for (int i = 0; i < 5; i++) {
			for (int j = 0; j <6; j++) {
				System.out.println(j);//输出：0    1
				if(j==1){
					break outer;
				}
			}
		}
	}
```
##### 3.3.2 continue
用法跟break类似，只不过continue是跳过本次循环剩下的语句，也可以在后面加标签
##### 3.3.3 return
return直接结束整个方法，不管在多少层循环之内
### 4 数组








### 2 字符串
String对象是不可变的，这里的不可变指的字符串对象本身，比如
```java
String str="hello";
str="world";
```
字符串"hello"被创建后不可变，但是str作为引用可以指向别的字符串
#### 2.1 字符串的创建
##### 2.1.1 字面量创建
```java
String str1="aaaa";
```
JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容（用equels()比较）的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用
##### 2.1.2 使用new创建
```java
String str1=new String("aaaa");
```
使用new来构造字符串对象的时候，JVM首先也会对这个字面量进行检查，有就不管，如果没有就创建，不管字符串常量池中有没有相同内容的对象的引用，新的字符串对象都会创建。此时想将这个对象的引用加入到字符串常量池，可以使用intern方法。调用intern后，首先检查字符串常量池中是否有该对象的引用，如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。（这里也有问题，网上的资料基本都是说的new会在堆中创建String对象，同时会复制该对象到字符串常量池中，待补充）
###### 2.1.2.1 关于new创建了几个对象
注意这里的new指的直接new，和用"+"连接的new表达式是不一样的。网上大部分观点都是创建了一个或两个：在类加载时，如果常量池有该字符串，则不创建，如果没有，则在常量池中创建一个该字符串；然后在类执行时，会从常量池复制一个对象到堆中(还有另外一种说法：加载时不确定，在执行的时候先在常量池中中创建"aaaa"字面量，然后创建new String（"aaaa"）对象)
##### 2.1.3 使用+创建(难点)
1. 只有使用引号包含文本的方式或者加上final的变量创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。
2. 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。（根本原因在于它的值在编译期无法确定，只有在程序运行期调用方法后才能知道，类似的还有通过函数获取的字符串值）
    典型的例子是
```java
        String str2 = new String("str")+new String("01");
        str2.intern();
        String str1 = "str01";
        System.out.println(str2==str1);
        System.out.println(str2==str2.intern());
        System.out.println(str1==str2.intern());
```
在jdk1.6下输出的结果是：false false true
在jdk1.7及以上输出的结果是：true true true
这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。

#### 2.2 字符串常量池
也叫字符串驻留池
##### 2.2.1 常量池存的是字符串对象引用还是对象
字符串是字面量，网友的观点也是各不相同，两种说法都有道理，我个人觉得可以把字面量(本质是char数组)看作jvm特殊处理过的对象，可以存在常量池中，这样就两种都有，很多地方就可以更好地解释。
##### 2.2.2 字符串的垃圾回收
字符串常量池中持有了共享的字符串对象的引用，这就是说是不是会导致这些对象无法回收？
>在早期的版本中确实存在这样的问题，但是随着弱引用的引入，目前这个问题应该没有了。
（待补充）
##### 2.2.3 优缺点
* 优点：节省内存空间，
* 缺点：牺牲了CPU计算时间来换空间，不过内部实现为HashTable，所以计算成本较低。（也有大神做实验发现常量池中String多了之后常量池的速度会降下来。）
## 五. 问题
1. 公有和私有jre的区别，什么时候用到？
