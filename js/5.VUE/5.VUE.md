# 5.VUE
# 一 概述
## 1 简介
官网文档写得很详细,所以该笔记应该只是对官网的补充和实战的记录.理解它一切皆模块的思想.

### 1.1 优点
使用相对比较简单、有良好的文档和开箱即用的脚手架。

为什么要用VUE框架(待补充):

### 1.3 他人评价

## 2 历史
### vue 2.x
### vue 3.x
参考：
1. [TypeScript 不适合在 vue 业务开发中使用吗？](https://www.zhihu.com/question/310485097)

## 3 常识
### 3.1 index.html中的/(带验证)
指的src的上层目录

### 3.2 main.js 里的/* eslint-disable no-new */
在js里面，new 一个对象，需要赋值给某个值（变量），用Vue实例化的时候，不需要赋值给值（变量），所以要单独给配一条规则，给new Vue这行代码上面加这个注释，把这行代码规则的校验跳过，通过eslint-disable。eslint的常用技巧之一

### 3.3 VUE的响应式
VUE的响应式指的它的响应式原理，和响应式布局不是一个东西，和响应式编程也不是一个东西，但是都有响应式这种概念在里面。

## 4 文档
## 5 网址
1. 新手向：Vue 2.0 的建议学习顺序:https://zhuanlan.zhihu.com/p/23134551
2. Vue 2.0 发布了！by尤雨溪:https://zhuanlan.zhihu.com/p/22722479

# 三 基础
## 1 未整理
1. 计算属性的 getter 函数是没有副作用 (side effect) 的
2. 变异方法和非变异方法
3. 异步加载模块

    vue中异步加载模块只需要将`import Foo from './Foo.vue'`改成`const Foo = () => import('./Foo.vue')`

## 2 生命周期
![](../../picture/js/vue-1-lifecycle.png)

生命周期钩子：Vue 实例在其生命周期的不同阶段会调用不同的钩子，如`created`、`compiled`、`ready`、`destroy`。钩子的`this`指向调用它的 Vue 实例。比如
```javascript
var vm = new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  }
})
// -> "a is: 1"
```

### 2.1 生命周期钩子
`beforeCreate()`:组件实例开始创建的状态,进行组件属性的初始化,事件的初始化,此时DOM未生成.`$data`和`$el`为undefined.
`created()`:组件实例创建完成的状态,属性已初始化完成,进行DOM的生成.此时`$el`为undefined
`beforeMount()`:模板挂载之前的状态,DOM已初始化,进行模板的挂载(相当于进行html和data的关联).此时的DOM形如:`<p>{{message}}</p>`,这里使用Virtual DOM技术，先把坑占住,然后再把值渲染进去。
`mounted()`:完成挂载.此时的DOM形如:`<p>{{你好}}</p>`
`beforeUpdate()`:组件更新前
`updated()`:组件更新后
`beforeDestroy()`:
`destroyed()`:注意:作者说,应该避免使用`destroyed()`来操作子组件,而是用`v-if`

总结:
`beforecreate` : 举个栗子：可以在这加个loading事件 
`created` ：在这结束loading，还做一些初始化，实现函数自执行 ;数据请求;
`mounted` ： 配合路由钩子做一些事情?
`beforeDestroy`: 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容

api请求放在哪个周期:一般放到`created()`里面就可以了，这样可以及早发请求获取数据，如果有依赖dom必须存在的情况，就放到`mounted()`

## 3 组件
### 3.1 组件的属性
获取属性的语法：
1. `$el`:获取Vue实例关联的DOM元素
2. `$data`:获取Vue实例的data选项（对象）
3. `$options`:获取Vue实例的自定义属性（如vm.$options.address,获取Vue实例的自定义属性address）
4. `$refs`:获取页面中所有含有ref属性的DOM元素（如vm.$refs.hello，获取页面中含有属性ref = “hello”的DOM元素，如果有多个元素，那么只返回最后一个）

#### el
#### data
#### expressions
不允许使用流操作或其他复杂的逻辑。他们应该保持简单。

#### filters 过滤器
用于简单的数据格式，在应用程序的多个位置都需要它。

#### computed 计算属性
computed属性称为计算属性，可用于快速计算视图（View）中显示的属性。**这些计算将被缓存，并且只在需要时更新**。computed用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义。

为什么需要computed属性：模板表达式虽然非常的便利，但它们实际上是用于一些简单的运算，如果在模板中放入太多的逻辑会让模板过重而且难以维护。对于任何复杂逻辑，更加推荐使用计算属性。

`get`和`set`:计算属性的变量默认只有getter，可以在需要时自己提供一个setter。getter在初始化和依赖变化时会执行，setter在变量变化时执行。

不是响应式依赖时，计算属性不会更新：
```JavaScript
computed: {
    now: function() {
        return Date.now()
    }
}
```

和`methods`属性的对比：以把某个方法里的返回值绑定到view上和computed属里的变量绑定到view上来对比，
1. 性能问题：方法是不会基于它们的依赖进行缓存的，页面每次渲染methods里的该方法都会执行，而计算属性是基于它们的依赖进行缓存的，只要依赖不变，多次访问对应的view不会导致计算属性的重新计算。
2. 缓存：假设我们有一个性能开销比较大的的计算属性A，它需要遍历一个极大的数组和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果不希望有缓存，可以用方法来替代。

#### watch
watch主要用于监控vue实例的变化，它监控的变量当然必须在data里面声明才可以，它可以监控一个变量，也可以是一个对象，但是我们不能类似这样监控，比如：
```JavaScript
watch:{
    goodsList.price(newVal,oldVal){
        //监控商品列表中是商品价格
    }
}
```

一般用于监控路由、input输入框的值特殊处理等等，它比较适合的场景是一个数据影响多个数据
### 3.3 组件通信
#### 父子组件通信
传递子组件没有注册的属性：如果我们给child传props没有注册的属性，我们就要用`$attrs`来取，在`$attrs`里面只会有props没有注册的属性，$attrs是vue2.4才推出的，为了简化父组件和孙组件的传值。

### 3.4 编译作用域
父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。

### 插槽(slot)
标签是`<slot>默认值</slot>`

Vue的插槽slot分类，一共3种：
1. 匿名插槽(默认插槽)：没有命名,有且只有一个
2. 具名插槽：相对匿名插槽组件slot标签带name命名的
3. 作用域插槽：子组件内数据可以被父页面拿到(解决了数据只能从父页面传递给子组件)

前两种很好理解，就是子组件里定义一个slot占位符，父组件调用时，在slot对应的位置填充模板就好了。

插槽的适用场景和用法：
1. 假设需要封装一个列表组件给别人用，列表并不关心业务逻辑，父组件需要关心业务逻辑，这个时候会发现无论是用$emit、vuex还是localStorage，都没有合适的时机让你把数据传递给子组件，可以用作用域插槽。有几个关键点：
    1. 传参数给组件，组件可能还需要把数据传递回来。
    2. 最好不要把数据定义在子组件里。因为子组件的数据都是来自父组件的。作为组件内部应该保持纯净。

插槽里默认值的作用：
1. 提供后备内容：父组件没有往插槽中填充模板的时候，会使用插槽的默认值。

经验：
1. 如果组件起始标签和结束标签之间没有包含一个`<slot>`元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。如
    
    ```html
    <navigation-link>
        <!-- 如果navigation-link组件的定义里没有包含slot元素，则中间的内容会被忽略 -->
        <font-awesome-icon name="user"></font-awesome-icon>
        Your Profile
    </navigation-link>
    ```

## 4 模板
### 4.1 模板表达式
1. 插值
    1. 普通文本：写在双花括号（Mustache）之间，会被vue解释为普通文本,如`<span>Message: {{ msg }}</span>`。使用`v-once`指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新，如`<span v-once>这个将不会改变: {{ msg }}</span>`
    2. 原始html：为了输出真正的 HTML，需要使用`v-html`指令。注意动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。
    
        ```html
        <p>Using mustaches: {{ rawHtml }}</p>
        <p>Using v-html directive: <span v-html="rawHtml"></span></p>
        ```
        
    3. html Attribute：Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 `v-bind` 指令，形如`<div v-bind:id="dynamicId"></div>`
    4. 使用js表达式：限制是每个绑定都只能包含单个表达式。
        
        ```html
        {{ number + 1 }}

        {{ ok ? 'YES' : 'NO' }}

        {{ message.split('').reverse().join('') }}

        <div v-bind:id="'list-' + id"></div>
        
        <!-- 这是语句，不是表达式 -->
        {{ var a = 1 }}

        <!-- 流控制也不会生效，请使用三元表达式 -->
        {{ if (ok) { return message } }}
        ```

## 5 指令
指令带有前缀 `v-`,会在渲染的 DOM 上应用特殊的响应式行为。

指令的参数：一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，`v-bind` 指令可以用于响应式地更新 HTML attribute：`<a v-bind:href="url">...</a>`，可以缩写为`<a :href="url">...</a>`；`v-on` 指令，它用于监听 DOM 事件:`<a v-on:click="doSomething">...</a>`

### 5.1 内置指令
`v-show`

#### 属性指令
参考：https://cn.vuejs.org/v2/guide/forms.html

`v-model`：双向绑定的语法糖，会根据控件类型自动选取正确的方法来更新元素。本质上是监听用户的输入事件以更新数据。也可以通过`v-bind`和`v-on`指令来实现。

`v-bind`：形如`<span v-bind:attribute_name="attribute_value"></span >`,attribute_name是参数，attribute_value预期值支持一个单一的js表达式（`v-for`除外）
1. 它有一个唯一可以直接跟等号的特殊写法：`<child2 v-bind=”$attrs”></child2>`，具体参考`$attrs`
2. 绑定样式
    1. 绑定class：
        1. 绑定具体某个class
            1. `<span v-bind:class="{prop1:isTrue,prop2:isActive}" class="spancss1">{{text}}</span>`
        2. 用一个对象来设置class`<span v-bind:class="obj" class="spancss1">{{text}}</span>`，obj是`{prop1: true,prop2: false}`
        3. 绑定到数组上
            1. `<span v-bind:class="arr" class="spancss1">{{text}}</span>`,arr是`['prop1','prop2','prop3']`
            2. `<span v-bind:class="[prop1,prop2,prop3]" class="spancss1">{{text}}</span>`
            3. `<span v-bind:class="[prop1?'prop1':'',prop2,prop3?'prop3':'',prop4?'prop4':'prop5',prop6?'prop6':'prop5']" class="spancss1">{{text}}</span>`
    2. 绑定内联样式
        1. 绑定具体样式
            1. `<span v-bind:style="{background:color1,fontSize:fontSize+'px'}" class="spancss1">{{text}}</span>`
            2. `<span v-bind:style="[prop1,prop2]" class="spancss1">{{text}}</span>`,prop1是`{background:'green'}`,prop2是`{fontSize: '25px',fontWeight: 'bolder'}`


#### 结构指令
#### 组件指令（有？）

### 5.2 自定义指令
参考：https://cn.vuejs.org/v2/guide/custom-directive.html

什么时候需要用到自定义指令：代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。比如聚焦输入框。

#### 全局指令
#### 局部指令

## 6 实例属性和方法

# 四 高级 
## 2 Virtual DOM(待整理)
vue的虚拟dom：在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。

vue的Virtual DOM是基于[snabbdom](https://github.com/snabbdom/snabbdom)修改的.

vue中负责把vnode渲染到Real DOM主要工作的是位于src/core/vdom/patch.js文件中的代码完成的

## 3 webpack template
这也就是为什么我们提供 [webpack template](https://github.com/vuejs-templates/webpack)，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。

## 8 ref
`ref`：被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的`$refs`对象上。用在不同的地方代表的意义不一样：
1. 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素。
2. 如果用在子组件上，引用就指向组件实例。（尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件，此时就可以使用 ref 为子组件指定一个引用 ID）
    1. 可以通过`ref`访问子组件的数据和方法

`$refs`：是所有注册过的`ref`的一个集合，相对document.getElementById的方法，`$refs`会减少获取dom节点的消耗（why）。

当`ref`和`v-for`一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。

# 六 问题
## 1 已解决
### 1.1 Property or method "routerTo" is not defined on the instance but referenced during render...
属性或者方法没有定义到合适的地方,比如方法定义到methods外面,就会出现这个错误

## 2 未解决
### 2.1 .vue文件中部分句子在vscode中格式化为多行而不是一行
比如`var point = poi ? JSON.parse(poi) : { longitude: 104.087744, latitude: 30.408908 };`

`console.log(
    `me.i:${me.i}   me.len:${len}   me._fromPause:${
    me._fromPause
    } me._moving:${me._moving}`
);`

# 六 问题
## 1 已解决
### 1.1 No parser and no file path given ... 
似乎是 prettier版本太高了,从1.13.0缓存1.12.0就好了.

## 2 未解决
1. vue中：和@的区别
    1. https://www.ucloud.cn/yun/102847.html
2. Vuetify.js,尤雨溪也给过好评,官方文档写得似乎也不错
3. 架子:vue-cli + vue-router + UI库 + axios
4. underscore

5. vue中,在方法的方法中调用methods里面的 方法,有什么好的方式可以替代`self =this;`?

6. 朋友说的vux,用于移动端
8. vue中怎么写公共类和公共方法
9. for keep-alive
    1. 重用相关?
11. elementUI和ivue
12. Vue 在不同组件间强制使用单向数据流(?)
13. vue看渲染时间的插件



# 七 待整理
1. https://github.com/vuejs/vue-devtools
1. `this.$el`等是vue自带的吗
2. 当dom树挂载完对数据watch会有用
3. console.group
4. 关于vue @import路径问题:https://segmentfault.com/q/1010000010541142
5. vue-loader
6. 待整理:https://zhuanlan.zhihu.com/p/25829687
8. Vue2.0 Transition常见用法全解惑:https://segmentfault.com/q/1010000007738500
9. vue-loader 和 vueify
10. 很多其他社区的项目也都在为 2.0 做兼容——请移步到 awesome-vue 搜索关键字“2.0”:https://github.com/vuejs/awesome-vue
11. vue watch和computed的对比：执行异步操作或开销较大的操作