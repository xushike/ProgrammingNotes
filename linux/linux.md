# linux
[TOC]

# 一 概述
## 1 简介
### 1.1 linux版本:
分为内核版本和发型版本，后者相当于在前者的基础上加了一些个性化的东西，核心可以是一样的。

慕课网上说：服务器领域用得最多的是redhat，也可以选择一些收费的服务；ubuntu有好看的图形界面；centOS和redhat内核是一样的，但是完全免费，现在用的人越来越多了；fedora是redhat公司的个人版，其实相当于集成了最新功能的版本，而且界面也不错(不过稳定性就很难保证)；

### 1.2 linux和windows的不同：  
1. linux严格区分大小写  
2. linux中所有内容以文件形式保存，包括硬件(一切皆文件),所以linux中文件和目录能同名
3. linux不靠扩展名区分文件类型(但是有约定俗成的一些规则：比如二进制软件包.rpm、脚本文件.sh、配置文件.conf等，是linux为了照顾系统管理员，也可以不写)
4. linux是多用户系统,而win是单用户

## 3 常识
### 3.1 快捷键
1. 复制粘贴快捷键(windows中cmd不生效)：复制`ctrl+insert`，粘贴`shift+insert`
2. 终端清屏快捷键：`ctrl+L`，在终端有任务进行的时候不会生效
3. 同一应用有多个窗口时，可以通过`alt+~`切换，mac也一样(有细微差别)，win不行
4. 强制结束:`ctrl+c`(?)
5. 挂起:`ctrl+z`,相当于暂停?然后可以用fg和bg在前后台之间切换
6. 文件结束EOF:`ctrl+d`,不是发送信号,而是表示一个特殊的二进制值.比如在中断`wc`统计命令,然后输入任意字符之后`ctrl+d`就表示输入结束,也能用于退出终端,能退出其他程序?

### 3.2 Locale
linux系统的区域设置、本地化策略。其中几个设置的优先级是`LC_ALL > LC_* >LANG`，比如git（>2.19）就会去读取该参数，发现`LANG=zh_CN.UTF-8`，就会设置git为中文。

### 1.2 关于gcc
>网友的回答：gcc 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。 g++则是GCC的c++编译器。
现在你在编译代码时调用的gcc，已经不是当初那个c语言编译器了，更确切的说他是一个驱动程序，根据代码的后缀名来判断调用c编译器还是c++编译器 (g++)。比如你的代码后缀是*.c，他会调用c编译器还有linker去链接c的library。如果你的代码后缀是cpp, 他会调用g++编译器，当然library call也是c++版本的。
当然我说了这么多你可能感到有些混乱，没关系，你就把gcc当成c语言编译器，g++当成c++语言编译器用就是了。

### 1.3 学习linux的一些网站
1. 查询linux命令：[http://man.linuxde.net/](http://man.linuxde.net/)
2. debian官方：[https://www.debian.org/doc/manuals/debian-faq/](https://www.debian.org/doc/manuals/debian-faq/)
3. 鸟哥的linux私房菜(推荐)：[http://linux.vbird.org/linux_basic/0320bash.php#bash](http://linux.vbird.org/linux_basic/0320bash.php#bash)

### 1.4 网友推荐的linux书籍(按学习顺序排列)
1. 某个博客
    1. 《鸟哥的Linux私房菜：基础学习篇》
    2. 《Linux Shell 脚本攻略》
    3. 《UNIX环境高级编程》
    4. 《Linux系统编程》
    6. 《Linux内核设计与实现》
    5. 《Linux内核设计的艺术》
2. 知乎Han:
    1. 《The Linux Command Line》(豆瓣 9.3分)，中文名“快乐的linux命令行”,作为入门和手册,中文翻译github地址:[http://billie66.github.io/TLCL/book/](http://billie66.github.io/TLCL/book/)
    2. 《The Pragmatic Programmer》（豆瓣 8.9分），中文名“程序员修炼之道”

### 1.5 动态链接和静态链接
动态链接和静态链接的区别:前者不会把依赖编译进程序里，而后者会；所以前者编译的程序占用更小，在程序有相同依赖时更节约空间，而后者

动态链接库和静态链接库一般是编译集成一系列的接口（函数），在linux中前者一般后缀为`.so`，后者为`.a`

### 1.6 关于linux的`./`和`.`等
1. `.`一般表示当前目录，可以不写；如果放在文件名前则表示隐藏文件
2. `/`一般表示根目录，也是目录分隔符，`/etc/`表示根目录下的etc目录，`/etc`则会检测etc是目录还是文件，虽然一般etc都是目录
3. `./`：（待补充）
    1. 本人的理解是：`./`其实也是表示当前目录，和`.`一样，但是在执行程序时，linux的默认搜索目录里没有当前目录，如果只是加上`.`系统又会把`.`和程序连在一起当成一个命令，而`/`是目录分隔符，如果再加上`/`，系统就不会误会了，所以如果你在当前目录中执行程序就要加上路径`./`，用全路径代替也是可以的(全路径执行的话是`/xx/xx/xx`，可加`.`可不加)。（所以把`.`加到PATH中就不需要这命令了？）
    2. linux似乎默认是优先查找PATH环境变量下的路径，最后才搜索当前目录，这点和win相反
### 1.7 关于`.bashrc`文件
1. 在linux用户目录`$HOME`（/home/xxx）下`ls -al`可以看到4个隐藏文件：
    ```bash
    .profile（待补充）
    .bash_history       记录之前输入的命令
    .bash_logout        当你退出时执行的命令
    .bash_profile       当你登入shell时执行
    .bashrc             当你登入shell时执行
    ```
    1. 后两个的区别：`.bash_profile`只在会话开始时被读取一次，而`.bashrc`则每次打开新的终端时，都要被读取
    2. 这些文件是每一位用户对终端功能和属性设置，修改.bashrc可以改变环境变量PATH、别名alias和提示符
    3. 除了可以修改用户目录下的.bashrc文件外，还可以修改如`/etc/profile`文件、`/etc/bashrc`文件及目录`/etc /profile.d`下的文件。但是修改/etc路径下的配置文件会应用到整个系统，属于系统级的配置，而修改用户目录下的.bashrc则只是限制在用户应用上，属于用户级设置。建议修改用户目录下的`.bashrc`，即无需root权限，也不会影响其他用户。
    4. rc的意思是run commands，参见[https://en.wikipedia.org/wiki/Run_commands](https://en.wikipedia.org/wiki/Run_commands)

2. PATH环境变量修改
    1. **PATH变量决定了shell将到哪些目录中寻找命令或程序**,作为惯例，所有环境变量名都是大写
    2. 设置变量时直接用名称，但使用时需要加上`$`:
        ```bash
        #设置，比如在原基础上新增变量
        PATH=$PATH:/usr/local/arm/3.4.1/bin
        #使用，比如输出
        echo $PATH
        ```
    3. 使用`export`：上面那样设置的新PATH其实是局部变量，在新终端中不会生效（和win似乎是反着的），加上`export`才是全局，而且加上后只对当前和以后的终端生效
        
        ```bash 
        export PATH=$PATH:/usr/local/arm/3.4.1/bin
        ```
        
        资料说`export`可以设置、修改和查看环境变量，但是查看的时候，比如`export $PATH`会提示`export: not valid in this context: ...`（虽然后面会跟着环境变量的内容，但是前面的错误让人不爽），没搞懂，干脆用`echo $PATH`查看。
    4. 为了让修改永久添加到`$PATH`，只要将`export`的那行添加到`.bashrc`或`/etc/bashrc`文件中，然后用`source ~/.bashrc`使其立即生效。（一般会在`.bash_profile`文件中显式调用`.bashrc`，登陆linux启动bash时首先会去读取`~/.bash_profile`文件，这样`~/.bashrc`也就得到执行了，你的个性化设置也就生效了）
3. alias别名
    1. 一般在.bashrc或/etc/bashrc文件里有几句话
        ```bash
        alias rm='rm -i'
        alias cp='cp -i'
        alias mv='mv -i'
        ```
        可以在该配置文件中添加自己风格的别名，如“alias ll='ls -l'”，只需要在终端中输入“ll”就实现了“ls -l”的功能
4. 提示符(意义不大)

### 1.8 关于文件扩展名
1. 关于判断文件类型：与win不同的是，linux不是根据文件的扩展名来判断文件是否能执行，而是查看文件内的头部信息来判断，另外，gcc是根据文件扩展名来判断
2. 关于文件命名：
    1. 关于扩展名
        linux没有文件扩展名的概念,即linux不通过扩展名判断文件类型.但是还是推荐加上扩展名，这样使用时更方便,而且有些应用程序可能会用到文件扩展名
    2. 关于标点符号
        不要使用空格,支持`.`,`-`和`_`
        
### 1.9 关于distribution
distribution一般是指发行版的意思，Linux真正意义上说只是一个内核，我们通常使用的都是基于Linux内核的发行版了。如常见的Linux发行版有：Ubuntu、Fedora、Suse、ArchLinux等

### 1.10 关于标准输入输出
执行shell命令时会自动打开三个标准文件:
- `stdin`标准输入文件,程序从中得到输入,默认连接到键盘
- `stdout`标准输出文件,运行结果输出到此,默认连接到屏幕
- `stderr`标准错误输出文件,错误信息(状态信息)输出到此,默认连接到屏幕

进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。
>弄懂linux的标准输入输出,才能理解重定向和管道的区别,如果还是不能理解,看这个例子:
cat myFile.txt | pbcopy
pbcopy < myFile.txt

1. 文件描述符
     一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。
1. 标准输入/输出
    标准输入输出有几个问题:
    - 每次的输入只能用一次
    - 修改不方便
    - 只能看不能动

    于是linux引入了两种机制:输入/输出重定向和管道
2. 重定向(即I/O重定向
    I/O重定向允许我们更改输出位置和输入来源
    1. 标准输入重定向:把标准输入重定向到指定的文件中,即可以不来自键盘
        1. 直接跟文件名,如`wc hello.txt`
        2. 输入重定向:`[命令] < [文件名]`
        3. here文档,允许命令在获取命令行输入数据时像是在读取文档一样,后面跟的字符代表开始和结束的分割符,如:
        ```bash
        wc << !?
        这段话开始了
        这段话结束了
        !?
        ```
    2. 标准输出重定向(常用):把标准输出重定向到指定文件中
        1. 输出重定向,如果后面的文件已存在,会被覆盖:`[命令] > [文件名]`,如`ls > hello.out`
            1. 该命令不会重定向标准错误输出,比如`ls /bin/usr > output.file`,因为`/bin/usr`目录不存在,屏幕上会打印出标准错误输出,同时因为使用的是`>`重定向符,重定向操作开始重写文件，然后由于错误而停止，导致文件内容删除,如果不存在该文件,则会创建一个新的空文件
            2. 利用重定向的重写技巧,我们可以这样删除一个文件内容或者创建一个新的空文件:`> xxx.file`
        2. 输出追加重定向,会在文件后面追加:`[命令] >> [文件名]`
    3. 标准错误输出重定向:可在屏幕上看到正常输出结果,同时把错误重定向到文件中.因为重定向标准错误缺乏专用的重定向操作符,为了重定向标准错误，我们必须参考其文件描述符
        1. 重定向:`2>`,如`ls 2> err.file`
        2. 追加重定向:`2>>`
    4. 将输出和错误一起重定向到文件中
        1. 老版本的写法,旧版本shell中也有效,如`ls /bin/usr > output.file 2>&1`,注意顺序很重要,标准错误的重定向必须总是出现在标准输出重定向之后，不然不起作用
        2. 新版本写法,更精简合理,如`ls &> output.file`
    5. 重定向到黑洞`/dev/null`
        `/dev/null`是一个特殊文件,叫位存储桶,位存储桶是个古老的Unix概念.
3. 管道
    对于把一个命令的输出作为另一个命令的输入,管道比重定向更加好用,可以通过`|`一直连下去,最后显示最后一个的输出,如`ls ~ | wc -w`
    1. 管道仅能处理标准输出的数据,对标准错误输出没有能力处理
    2. 管道后所接的命令必须能够接受标准输入才行,否则无效,比如`ls`,`mv`,`cp`这些管道就没用,但是这些命令可以用命令替换
4. 其他:命令替换
    命令替换和重定向有点类似,区别在于命令替换是把一个命令的输出作为另一个命令的参数,有两种用法,具体参考字符展开中的命令替换
5. 其他:连续命令
    和管道不同在于,连续命令(用`;`分隔)中各个命令不存在相关性,只是顺序执行

### 1.11 关于命令的选项
大多数命令使用短选项——一个中划线加一个字符,但是许多命令也支持长选项——两个中划线加一个单词,而且许多命令允许把多个多个短选项合在一起使用,比如`ls -lt`
### 1.12 关于命令行的参数
1. 参数可重复:当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复，如`mkdir directory...`,可以使用`mkdir dir1 dir2 dir3`等同时创建多个目录
### 1.13 关于linux的普通文件(regular file)
### 1.14 关于linux的元键
现在键盘上,一般alt代表元键,如果是在终端中,则`esc`也可当做`alt`来用

### 1.15 终端，Shell，“tty”和控制台（console）有什么区别
参考知乎网友的回答:[终端，Shell，“tty”和控制台（console）有什么区别？](https://www.zhihu.com/question/21711307)

### 3.16 login shell 和 non-login shell，.bash_profile和.bashrc
为什么会有login shell和non-login shell：会读取不同的配置文件。

login shell：取得shell时需要完整登录流程（比如需要输入账号密码）就称为login shell，比如图形界面登录，ssh登录，命令行登录。一般会依次去读取几个配置文件，顺序如下：
1. `/etc/profile`
2. `~/.bash_profile` 或 `~/.bash_login` 或 `~/.profile`:这三个从左到右只要存在一个，后面的就不会被读取。

non-login shell：取得shell的方法不需要重复登录流程的就是non-login shell。仅会读取`~/.bashrc`

注意：linux的shell读取的配置和mac不同。

### 3.17 sh 和 bash
sh是一种POSIX标准，它有很多种实现，包括ksh88, dash,bash等。

因为sh是一种规范，并不是实现，所以`/bin/sh`实际上是一个硬链接，链接到某种实现上。大多数情况下，`/bin/sh`会链接到`/bin/bash`。所以你执行`sh xx`等价于执行`bash xx`。但是在一些系统中，/bin/sh并没有指向/bin/bash，比如在一些现代的Debian和Ubuntu系统中，sh指向的是dash。

## 4 文档资料等
1. 网友写的Linux工具快速教程，还不错：https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html

# 二 安装配置

# 三 基础（命令）

## 1 查看相关命令
### 1.1 查看文件信息
`ls`:最基础并且使用的最广泛的命令行中工具之一。它是一个POSIX兼容工具，在GNU基本工具集以及BSD各种变体上都可以使用
1. 列出当前目录所有文件:`ls`或`echo *`,列出其他目录`ls [路径]`,列出多个目录的文件`ls [路径1] [路径2]`
2. 只列出当前目录下的目录:`ls /`或`echo */`
3. 参数`--full-time`：一般情况下似乎看不到年份信息，此命令可以显示全部日期信息
4. 参数`-a`:列出所有文件,包括隐藏文件和以.开头的文件（linux中`.`代表当前目录,`..`代表父目录）
1. 参数`-l`:以长格式(每个一行?)查看文件详细信息
2. 参数`-t`按文件修改时间的先后来排序
3. 参数`-h`(`--human-readable`),以人可读的格式来显示文件大小
4. 参数`-i`(`--inode`):打印文件的索引节点(inode)信息
5. 参数`-S`,命令输出结果按照文件大小来排序,优先级比`-t`高
6. 参数`-r`(`--reverse`),以相反顺序来显示结果
7.  参数`-A`,列出除`.`和`..`外所有文件,包括隐藏文件

`lsof`(list open files,列出打开的文件)：列出某个进程打开的所有文件信息。因为unix中一切皆文件，所以它可以查看的文件包括：普通的文件，目录，NFS文件，块文件，字符文件，共享库，常规管道，符号链接，Socket流，网络Socket，UNIX域Socket等等。

参考：
1. https://www.ibm.com/developerworks/cn/aix/library/au-lsof.html#listing2

参数：

简单使用（待补充）：
1. 恢复被删除的文件
2. 查看连接


### 1.2 查看文件类型:`file [filename]`
会打印文件类型和内容的简单描述,比如文本文件是`ASCII text`，类型有：
|属性|	文件类型|
|-|:-|
|`-`|	一个普通文件|
|`d`|	一个目录|
|`l`|	一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。|
|`c`|	一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器|
|`b`|	一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。|

### 1.3 查看文本文件内容 less
可查看所有类型的文本文件(即ASCII类型的文件,包括txt、配置文件、脚本等),如果查看非文本文件,则是乱码.特点是自带分页,可以接受标准输入.less是早期unix程序more的改进版,意味着less is more。因为有分页,所以可以用来方便的查看产生标准输出的命令运行结果,比如`ls | less`

常用操作:上一页`b`,下一页`space`,页首`g`,页尾`G`,向上/下查找匹配`?xxx`和`/xxx`,查看上/下一个匹配`n`和`N`，查看帮助`h`,退出less`q`，多个文件时的下一个文件`:n`,上一个文件`:p`，使用配置的编辑器编辑文件`v`，仅显示匹配模式的行，而不是整个文件`&pattern`

参数：
1. `-m`：像more那样显示百分比
2. `-S`(`--chop-long-lines`)：丢弃一行不能显示完的，按右键显示？

### 1.4 查看命令类型:`type`会显示命令的类型:
1. file为外部指令
2. alias为别名。如果本来的命令和别名重名，优先使用别名。
3. builtin为系统（shell？）內建指令

### 1.5 查看可执行程序位置`which`
有时系统中不止安装了程序的一个版本,虽然在桌面系统中不常见,但在大型系统中却很平常.该命令对只对可执行程序有效，不包括内建命令和命令别名,有点奇特,比如对`cd`就无效

### 1.6 查看內建命令的帮助文档`help`
该命令是bash的內建的帮助工具,用法是`help [命令名]`,实例如
```bash
[me@linuxbox ~]$ help cd
cd: cd [-L|-P] [dir]
Change ...
```
注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符 表示互斥选项。帮助文档很简洁准确，但它决不是教程。

许多可执行程序支持一个`--help`选项，用于显示命令所支持的语法和选项说明.不过有些不支持,但是任何情况该命令都值得一试


### 1.7 查看程序手册`man`
许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页(man page)。一个特殊的叫做man的分页程序(大多数man使用的是less)，可用来浏览他们。用法`man [program]`手册文档的格式有点不同:一般包含一个标题、命令语法的纲要、命令用途的说明、 以及每个命令选项的列表和说明,也包括系统管理员命令、程序接口、文件格式等。但手册文档通常并不包含实例，它打算作为参考手册，而不是教程。
1. 参数`[num]`:跳到手册的指定章节,如果有的话.因为man的手册是分章节的

### 1.8 查看命令历史：`history`
 1. 反向递增搜索:`ctrl+r`,搜索之后回车是执行,`ctrl+j`是复制到shell
 2. 执行特定行的命令`![num]`

### 1.9 查看日期:`date`
 1. 直接使用显示类似:`2017年12月 9日 星期六 20时19分25秒 CST`
 2. 还可以用date的格式化输出功能,比如`date +%Y/%m/%d`,会显示`2017/12/09`.从这里也可以看出linux的命令选项前不仅可以用`-`,在特殊情况下还可以用`+`

### 1.10 查看日历:`cal`
 1. 查看某年的日历:如,`cal 2017`,查看某年某月的日历:`cal [mon] [year]`

### 1.11 查看程序的资源信息:top(待补充)
对于`top`,它的命令似乎是后面手动输入的
1. 字段说明

    | 字段  | 说明                                          |
    | ----- | --------------------------------------------- |
    | `vir` | 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES |
2. 命令说明

### 1.12 查看网络状态(待补充)

### 1.13 查看系数中安装的所有字体
`fc-list`

## 2 文件操作相关
关于linux的文件系统树:linux以分层目录来组织所有文件，第一级目录称为根目录(唯一)，对于连接到计算机的磁盘或存储设备，则是挂载到目录树的某个节点上，区别于win中的每个存储设备都有独自的文件系统

### 2.1 文件系统跳转
1. 查看当前目录：`pwd`(`print working directory`),注意该命令会在结尾加上一个换行符
2. 更改工作目录,其中`.`是当前目录,`..`是父级目录,而且几乎所有情况下都可以省略`./`,因为它是隐含的：
    1. 后面可接相对路径和绝对路径,直接`cd`则是跳转到home目录
    2. 跳到上一次的目录:`cd -`
    3. 跳到某个用户的目录:`cd ~[uerName]`
    4. 注意,跳转时路径中间必须都是目录,不能包含文件,比如`cd ./xxx.txt`就不行
### 2.2 文件创建
#### 创建文件:`touch`

#### 创建目录:`mkdir`
可跟多个参数,如`mkdir dir1 dir2 dir3`

参数说明
- `-p`(`--parents`):若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录

来自: http://man.linuxde.net/mkdir
2. 创建文件:
### 2.3 文件移动、复制、重命名、删除、链接
#### 复制文件和目录 cp
1. 复制单个文件或目录,如`cp item1 item2`
    1. 复制目录时,需要加上`-r`,而且对于`cp dir1 dir2`,如果dir2存在,则是把dir1复制到dir2下,如果不存在,则是把dir1复制为dir2
2. 复制多个文件或目录到一个目录:`cp item... dir`,此时作为"一"的dir必须存在
3. 参数`-a`(` --archive`):同时会复制他们的属性,包括所有权和权限
4. 参数`-i`(`--interactive`):重写已存在的文件前会提示用户确认,因为cp命令默认是重写不提示
5. 参数`-r`(`--recursive`):递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）.注意linux中很多命令的`-r`都代表递归
6. 参数`-u`(`--update`):当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。
7. 参数`-v`(`--verbose`):显示详细的命令操作信息,即会告诉用户干了什么.注意很多linux命令的`-v`都是这个意思

#### 跨服务器的安全复制 scp(secure copy)
用法和`cp`很像,而且`scp`可以跨服务器,传输是安全的（加密的）,还非常不占资源,当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。

基本用法:`scp item user_name@remote_ip:dir`

参数：
1. `-q`：不显示进度条
2. `-r`:递归复制整个目录

#### 移动或重命名文件 mv
    使用方法和`cp`很像,但是不用加`-r`,操作成功后原来的文件名不再存在
    1. 移动或重命名单个文件或目录:`mv item1 item2`
        1. 对于`mv file1 file2`,如果file2存在,则被重写为file1;如果file2不存在,则创建file2.每种情况下file1都不会存在
        2. 对于`mv dir1 dir2`,如果dir2存在,移动dir1及它的内容到dir2中;如果dir2不存在,创建dir2,将dir1的内容移到dir2.
    2. 移动多个文件或目录到目录:`mv item... dir`,dir必须存在
    2. 参数`-i`(`--interactive`):在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。
    3. 参数`-u`(`--update`):用法同cp
4. 删除文件或目录`rm`(`remove`)
    该命令必须慎重使用,类unix(比如linux)的操作系统中没有复原命令,它假定操作者是聪明的,知道自己在干什么.最佳实践是:每次删除前使用ls列出要删除的文件,确认后再将ls修改成rm
    1. 基本用法`rm item...`
    2. 参数`-i`(`--interactive`):在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，`rm`会默默地删除文件
    3. 参数`-r`(`--recursive`):递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。
    4. 参数`-f`(`--force`):忽视不存在的文件，不显示提示信息。这选项覆盖了`--interactive`选项。
5. 创建链接`ln`
    1. 硬链接`ln file link`,和文件本身没什么区别,硬链接有两个局限性:
        - 不能关联目录
        - 不能关联不在同一个分区的磁盘文件
    2. 符号链接`ln -s file link`,为了解决硬链接的局限而生,符号链接包含关联的文件或目录的文本指针,类似于windows的快捷方式,而且出现时间比win快捷方式早很多.如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色
        1. 比如指向`../fun`的某个符号链接`fun-sym`,符号链接`fun-sym`文件的长度是6，这是字符串”../fun”所包含的字符数， 而不是符号链接所指向的文件长度
        2. 大多数文件操作是针对链接的对象,而不是链接本身,但是`rm`是个特例,删除链接时就是删除链接本身
        3. gonme中,拖动文件同时按下`ctrl+shift`会创建一个链接(什么链接?)而不是移动或复制文件

### 2.4 压缩相关
### tar
1. 首先明确linux中打包和压缩是不同的，打包是把多个文件变成一个总的文件；因为linux中很多压缩程序只能对一个文件压缩，所以一般是先打包再压缩,参考:["为什么linux的包都是.tar.gz？要解压两次"](https://www.zhihu.com/question/37019479?sort=created)
2. tar

    不加`-z`或`-a`的话就只是打包,而没有压缩.

    >关于tar这个命令名字的来历：Initially, tar archives were used to store files conveniently on magnetic tape. The name "Tar" comes from this use（最初，tar档案被用来方便地在磁带上存储文件。 “焦油”这个名字来自这个用途。）
    1. `-z`或`--gzip`或`--ungzip`：通过gzip指令处理.gz格式的文件；`-j`:针对bzip2即.bz2格式的文件。
    2. `-v`(`--verbose`)：显示操作过程
    3. `-f [压缩或备份的文件]`或`--file=[压缩或备份的文件]`：指定备份文件
    4. `-c`或`--create`：建立新的备份文件
    5. `-x`或`--extract`或`--get`：从备份文件中还原文件
    6. `-t`或`--list`：列出备份文件的内容
    6. `-C [目录]`：在指定目录解压缩。
    7. `-a`(`--auto-compress`):使用归档后缀名来决定压缩程序,也就是用了该参数就不用`-z`参数了.
    ```bash
    # 最常用的例子如下
    # 压缩：
    tar -zcv -f filename.tar.gz 要被压缩的文件或目录名称 
    # 查询：
    tar -ztv -f filename.tar.gz 
    # 解压缩：
    tar -zxv -f filename.tar.gz -C 欲解压缩的目录
    ```
3. 打包
### zip
1. 解压`unzip`
2. 压缩`zip`

## 3 过滤器
管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。
1. 排序`sort`
    `sort`对文件排序,也可获取标准输入,然后标准输出.将文件/文本的每一行作为一个单位,从首字符向后，依次按ASCII码值进行比较,最后升序输出.
2. 报道或忽略重复行`uniq`
    用于报告或忽略文件中的重复行，常与sort命令结合使用,例如`ls /bin /usr/bin | sort | uniq | less`
3. 打印行数、字数和字节数`wc`
    display the number of lines, words, and bytes contained in files.接受标准输
    1. 直接使用`wc`,接受标准输入
    2. 一般用法`wc [file]`
    3. 也可指定显示,比如`wc -l [file]`则只显示行数
4. 打印匹配行`grep`(`Globally search a Regular Expression and Print`)
    很强大的文本搜索工具,用来找到文件中的匹配文本,类似于win中的`FINDSTR`,基本用法`grep pattern [file...]`,支持正则表达式.比如想找目录中文件名包含`xiaoke`的文件,可以这样`ls | grep xiaoke`
    1. 参数`-i`:忽略大小写
    2. 参数`-v`:只显示不匹配的行。排除多个可以使用`grep -v 'args1\|args2...'`
5. 打印文件的开头/结尾部分`head`和`tail`
    `head`默认打印开头10行,`tail`则是结尾10行,`tail`有个选项`-f`允许实时地浏览文件,观察日志文件时很有用.
    1. 参数`-n`:指定打印的行数
6. 读取数据,同时输出到屏幕和文件`tee`
    比如`ls /usr/bin | tee xxx.txt`,会同时输出到屏幕和文件
## 4 (字符)展开
每当你输入一个命令并按下enter键，bash会在执行命令前对输入的字符处理,这背后的的过程叫做（字符）展开。通过展开，你输入的字符，在shell对它起作用之前，会展开成为别的字符,用`echo`就可以看到(字符)展开
1. 路径名展开
    文件名以圆点字符开头的文件是隐藏文件,路径名展开尊重隐藏文件,比如`echo *`,会显示当前目录所有文件和目录但不包括隐藏文件
2. 波浪线展开
    展开成指定用户的家目录名,默认是当前用户家目录,如`echo ~`
3. 算术表达式展开
    允许把shell提示当计算器来使用,因为用的bash内置运算的支持,所以只支持整数,不支持浮点运算,基本用法是`$((expression))`,其中表达式有无空格无所谓,如`echo $((2+3))`,输出5.感觉较鸡肋
    1. 算数操作符`/`(即除),因为展开只是支持整数除法，所以结果是整数,从这儿可以看出不如`bc`
4. 花括号展开
    从一个包含花括号的模式中创建多个文本字符串,常见的应用场景是:创建一系列的文件或目录列表.比如摄影师给大量的相片命名.花括号的展开模式可能包含一个开头部分叫做报头,一个结尾部分叫做附言,而花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一系列的整数，或者单个的字符串,不能嵌入空白字符.
    1. 简单例子:
    ```bash
    #注意多个连续的这种简短写法是中间两个点`..`
    [me@linuxbox ~]$ echo Number_{1..5}
    Number_1  Number_2  Number_3  Number_4  Number_5 
    [me@linuxbox ~]$ echo {Z..A}
    Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
    ```
    2. 可以嵌套:
    ```bash
    [me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b
    aA1b aA2b aB3b aB4b
    ```
5. 参数展开
    该特性在shell脚本中更有用,常用于:系统存储小块数据，并给每块数据命名.
    1. 查看变量名,比如`echo $USER`,如果输错变量名,展开仍会进行,不过是显示空字符串
    2. 查看有效变量列表`printenv | less`
6. 命令替换
    命令替换允许我们把一个命令的输出作为一个展开模式来使用,有两种写法:新版写法是`$(program)`,旧版是`program`(用倒引号来代替美元符号和括号)
    1. 用法一如下:

        ```bash
        [me@linuxbox ~]$ echo $(ls)
        Desktop Documents ls-output.txt Music Pictures Public Templates Videos
        [me@linuxbox ~]$ file $(ls /usr/bin/* | grep zip)
        ```
    2. 用法二如下:
    
        ```
        #``中的内容会被当做命令执行,然后结果作为cd的参数
        #所以最后的结果是仍停留在当前目录
        cd `pwd`
        ```
## 5 引用
用于控制展开.有几种类型:双引号
1. 双引号
    除了`$`、`\`和反引号(Backslash),其他字符在shell的双引号中都变成了普通字符.使用双引号，我们可以处理包含空格的文件名。(文件名含空格的受害者,笑:))
    在双引号中，参数展开、算术表达式展开和命令替换仍然有效：
    ```bash
    [me@linuxbox ~]$ echo "$USER $((2+2)) $(cal)"
    me 4    February 2008
    Su Mo Tu We Th Fr Sa
    ```
    在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用.在mac上的例子如下
    ```bash
    xushikedeMacBook-Pro-2:zztemp xushike$ echo $(cal)
    十二月 2017 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    xushikedeMacBook-Pro-2:zztemp xushike$ echo "$(cal)"
        十二月 2017
    日 一 二 三 四 五 六
                    1  2
    3  4  5  6  7  8  9
    10 11 12 13 14 15 16
    17 18 19 20 21 22 23
    24 25 26 27 28 29 30
    31
    ```
2. 单引号
    如果要禁用所有展开,则用单引号,如
    ```bash
    [me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
    text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
    ```
3. 转义字符`\`
    有两种用法:阻止展开和反斜杠转义字符序列(Backslash Escape Sequences)
    1. 阻止展开:
        有时只想引用某个字符,在双引号中可以使用转义字符`\`来消除字符的特殊含义,而单引号则不需要
    2. 反斜杠转义字符序列
        用来表示ASCII中的控制字符,背后的思想来源于C编程语言，许多其它语言也采用了这种表示方法，包括shell。
## 6 用户和权限
1. 查看关于自己身份的信息:`id`,用户账户定义在`/etc/passwd`,用户组定义在`/etc/group`,这几个文件随着`/etc/shadow`而改变
2. 权限属性

    文件类型后的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。如图,
    ![](../picture/linux/0-1-permission.png)

    |属性|	文件|	目录|
    |-|:-|:-|
    |`r`|	允许打开并读取文件内容。	|允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。|
    |`w`|	允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。 |允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性(x)|
    |`x`|	允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。	|允许进入目录，例如：cd directory 。|
    1. 特殊权限(待理解)

        从技术层面上来讲，用四位数字来表示权限更确切,因为除了读取、写入和执行权限之外，还有其它较少用到的权限设置。
        1. `setuid`位（八进制4000）

            应用到一个可执行文件时，它把有效用户ID从真正的用户（实际运行程序的用户）设置成程序所有者的ID.通常用于超级用户拥有的程序。当一个普通用户运行一个由根用户(root) 所有并且设置了`setuid`位的程序，这个程序运行时具有超级用户的特权，这样程序就可以访问普通用户禁止访问的文件和目录。很明显，这会引起安全方面的问题，所以所有可以设置`setuid`位的程序个数，必须控制在绝对小的范围内。
            一般用法`chmod u+s program`,权限修改后类似`-rwsr-xr-x`
        2. `setgid`位（八进制2000）

            类似于`setuid`位，把有效用户组ID从真正的用户组ID更改为文件所有者的组 ID。当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时，那么设置 setgid 位很有用处。
            一般用法`chmod g+s dir`,权限修改后类似`drwxrwsr-xx`
        3. `sticky`位（八进制1000）

            该位继承于Unix，在Unix中它可能把一个可执行文件标志为“不可交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。这个经常用来控制访问共享目录，比方说/tmp。
            一般用法`chmod +t dir`,权限修改后类似`drwxrwxrwt`

3. 更改文件模式:`chmod`(`change the mode (permissions)`)
    只有文件的所有者或者超级用户才 能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或 符号表示法。
    1. 八进制法
        因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。下表展示了要表达的意思：

        |Octal|	Binary|	File Mode|
        |-|-|-|
        |`0`|	000|	---|
        |`1`|	001|	--x|
        |`2`|	010|	-w-|
        |`3`|	011|	-wx|
        |`4`|	100|	r--|
        |`5`|	101|	r-x|
        |`6`|	110|	rw-|
        |`7`|	111|	rwx|
        一般用法如`chmod 600 foo.txt`,常用的是7、6、5、4、0

    2. 符号表示法
        符号表示法分为三部分：更改会影响谁， 要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定要影响的对象，如下

        |字符|对象|
        |-|-|
        |`u`|	"user"的简写，意思是文件或目录的所有者。|
        |`g`|	用户组。|
        |`o`|	"others"的简写，意思是其他所有的人。|
        |`a`|	"all"的简写，是"u", "g"和“o”三者的联合。|
        如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。

        符号表示法实例:

        |符号|意义|
        |-|-|
        |`u+x`|	为文件所有者添加可执行权限。|
        |`u-x`|	删除文件所有者的可执行权限。|
        |`+x`|	为文件所有者，用户组，和其他所有人添加可执行权限。等价于`a+x`。|
        |`o-rw`|	除了文件所有者和用户组，删除其他人的读权限和写权限。|
        |`go=rw`|	给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。|
        |`u+x,go=rw`|	给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。|

4. 设置默认权限:`umask`

    大多数情况下不需要设置,在某些高安全权限下需要控制掩码值.
    1. 不带参数使用是查看当前的掩码值,掩码值(默认八进制)的后三位对应权限rwx的八进制,但是意思相反:掩码这儿转换成二进制后,如果某位为1,则表示关闭该该位对应的权限,如
    ```bash
    [me@linuxbox ~]$ umask
    0002
    ```
    2. 该命令设置的掩码值只能在当前shell会话中生效
4. 切换用户

    有三种方式,发行版一般都支持后两种方式,但可能会偏袒其中之一.
    1. Log out and log back in as the alternate user.(注销系统并以其他用户身份重新登录系统)

        easy但是并不方便
    2. Use the su command.(使用`su`命令)

        以其他用户身份和组 ID 运行一个 shell
        1. 一般用法`su [user_name]`
        2. 带参数`-l`的用法`su -l [user_name]`,启动一个需要登录的shell(即login shell)。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。
            1. 如果不指定用户`su -l`,则是默认超级用户
            2. 而且该参数可以缩写为`-`
        3. 带参数`-c`的用法`su -c 'command'`,执行单个命令，而不是启动一个新的可交互的shel.注意command的两边的反引号很重要,这样命令就不会在我们的shell中展开而是在新shell中展开.
            ```bash
            [me@linuxbox ~]$ su -c 'ls -l /root/*'
            Password:
            -rw------- 1 root root    754 2007-08-11 03:19 /root/anaconda-ks.cfg
            ```
    3. Use the sudo command.(使用`sudo`命令)

        类似su,但是几个很重要且不同的功能:
        1. 管理员可以配置sudo命令,从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性).
        2. 另一个重要差异是sudo使用用户自己的密码来认证.
        3. sudo 不会重新启动一个 shell，也不会加载另一个 用户的 shell 运行环境。这意味者命令不必用单引号引起来。
        4. 通过配置,上面的这些行为也可以被推翻.
        5. 一般`sudo`命令会相信你几分钟,意味着几分钟内不用再输入密码.
        5. 参数`-l`,显示`sudo`命令可以授予哪些权,如
            
            ```bash
            User xushike may run the following commands on xushikedeMacBook-Pro-2:
                (ALL) ALL
            ```
5. 其他

    1. `chown`更改文件所有者和用户组
    2. `chgrp`更改用户组所有权
6. 关于权限的练习(待补充)

    [http://billie66.github.io/TLCL/book/chap10.html](http://billie66.github.io/TLCL/book/chap10.html)
7. 修改用户密码:`passwd`

    `passwd`命令将会试着强迫你使用“强”密码。这意味着它会拒绝接受太短的密码、与先前相似的密码、 字典中的单词作为密码或者是太容易猜到的密码
8. 维护用户和用户组
    `adduser`,`useradd`,`groupadd`

## 7 进程
1. 关于进程如何工作
    
    当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户界面。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。
    内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。
2. 查看进程快照`ps`

    该命令古老且重要,各种linux都默认安装了,不过参数可能不一样.`ps`命令支持三种使用的语法格式:
    - UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符
    - BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符
    - GNU 风格的长选项，选项前有两个“-”连字符
    1. 直接使用`ps`,只列出与当前终端会话相关的进程,其中TTY是“Teletype” 的简写，是指进程的控制终端.TIME字段表示进程占用的CPU处理时间。

        ```bash
        [me@linuxbox ~]$ ps
        PID TTY           TIME CMD
        5198 pts/1    00:00:00 bash
        10129 pts/1   00:00:00 ps
        ```
    2. 带参数`x`的用法`ps x`(注意不是`-x`),展示所有进程，不管它们由什么终端（如果有的话）控制。TTY栏的问号表示没有控制终端。该用法可以看到我们所拥有的每个进程的信息。

        1. STAT是“state” 的简写，它揭示了进程当前状态

            |状态|	含义|
            |-|:-|
            |`R`|	运行中。这意味着，进程正在运行或准备运行。|
            |`S`|	正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。|
            |`D`|	不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。|
            |`T`|	已停止. 已经指示进程停止运行。稍后介绍更多。|
            |`Z`|	一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）|
            |`<`|	一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。|
            |`N`|	低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。|
    3. 常用组合参数`aux`的用法`ps aux`
        - 参数`a`代表all
        - 参数`x`会显示没有控制终端的进程
        - 参数`u`根据用户过滤
    4. 根据进程名过滤`-C`
    5. 查看格式化的信息列表`-f`
    6. 根据PID查看线程的进程`-L [PID]`
    7. 参数`-e`显示所有进程信息
    8. 实时监控进程状态`ps`和`watch`结合使用
        `top`虽然也可以,比`top`好的地方是可以自定义显示的字段.

## 8 curl
文件下载（包括发送HTTP请求），断点续传，指定cookie，设置用户代理字符串，认证等
参数：
1. `-X`:指定request method：POST、GET、DELETE等，默认是GET
2. `-H 'xxx: xxx'`:自定义头信息传递给服务器
3. `-d 'xxx'`：HTTP POST方式传送的body数据
4. `-F 'xxx'`:模拟http表单提交数据
5. `-I`(`--head`)：只显示头信息

例子如：`curl -X GET -H "Sign: 12345672147b8d706e7022ef862b0dec25fce20415263e48ed37b2a17385e41a" -H "Timestamp: 1542102231" -H "Cache-Control: no-cache" -H "Postman-Token: 12345678-e5a2-4c28-26fe-0bf63eeea10f" "https://xxx.com/vin?vin=WAUAMD4L2CD005389"`

判断端口连通性：`curl ip:port`
1. Connection reset by peer

问题：
1. 有时候已下载的百分比会变小是什么情况，比如从25%突然跳到17%？

## 9 wget
用来从指定的URL下载文件，支持断点续传。

参数：
1. `-O`:以不同的文件名保存。wget默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确。比如`wget http://www.linuxde.net/download?id=1`会下载一个文件并以名称"download.aspx?id=1080"保存。
2. `-c`：继续执行上次终端的任务，断点续传。
3. `--spider`：测试下载链接是否有效。

## 10 其他
1. 别名`alias`
    1. 基本用法是`alias [name]=[string]`,比如想把`cd /usr; ls; cd -`三个命令合在一起取个别名,可以使用`alias foo='cd /usr; ls; cd -'`
    2. 删除别名`unalias [name]`
    3. 不带参数使用`alias`,则是显示系统中所有的别名命令(mac无效?)
2. 读取文件到标准输出:`cat`
    `cat`用于读取一个或多个文件,然后复制他们到标准输出,没有分页,经常用来显示简短的文本文件
    1. 不带参数使用,则是读取标准输入到标准输出,此时可以`ctrl+d`给它一个EOF结束.
        1. 也可以`cat > xxx.txt`实现世界上最低能的文字处理器
3. 计算器`bc`(Binary Calculator)
        
## N 剪切板xsel
```bash
cat README.TXT | xsel  
# 如有问题可以试试-b选项
cat README.TXT | xsel -b 
# 将readme.txt的文本放入剪贴板
xsel < README.TXT  
# 清空剪贴板
xsel -c  
```


# 四 高级
## 1 linux系统主要目录说明

|目录|评论|
|---|:--|
|/	|根目录，万物起源。|
|/bin|包含系统启动和运行所必须的二进制程序.|
|/boot|包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。|
|/dev|这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。|
|/etc|这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。|
|/home|	在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。|
|/lib|	包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。|
|/lost+found|	每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统 真正的损坏了，那么这个目录会是个空目录。|
|/media|	在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。|
|/mnt	|在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。|
|/opt|	这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。|
|/proc|	这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。|
|/root|	root 帐户的家目录。|
|/sbin	|这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。|
|/tmp	|这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。|
|/usr|	在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。|
|/usr/bin	|/usr/bin 目录包含系统安装的可执行程序。大多数系统程序的安装目录|
|/usr/lib	|包含由/usr/bin 目录中的程序所用的共享库。|
|/usr/local|	这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在这个目录， 但却是空目录，直到系统管理员放些东西到它里面。|
|/usr/sbin|	包含许多系统管理程序。|
|/usr/share|	/usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。|
|/usr/share/doc|	大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。|
|/var|	除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。|
|/var/log|	这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。|

## 2 linux的虚拟化技术:XEN,openvz和KVM
待整理

## 3 cron

### 3.1 cron表达式
参考：https://www.cnblogs.com/linjiqin/archive/2013/07/08/3178452.html

格式有两种：
- Seconds Minutes Hours DayofMonth Month DayofWeek Year
- Seconds Minutes Hours DayofMonth Month DayofWeek

## 4 包管理
### 4.1 snap
听说Snap将成为支持所有 GNU/Linux 发行版的通用二进制软件包格式，Snap能使一个单一的二进制程序包可以完美、安全地运行在任何Linux台式机、服务器、云或物联网设备上。大佬说的：“在一个私有仓库中维护一个 .deb 软件包是复杂而耗时的,而 Snap 更容易维护、打包和分发”，官网是：snapcraft.io

Snap：是一种安全的、易于安装的、沙盒化的软件包格式。

snapcraft：涵盖了 snap 和用来构建它们的命令行工具。

特点：
1. 包含应用所需运行的所有dependence，包含了所有它需要运行的环境。代价就是包会比较大
2. 你可以100％确定你的应用不会因为任何在应用之外的变化的改变而导致你的应用不 能正常运行，比如卸载一个Java应用不会导致其它Java应用的运行．安装一个使用不同版本的Java JDK/OpenJDK的Java应用，不会干扰现有的任何一个运行在不同JDK/OpenJDK版本的Java应用

常用操作：`find`,`list`,`install`,`refresh`,`remove`,`revert`
1. `changes`：更改记录

# 六 问题
## 1 已解决
## 2 未解决
1. 学会使用linux联机帮助
2. 在命令行执行命令的时候输入命令会怎么样
3. linux的鼠标中键表示什么？
4. 移动到终端正在输入的命令前后面快捷键
5. linux的计算器？
6. sbin
7. 删除包和依赖呢？
```bash
dpkg -P package #删除包（包括配置文件）
dpkg -L package #列出与该包关联的文件
```
8. linux按时间顺序排列
9. man 3 xxx
10. dpkg所有参数在哪儿看
11. 为什么`./`是运行，可以加在最后?
12. 知道 Linux 下最大的坑是什么么？就是动态链接库。
为什么 Linux 大部分软件都要求编译安装，就是因为动态链接库。
13. linux和mac上各种格式包的安装和区别
14. 内容太多终端显示不完怎么办，终端中如何翻页等
16. copy的几种方式，除了cp还有什么
17. 关于软链接和硬链接
    1. 硬链接:与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块
    2. 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。
    3. 硬链接的实现原理是怎么样的?
    3. 参考:[http://www.jianshu.com/p/dde6a01c4094](http://www.jianshu.com/p/dde6a01c4094)
18. linux的命令一共有4中,除了type识别的三种还有:shell函数(即小型shell脚本)?
19. gdb调试工具
20. sftp:[https://jingyan.baidu.com/article/c910274be7bc6acd361d2da7.html](https://jingyan.baidu.com/article/c910274be7bc6acd361d2da7.html)
21. linux cheat
22. [命令行的艺术:linux bash命令大全详解](http://ourjs.com/detail/5923d49cf1239006149616a6)
23. `init.d`

24. linux tty是啥
26. 远程如何连到局域网内的机子？就是如何把linux弄成可以外网访问的?
27. tty -s