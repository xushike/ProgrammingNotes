# readingNotes
[TOC]
## 一. 待读
1. 知乎“你会如何重新学习编程？”回答中推荐的书籍  
2. 豆瓣读书回答中推荐的书：https://book.douban.com/review/3030002/#comments
3. 卡耐基《人性的弱点》
## 二. 值得读
## 三. 读书笔记
### 1 《深入理解java虚拟机：jvm高级特性与最佳实践》
1. 网友说该书有个别瑕疵，可以参考R大对此书的读出笔记，豆瓣可见。（待补充）
2. sun官方定义的java技术体系包括以下几个组成部分
### 2 《java核心技术 卷1 基础知识》
1. 
### 3 《Thinking In Java(java编程思想)》第四版（豆瓣9.1分）
#### 3.1 主要笔记
1. 汽车和轮子的发明都非常重要，但他们最终亦如此而已。真正重要的还是我们与世界的关系，而其中最关键的就是通信。
2. 贯穿本书，我试图在您的大脑里建立一个模型——或者说一个“知识结构”。这样可加深对语言的理解。若遇到难解之处，应学会把它填入这个模型的对应地方，然后自行演绎出答案。事实上，学习任何语言时，脑海里有一个现成的知识结构往往会起到事半功倍的效果。
3. 我认为信息的重要程度是存在一个合理的层次的。有些情况是95％的程序员都永远不必了解的。如强行学习，只会干扰他们的正常思维，从而加深语言在他们面前表现出来的难度。以C 语言为例，假如你能记住运算符优先次序表（我从来记不住），那么就可以写出更“聪明”的代码。但再深入想一层，那也会使代码的读者／维护者感到困扰。所以忘了那些次序吧，在拿不准的时候加上括号即可。
4. Java 配套提供了数量众多的现成类型。对我们来讲，最重要的就是记住能自行创建类型。
#### 3.4 上溯造型
把衍生类型当作它的基本类型处理的过程叫作“Upcasting”（上溯造型）
比如
```Java
void doStuff(Shape s) {
s.erase();
// ...
s.draw();
}
```
当我传进去一个Circle、Triangle或者Line也会正确工作，因为这些都是继承的Shape。这样最直接的好处就是不用为每一个形状单独去写那么多代码，也是java多态的体现。
#### 3.5 Iterator迭代器
单选定函数的功能是非常有限的。如果想对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，这时又该怎么办呢？可以使用Iterator，它属于一种对象，负责选择集合内的元素，并把它们提供给继
承器的用户。作为一个类，它也提供了一级抽象。利用这一级抽象，可将集合细节与用于访问那个集合的代
码隔离开。通过继承器的作用，集合被抽象成一个简单的序列。继承器允许我们遍历那个序列，同时毋需关
心基础结构是什么
#### 3.6 矢量（Vector）和列表（List）的区别
它们都属于简单的序列，拥有完全一致的接口和外部行为。但在执行一些特定的任务时，需要的开销
却是完全不同的。对矢量内的元素进行的随机访问（存取）是一种常时操作；无论我们选择的选择是什么，
需要的时间量都是相同的。但在一个链接列表中，若想到处移动，并随机挑选一个元素，就需付出“惨重”
的代价。而且假设某个元素位于列表较远的地方，找到它所需的时间也会长许多。但在另一方面，如果想在
序列中部插入一个元素，用列表就比用矢量划算得多。
#### 3.7 单根结构的优点
java所有对象都继承自Object，这就是单根结构
1. 极大简化参数的传递
2. 更方便地实现一个垃圾收集器
#### 3.8 下溯造型
存进集合的对象会被自动转为Object，取出来的时候就需要用到下溯造型了
#### 3.9 handle和handler
前者在java里经常被翻译为句柄、引用或者指针，后者根据网友的解释可翻译为回调函数
#### 3.10 native method
### 4 《疯狂java讲义 李刚（第三版）》
#### 4.1 主要笔记
1. 编程的本质，就是对内存中数据的访问和修改。编程的机制就是通过变量。 
2. 无论哪种编程语言，都会提供两种基本的流程控制结构：分支结构和循环结构。
3. 不要把系统搞糊涂了，系统一糊涂就是你错了。
#### 4.2 常量池（constant pool）
常量池指在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括关于类、方法、接口中的常量，也包括字符串直接量。（我觉得这里的常量池应该指的每个class自带的常量池）
### 5 《goinactiongo语言实战》
### 6 《The Linux Command Line》
#### 6.1 主要笔记
1. 人们说，“图形用户界面让简单的任务更容易完成， 而命令行界面使完成复杂的任务成为可能”，到现在这句话仍然很正确。
>It’s been said that “graphical user interfaces make easy tasks easy, while command line interfaces make difficult tasks possible” and this is still very true today.